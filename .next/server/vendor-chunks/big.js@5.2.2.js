"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/big.js@5.2.2";
exports.ids = ["vendor-chunks/big.js@5.2.2"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/big.js@5.2.2/node_modules/big.js/big.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/.pnpm/big.js@5.2.2/node_modules/big.js/big.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Big: () => (/* binding */ Big),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\r\n *  big.js v5.2.2\r\n *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.\r\n *  Copyright (c) 2018 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *  https://github.com/MikeMcl/big.js/LICENCE\r\n */ /************************************** EDITABLE DEFAULTS *****************************************/ // The default values below must be integers within the stated ranges.\n/*\r\n   * The maximum number of decimal places (DP) of the results of operations involving division:\r\n   * div and sqrt, and pow with negative exponents.\r\n   */ var DP = 20, /*\r\n   * The rounding mode (RM) used when rounding to the above decimal places.\r\n   *\r\n   *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)\r\n   *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)\r\n   *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)\r\n   *  3  Away from zero.                                  (ROUND_UP)\r\n   */ RM = 1, // The maximum value of DP and Big.DP.\nMAX_DP = 1E6, // The maximum magnitude of the exponent argument to the pow method.\nMAX_POWER = 1E6, /*\r\n   * The negative exponent (NE) at and beneath which toString returns exponential notation.\r\n   * (JavaScript numbers: -7)\r\n   * -1000000 is the minimum recommended exponent value of a Big.\r\n   */ NE = -7, /*\r\n   * The positive exponent (PE) at and above which toString returns exponential notation.\r\n   * (JavaScript numbers: 21)\r\n   * 1000000 is the maximum recommended exponent value of a Big.\r\n   * (This limit is not enforced or checked.)\r\n   */ PE = 21, /**************************************************************************************************/ // Error messages.\nNAME = \"[big.js] \", INVALID = NAME + \"Invalid \", INVALID_DP = INVALID + \"decimal places\", INVALID_RM = INVALID + \"rounding mode\", DIV_BY_ZERO = NAME + \"Division by zero\", // The shared prototype object.\nP = {}, UNDEFINED = void 0, NUMERIC = /^-?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i;\n/*\r\n * Create and return a Big constructor.\r\n *\r\n */ function _Big_() {\n    /*\r\n   * The Big constructor and exported function.\r\n   * Create and return a new instance of a Big number object.\r\n   *\r\n   * n {number|string|Big} A numeric value.\r\n   */ function Big(n) {\n        var x = this;\n        // Enable constructor usage without new.\n        if (!(x instanceof Big)) return n === UNDEFINED ? _Big_() : new Big(n);\n        // Duplicate.\n        if (n instanceof Big) {\n            x.s = n.s;\n            x.e = n.e;\n            x.c = n.c.slice();\n        } else {\n            parse(x, n);\n        }\n        /*\r\n     * Retain a reference to this Big constructor, and shadow Big.prototype.constructor which\r\n     * points to Object.\r\n     */ x.constructor = Big;\n    }\n    Big.prototype = P;\n    Big.DP = DP;\n    Big.RM = RM;\n    Big.NE = NE;\n    Big.PE = PE;\n    Big.version = \"5.2.2\";\n    return Big;\n}\n/*\r\n * Parse the number or string value passed to a Big constructor.\r\n *\r\n * x {Big} A Big number instance.\r\n * n {number|string} A numeric value.\r\n */ function parse(x, n) {\n    var e, i, nl;\n    // Minus zero?\n    if (n === 0 && 1 / n < 0) n = \"-0\";\n    else if (!NUMERIC.test(n += \"\")) throw Error(INVALID + \"number\");\n    // Determine sign.\n    x.s = n.charAt(0) == \"-\" ? (n = n.slice(1), -1) : 1;\n    // Decimal point?\n    if ((e = n.indexOf(\".\")) > -1) n = n.replace(\".\", \"\");\n    // Exponential form?\n    if ((i = n.search(/e/i)) > 0) {\n        // Determine exponent.\n        if (e < 0) e = i;\n        e += +n.slice(i + 1);\n        n = n.substring(0, i);\n    } else if (e < 0) {\n        // Integer.\n        e = n.length;\n    }\n    nl = n.length;\n    // Determine leading zeros.\n    for(i = 0; i < nl && n.charAt(i) == \"0\";)++i;\n    if (i == nl) {\n        // Zero.\n        x.c = [\n            x.e = 0\n        ];\n    } else {\n        // Determine trailing zeros.\n        for(; nl > 0 && n.charAt(--nl) == \"0\";);\n        x.e = e - i - 1;\n        x.c = [];\n        // Convert string to array of digits without leading/trailing zeros.\n        for(e = 0; i <= nl;)x.c[e++] = +n.charAt(i++);\n    }\n    return x;\n}\n/*\r\n * Round Big x to a maximum of dp decimal places using rounding mode rm.\r\n * Called by stringify, P.div, P.round and P.sqrt.\r\n *\r\n * x {Big} The Big to round.\r\n * dp {number} Integer, 0 to MAX_DP inclusive.\r\n * rm {number} 0, 1, 2 or 3 (DOWN, HALF_UP, HALF_EVEN, UP)\r\n * [more] {boolean} Whether the result of division was truncated.\r\n */ function round(x, dp, rm, more) {\n    var xc = x.c, i = x.e + dp + 1;\n    if (i < xc.length) {\n        if (rm === 1) {\n            // xc[i] is the digit after the digit that may be rounded up.\n            more = xc[i] >= 5;\n        } else if (rm === 2) {\n            more = xc[i] > 5 || xc[i] == 5 && (more || i < 0 || xc[i + 1] !== UNDEFINED || xc[i - 1] & 1);\n        } else if (rm === 3) {\n            more = more || !!xc[0];\n        } else {\n            more = false;\n            if (rm !== 0) throw Error(INVALID_RM);\n        }\n        if (i < 1) {\n            xc.length = 1;\n            if (more) {\n                // 1, 0.1, 0.01, 0.001, 0.0001 etc.\n                x.e = -dp;\n                xc[0] = 1;\n            } else {\n                // Zero.\n                xc[0] = x.e = 0;\n            }\n        } else {\n            // Remove any digits after the required decimal places.\n            xc.length = i--;\n            // Round up?\n            if (more) {\n                // Rounding up may mean the previous digit has to be rounded up.\n                for(; ++xc[i] > 9;){\n                    xc[i] = 0;\n                    if (!i--) {\n                        ++x.e;\n                        xc.unshift(1);\n                    }\n                }\n            }\n            // Remove trailing zeros.\n            for(i = xc.length; !xc[--i];)xc.pop();\n        }\n    } else if (rm < 0 || rm > 3 || rm !== ~~rm) {\n        throw Error(INVALID_RM);\n    }\n    return x;\n}\n/*\r\n * Return a string representing the value of Big x in normal or exponential notation.\r\n * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.\r\n *\r\n * x {Big}\r\n * id? {number} Caller id.\r\n *         1 toExponential\r\n *         2 toFixed\r\n *         3 toPrecision\r\n *         4 valueOf\r\n * n? {number|undefined} Caller's argument.\r\n * k? {number|undefined}\r\n */ function stringify(x, id, n, k) {\n    var e, s, Big = x.constructor, z = !x.c[0];\n    if (n !== UNDEFINED) {\n        if (n !== ~~n || n < (id == 3) || n > MAX_DP) {\n            throw Error(id == 3 ? INVALID + \"precision\" : INVALID_DP);\n        }\n        x = new Big(x);\n        // The index of the digit that may be rounded up.\n        n = k - x.e;\n        // Round?\n        if (x.c.length > ++k) round(x, n, Big.RM);\n        // toFixed: recalculate k as x.e may have changed if value rounded up.\n        if (id == 2) k = x.e + n + 1;\n        // Append zeros?\n        for(; x.c.length < k;)x.c.push(0);\n    }\n    e = x.e;\n    s = x.c.join(\"\");\n    n = s.length;\n    // Exponential notation?\n    if (id != 2 && (id == 1 || id == 3 && k <= e || e <= Big.NE || e >= Big.PE)) {\n        s = s.charAt(0) + (n > 1 ? \".\" + s.slice(1) : \"\") + (e < 0 ? \"e\" : \"e+\") + e;\n    // Normal notation.\n    } else if (e < 0) {\n        for(; ++e;)s = \"0\" + s;\n        s = \"0.\" + s;\n    } else if (e > 0) {\n        if (++e > n) for(e -= n; e--;)s += \"0\";\n        else if (e < n) s = s.slice(0, e) + \".\" + s.slice(e);\n    } else if (n > 1) {\n        s = s.charAt(0) + \".\" + s.slice(1);\n    }\n    return x.s < 0 && (!z || id == 4) ? \"-\" + s : s;\n}\n// Prototype/instance methods\n/*\r\n * Return a new Big whose value is the absolute value of this Big.\r\n */ P.abs = function() {\n    var x = new this.constructor(this);\n    x.s = 1;\n    return x;\n};\n/*\r\n * Return 1 if the value of this Big is greater than the value of Big y,\r\n *       -1 if the value of this Big is less than the value of Big y, or\r\n *        0 if they have the same value.\r\n*/ P.cmp = function(y) {\n    var isneg, x = this, xc = x.c, yc = (y = new x.constructor(y)).c, i = x.s, j = y.s, k = x.e, l = y.e;\n    // Either zero?\n    if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;\n    // Signs differ?\n    if (i != j) return i;\n    isneg = i < 0;\n    // Compare exponents.\n    if (k != l) return k > l ^ isneg ? 1 : -1;\n    j = (k = xc.length) < (l = yc.length) ? k : l;\n    // Compare digit by digit.\n    for(i = -1; ++i < j;){\n        if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;\n    }\n    // Compare lengths.\n    return k == l ? 0 : k > l ^ isneg ? 1 : -1;\n};\n/*\r\n * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,\r\n * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\r\n */ P.div = function(y) {\n    var x = this, Big = x.constructor, a = x.c, b = (y = new Big(y)).c, k = x.s == y.s ? 1 : -1, dp = Big.DP;\n    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) throw Error(INVALID_DP);\n    // Divisor is zero?\n    if (!b[0]) throw Error(DIV_BY_ZERO);\n    // Dividend is 0? Return +-0.\n    if (!a[0]) return new Big(k * 0);\n    var bl, bt, n, cmp, ri, bz = b.slice(), ai = bl = b.length, al = a.length, r = a.slice(0, bl), rl = r.length, q = y, qc = q.c = [], qi = 0, d = dp + (q.e = x.e - y.e) + 1; // number of digits of the result\n    q.s = k;\n    k = d < 0 ? 0 : d;\n    // Create version of divisor with leading zero.\n    bz.unshift(0);\n    // Add zeros to make remainder as long as divisor.\n    for(; rl++ < bl;)r.push(0);\n    do {\n        // n is how many times the divisor goes into current remainder.\n        for(n = 0; n < 10; n++){\n            // Compare divisor and remainder.\n            if (bl != (rl = r.length)) {\n                cmp = bl > rl ? 1 : -1;\n            } else {\n                for(ri = -1, cmp = 0; ++ri < bl;){\n                    if (b[ri] != r[ri]) {\n                        cmp = b[ri] > r[ri] ? 1 : -1;\n                        break;\n                    }\n                }\n            }\n            // If divisor < remainder, subtract divisor from remainder.\n            if (cmp < 0) {\n                // Remainder can't be more than 1 digit longer than divisor.\n                // Equalise lengths using divisor with extra leading zero?\n                for(bt = rl == bl ? b : bz; rl;){\n                    if (r[--rl] < bt[rl]) {\n                        ri = rl;\n                        for(; ri && !r[--ri];)r[ri] = 9;\n                        --r[ri];\n                        r[rl] += 10;\n                    }\n                    r[rl] -= bt[rl];\n                }\n                for(; !r[0];)r.shift();\n            } else {\n                break;\n            }\n        }\n        // Add the digit n to the result array.\n        qc[qi++] = cmp ? n : ++n;\n        // Update the remainder.\n        if (r[0] && cmp) r[rl] = a[ai] || 0;\n        else r = [\n            a[ai]\n        ];\n    }while ((ai++ < al || r[0] !== UNDEFINED) && k--);\n    // Leading zero? Do not remove if result is simply zero (qi == 1).\n    if (!qc[0] && qi != 1) {\n        // There can't be more than one zero.\n        qc.shift();\n        q.e--;\n    }\n    // Round?\n    if (qi > d) round(q, dp, Big.RM, r[0] !== UNDEFINED);\n    return q;\n};\n/*\r\n * Return true if the value of this Big is equal to the value of Big y, otherwise return false.\r\n */ P.eq = function(y) {\n    return !this.cmp(y);\n};\n/*\r\n * Return true if the value of this Big is greater than the value of Big y, otherwise return\r\n * false.\r\n */ P.gt = function(y) {\n    return this.cmp(y) > 0;\n};\n/*\r\n * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise\r\n * return false.\r\n */ P.gte = function(y) {\n    return this.cmp(y) > -1;\n};\n/*\r\n * Return true if the value of this Big is less than the value of Big y, otherwise return false.\r\n */ P.lt = function(y) {\n    return this.cmp(y) < 0;\n};\n/*\r\n * Return true if the value of this Big is less than or equal to the value of Big y, otherwise\r\n * return false.\r\n */ P.lte = function(y) {\n    return this.cmp(y) < 1;\n};\n/*\r\n * Return a new Big whose value is the value of this Big minus the value of Big y.\r\n */ P.minus = P.sub = function(y) {\n    var i, j, t, xlty, x = this, Big = x.constructor, a = x.s, b = (y = new Big(y)).s;\n    // Signs differ?\n    if (a != b) {\n        y.s = -b;\n        return x.plus(y);\n    }\n    var xc = x.c.slice(), xe = x.e, yc = y.c, ye = y.e;\n    // Either zero?\n    if (!xc[0] || !yc[0]) {\n        // y is non-zero? x is non-zero? Or both are zero.\n        return yc[0] ? (y.s = -b, y) : new Big(xc[0] ? x : 0);\n    }\n    // Determine which is the bigger number. Prepend zeros to equalise exponents.\n    if (a = xe - ye) {\n        if (xlty = a < 0) {\n            a = -a;\n            t = xc;\n        } else {\n            ye = xe;\n            t = yc;\n        }\n        t.reverse();\n        for(b = a; b--;)t.push(0);\n        t.reverse();\n    } else {\n        // Exponents equal. Check digit by digit.\n        j = ((xlty = xc.length < yc.length) ? xc : yc).length;\n        for(a = b = 0; b < j; b++){\n            if (xc[b] != yc[b]) {\n                xlty = xc[b] < yc[b];\n                break;\n            }\n        }\n    }\n    // x < y? Point xc to the array of the bigger number.\n    if (xlty) {\n        t = xc;\n        xc = yc;\n        yc = t;\n        y.s = -y.s;\n    }\n    /*\r\n   * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only\r\n   * needs to start at yc.length.\r\n   */ if ((b = (j = yc.length) - (i = xc.length)) > 0) for(; b--;)xc[i++] = 0;\n    // Subtract yc from xc.\n    for(b = i; j > a;){\n        if (xc[--j] < yc[j]) {\n            for(i = j; i && !xc[--i];)xc[i] = 9;\n            --xc[i];\n            xc[j] += 10;\n        }\n        xc[j] -= yc[j];\n    }\n    // Remove trailing zeros.\n    for(; xc[--b] === 0;)xc.pop();\n    // Remove leading zeros and adjust exponent accordingly.\n    for(; xc[0] === 0;){\n        xc.shift();\n        --ye;\n    }\n    if (!xc[0]) {\n        // n - n = +0\n        y.s = 1;\n        // Result must be zero.\n        xc = [\n            ye = 0\n        ];\n    }\n    y.c = xc;\n    y.e = ye;\n    return y;\n};\n/*\r\n * Return a new Big whose value is the value of this Big modulo the value of Big y.\r\n */ P.mod = function(y) {\n    var ygtx, x = this, Big = x.constructor, a = x.s, b = (y = new Big(y)).s;\n    if (!y.c[0]) throw Error(DIV_BY_ZERO);\n    x.s = y.s = 1;\n    ygtx = y.cmp(x) == 1;\n    x.s = a;\n    y.s = b;\n    if (ygtx) return new Big(x);\n    a = Big.DP;\n    b = Big.RM;\n    Big.DP = Big.RM = 0;\n    x = x.div(y);\n    Big.DP = a;\n    Big.RM = b;\n    return this.minus(x.times(y));\n};\n/*\r\n * Return a new Big whose value is the value of this Big plus the value of Big y.\r\n */ P.plus = P.add = function(y) {\n    var t, x = this, Big = x.constructor, a = x.s, b = (y = new Big(y)).s;\n    // Signs differ?\n    if (a != b) {\n        y.s = -b;\n        return x.minus(y);\n    }\n    var xe = x.e, xc = x.c, ye = y.e, yc = y.c;\n    // Either zero? y is non-zero? x is non-zero? Or both are zero.\n    if (!xc[0] || !yc[0]) return yc[0] ? y : new Big(xc[0] ? x : a * 0);\n    xc = xc.slice();\n    // Prepend zeros to equalise exponents.\n    // Note: reverse faster than unshifts.\n    if (a = xe - ye) {\n        if (a > 0) {\n            ye = xe;\n            t = yc;\n        } else {\n            a = -a;\n            t = xc;\n        }\n        t.reverse();\n        for(; a--;)t.push(0);\n        t.reverse();\n    }\n    // Point xc to the longer array.\n    if (xc.length - yc.length < 0) {\n        t = yc;\n        yc = xc;\n        xc = t;\n    }\n    a = yc.length;\n    // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.\n    for(b = 0; a; xc[a] %= 10)b = (xc[--a] = xc[a] + yc[a] + b) / 10 | 0;\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\n    if (b) {\n        xc.unshift(b);\n        ++ye;\n    }\n    // Remove trailing zeros.\n    for(a = xc.length; xc[--a] === 0;)xc.pop();\n    y.c = xc;\n    y.e = ye;\n    return y;\n};\n/*\r\n * Return a Big whose value is the value of this Big raised to the power n.\r\n * If n is negative, round to a maximum of Big.DP decimal places using rounding\r\n * mode Big.RM.\r\n *\r\n * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.\r\n */ P.pow = function(n) {\n    var x = this, one = new x.constructor(1), y = one, isneg = n < 0;\n    if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) throw Error(INVALID + \"exponent\");\n    if (isneg) n = -n;\n    for(;;){\n        if (n & 1) y = y.times(x);\n        n >>= 1;\n        if (!n) break;\n        x = x.times(x);\n    }\n    return isneg ? one.div(y) : y;\n};\n/*\r\n * Return a new Big whose value is the value of this Big rounded using rounding mode rm\r\n * to a maximum of dp decimal places, or, if dp is negative, to an integer which is a\r\n * multiple of 10**-dp.\r\n * If dp is not specified, round to 0 decimal places.\r\n * If rm is not specified, use Big.RM.\r\n *\r\n * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.\r\n * rm? 0, 1, 2 or 3 (ROUND_DOWN, ROUND_HALF_UP, ROUND_HALF_EVEN, ROUND_UP)\r\n */ P.round = function(dp, rm) {\n    var Big = this.constructor;\n    if (dp === UNDEFINED) dp = 0;\n    else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) throw Error(INVALID_DP);\n    return round(new Big(this), dp, rm === UNDEFINED ? Big.RM : rm);\n};\n/*\r\n * Return a new Big whose value is the square root of the value of this Big, rounded, if\r\n * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\r\n */ P.sqrt = function() {\n    var r, c, t, x = this, Big = x.constructor, s = x.s, e = x.e, half = new Big(0.5);\n    // Zero?\n    if (!x.c[0]) return new Big(x);\n    // Negative?\n    if (s < 0) throw Error(NAME + \"No square root\");\n    // Estimate.\n    s = Math.sqrt(x + \"\");\n    // Math.sqrt underflow/overflow?\n    // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.\n    if (s === 0 || s === 1 / 0) {\n        c = x.c.join(\"\");\n        if (!(c.length + e & 1)) c += \"0\";\n        s = Math.sqrt(c);\n        e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);\n        r = new Big((s == 1 / 0 ? \"1e\" : (s = s.toExponential()).slice(0, s.indexOf(\"e\") + 1)) + e);\n    } else {\n        r = new Big(s);\n    }\n    e = r.e + (Big.DP += 4);\n    // Newton-Raphson iteration.\n    do {\n        t = r;\n        r = half.times(t.plus(x.div(t)));\n    }while (t.c.slice(0, e).join(\"\") !== r.c.slice(0, e).join(\"\"));\n    return round(r, Big.DP -= 4, Big.RM);\n};\n/*\r\n * Return a new Big whose value is the value of this Big times the value of Big y.\r\n */ P.times = P.mul = function(y) {\n    var c, x = this, Big = x.constructor, xc = x.c, yc = (y = new Big(y)).c, a = xc.length, b = yc.length, i = x.e, j = y.e;\n    // Determine sign of result.\n    y.s = x.s == y.s ? 1 : -1;\n    // Return signed 0 if either 0.\n    if (!xc[0] || !yc[0]) return new Big(y.s * 0);\n    // Initialise exponent of result as x.e + y.e.\n    y.e = i + j;\n    // If array xc has fewer digits than yc, swap xc and yc, and lengths.\n    if (a < b) {\n        c = xc;\n        xc = yc;\n        yc = c;\n        j = a;\n        a = b;\n        b = j;\n    }\n    // Initialise coefficient array of result with zeros.\n    for(c = new Array(j = a + b); j--;)c[j] = 0;\n    // Multiply.\n    // i is initially xc.length.\n    for(i = b; i--;){\n        b = 0;\n        // a is yc.length.\n        for(j = a + i; j > i;){\n            // Current sum of products at this digit position, plus carry.\n            b = c[j] + yc[i] * xc[j - i - 1] + b;\n            c[j--] = b % 10;\n            // carry\n            b = b / 10 | 0;\n        }\n        c[j] = (c[j] + b) % 10;\n    }\n    // Increment result exponent if there is a final carry, otherwise remove leading zero.\n    if (b) ++y.e;\n    else c.shift();\n    // Remove trailing zeros.\n    for(i = c.length; !c[--i];)c.pop();\n    y.c = c;\n    return y;\n};\n/*\r\n * Return a string representing the value of this Big in exponential notation to dp fixed decimal\r\n * places and rounded using Big.RM.\r\n *\r\n * dp? {number} Integer, 0 to MAX_DP inclusive.\r\n */ P.toExponential = function(dp) {\n    return stringify(this, 1, dp, dp);\n};\n/*\r\n * Return a string representing the value of this Big in normal notation to dp fixed decimal\r\n * places and rounded using Big.RM.\r\n *\r\n * dp? {number} Integer, 0 to MAX_DP inclusive.\r\n *\r\n * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n */ P.toFixed = function(dp) {\n    return stringify(this, 2, dp, this.e + dp);\n};\n/*\r\n * Return a string representing the value of this Big rounded to sd significant digits using\r\n * Big.RM. Use exponential notation if sd is less than the number of digits necessary to represent\r\n * the integer part of the value in normal notation.\r\n *\r\n * sd {number} Integer, 1 to MAX_DP inclusive.\r\n */ P.toPrecision = function(sd) {\n    return stringify(this, 3, sd, sd - 1);\n};\n/*\r\n * Return a string representing the value of this Big.\r\n * Return exponential notation if this Big has a positive exponent equal to or greater than\r\n * Big.PE, or a negative exponent equal to or less than Big.NE.\r\n * Omit the sign for negative zero.\r\n */ P.toString = function() {\n    return stringify(this);\n};\n/*\r\n * Return a string representing the value of this Big.\r\n * Return exponential notation if this Big has a positive exponent equal to or greater than\r\n * Big.PE, or a negative exponent equal to or less than Big.NE.\r\n * Include the sign for negative zero.\r\n */ P.valueOf = P.toJSON = function() {\n    return stringify(this, 4);\n};\n// Export\nvar Big = _Big_();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Big);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYmlnLmpzQDUuMi4yL25vZGVfbW9kdWxlcy9iaWcuanMvYmlnLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7OztDQUtDLEdBR0Qsa0dBQWtHLEdBR2hHLHNFQUFzRTtBQUV0RTs7O0dBR0MsR0FDSCxJQUFJQSxLQUFLLElBRVA7Ozs7Ozs7R0FPQyxHQUNEQyxLQUFLLEdBRUwsc0NBQXNDO0FBQ3RDQyxTQUFTLEtBRVQsb0VBQW9FO0FBQ3BFQyxZQUFZLEtBRVo7Ozs7R0FJQyxHQUNEQyxLQUFLLENBQUMsR0FFTjs7Ozs7R0FLQyxHQUNEQyxLQUFLLElBR1Asa0dBQWtHLEdBR2hHLGtCQUFrQjtBQUNsQkMsT0FBTyxhQUNQQyxVQUFVRCxPQUFPLFlBQ2pCRSxhQUFhRCxVQUFVLGtCQUN2QkUsYUFBYUYsVUFBVSxpQkFDdkJHLGNBQWNKLE9BQU8sb0JBRXJCLCtCQUErQjtBQUMvQkssSUFBSSxDQUFDLEdBQ0xDLFlBQVksS0FBSyxHQUNqQkMsVUFBVTtBQUdaOzs7Q0FHQyxHQUNELFNBQVNDO0lBRVA7Ozs7O0dBS0MsR0FDRCxTQUFTQyxJQUFJQyxDQUFDO1FBQ1osSUFBSUMsSUFBSSxJQUFJO1FBRVosd0NBQXdDO1FBQ3hDLElBQUksQ0FBRUEsQ0FBQUEsYUFBYUYsR0FBRSxHQUFJLE9BQU9DLE1BQU1KLFlBQVlFLFVBQVUsSUFBSUMsSUFBSUM7UUFFcEUsYUFBYTtRQUNiLElBQUlBLGFBQWFELEtBQUs7WUFDcEJFLEVBQUVDLENBQUMsR0FBR0YsRUFBRUUsQ0FBQztZQUNURCxFQUFFRSxDQUFDLEdBQUdILEVBQUVHLENBQUM7WUFDVEYsRUFBRUcsQ0FBQyxHQUFHSixFQUFFSSxDQUFDLENBQUNDLEtBQUs7UUFDakIsT0FBTztZQUNMQyxNQUFNTCxHQUFHRDtRQUNYO1FBRUE7OztLQUdDLEdBQ0RDLEVBQUVNLFdBQVcsR0FBR1I7SUFDbEI7SUFFQUEsSUFBSVMsU0FBUyxHQUFHYjtJQUNoQkksSUFBSWYsRUFB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YWNrOi8vcG9vbC5ndXJ1Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpZy5qc0A1LjIuMi9ub2RlX21vZHVsZXMvYmlnLmpzL2JpZy5tanM/MmY4NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiAgYmlnLmpzIHY1LjIuMlxyXG4gKiAgQSBzbWFsbCwgZmFzdCwgZWFzeS10by11c2UgbGlicmFyeSBmb3IgYXJiaXRyYXJ5LXByZWNpc2lvbiBkZWNpbWFsIGFyaXRobWV0aWMuXHJcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTggTWljaGFlbCBNY2xhdWdobGluIDxNOGNoODhsQGdtYWlsLmNvbT5cclxuICogIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZy5qcy9MSUNFTkNFXHJcbiAqL1xyXG5cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBFRElUQUJMRSBERUZBVUxUUyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblxyXG4gIC8vIFRoZSBkZWZhdWx0IHZhbHVlcyBiZWxvdyBtdXN0IGJlIGludGVnZXJzIHdpdGhpbiB0aGUgc3RhdGVkIHJhbmdlcy5cclxuXHJcbiAgLypcclxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgKERQKSBvZiB0aGUgcmVzdWx0cyBvZiBvcGVyYXRpb25zIGludm9sdmluZyBkaXZpc2lvbjpcclxuICAgKiBkaXYgYW5kIHNxcnQsIGFuZCBwb3cgd2l0aCBuZWdhdGl2ZSBleHBvbmVudHMuXHJcbiAgICovXHJcbnZhciBEUCA9IDIwLCAgICAgICAgICAvLyAwIHRvIE1BWF9EUFxyXG5cclxuICAvKlxyXG4gICAqIFRoZSByb3VuZGluZyBtb2RlIChSTSkgdXNlZCB3aGVuIHJvdW5kaW5nIHRvIHRoZSBhYm92ZSBkZWNpbWFsIHBsYWNlcy5cclxuICAgKlxyXG4gICAqICAwICBUb3dhcmRzIHplcm8gKGkuZS4gdHJ1bmNhdGUsIG5vIHJvdW5kaW5nKS4gICAgICAgKFJPVU5EX0RPV04pXHJcbiAgICogIDEgIFRvIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgcm91bmQgdXAuICAoUk9VTkRfSEFMRl9VUClcclxuICAgKiAgMiAgVG8gbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0byBldmVuLiAgIChST1VORF9IQUxGX0VWRU4pXHJcbiAgICogIDMgIEF3YXkgZnJvbSB6ZXJvLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoUk9VTkRfVVApXHJcbiAgICovXHJcbiAgUk0gPSAxLCAgICAgICAgICAgICAvLyAwLCAxLCAyIG9yIDNcclxuXHJcbiAgLy8gVGhlIG1heGltdW0gdmFsdWUgb2YgRFAgYW5kIEJpZy5EUC5cclxuICBNQVhfRFAgPSAxRTYsICAgICAgIC8vIDAgdG8gMTAwMDAwMFxyXG5cclxuICAvLyBUaGUgbWF4aW11bSBtYWduaXR1ZGUgb2YgdGhlIGV4cG9uZW50IGFyZ3VtZW50IHRvIHRoZSBwb3cgbWV0aG9kLlxyXG4gIE1BWF9QT1dFUiA9IDFFNiwgICAgLy8gMSB0byAxMDAwMDAwXHJcblxyXG4gIC8qXHJcbiAgICogVGhlIG5lZ2F0aXZlIGV4cG9uZW50IChORSkgYXQgYW5kIGJlbmVhdGggd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgKiAoSmF2YVNjcmlwdCBudW1iZXJzOiAtNylcclxuICAgKiAtMTAwMDAwMCBpcyB0aGUgbWluaW11bSByZWNvbW1lbmRlZCBleHBvbmVudCB2YWx1ZSBvZiBhIEJpZy5cclxuICAgKi9cclxuICBORSA9IC03LCAgICAgICAgICAgIC8vIDAgdG8gLTEwMDAwMDBcclxuXHJcbiAgLypcclxuICAgKiBUaGUgcG9zaXRpdmUgZXhwb25lbnQgKFBFKSBhdCBhbmQgYWJvdmUgd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgKiAoSmF2YVNjcmlwdCBudW1iZXJzOiAyMSlcclxuICAgKiAxMDAwMDAwIGlzIHRoZSBtYXhpbXVtIHJlY29tbWVuZGVkIGV4cG9uZW50IHZhbHVlIG9mIGEgQmlnLlxyXG4gICAqIChUaGlzIGxpbWl0IGlzIG5vdCBlbmZvcmNlZCBvciBjaGVja2VkLilcclxuICAgKi9cclxuICBQRSA9IDIxLCAgICAgICAgICAgIC8vIDAgdG8gMTAwMDAwMFxyXG5cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblxyXG4gIC8vIEVycm9yIG1lc3NhZ2VzLlxyXG4gIE5BTUUgPSAnW2JpZy5qc10gJyxcclxuICBJTlZBTElEID0gTkFNRSArICdJbnZhbGlkICcsXHJcbiAgSU5WQUxJRF9EUCA9IElOVkFMSUQgKyAnZGVjaW1hbCBwbGFjZXMnLFxyXG4gIElOVkFMSURfUk0gPSBJTlZBTElEICsgJ3JvdW5kaW5nIG1vZGUnLFxyXG4gIERJVl9CWV9aRVJPID0gTkFNRSArICdEaXZpc2lvbiBieSB6ZXJvJyxcclxuXHJcbiAgLy8gVGhlIHNoYXJlZCBwcm90b3R5cGUgb2JqZWN0LlxyXG4gIFAgPSB7fSxcclxuICBVTkRFRklORUQgPSB2b2lkIDAsXHJcbiAgTlVNRVJJQyA9IC9eLT8oXFxkKyhcXC5cXGQqKT98XFwuXFxkKykoZVsrLV0/XFxkKyk/JC9pO1xyXG5cclxuXHJcbi8qXHJcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgQmlnIGNvbnN0cnVjdG9yLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gX0JpZ18oKSB7XHJcblxyXG4gIC8qXHJcbiAgICogVGhlIEJpZyBjb25zdHJ1Y3RvciBhbmQgZXhwb3J0ZWQgZnVuY3Rpb24uXHJcbiAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBCaWcgbnVtYmVyIG9iamVjdC5cclxuICAgKlxyXG4gICAqIG4ge251bWJlcnxzdHJpbmd8QmlnfSBBIG51bWVyaWMgdmFsdWUuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gQmlnKG4pIHtcclxuICAgIHZhciB4ID0gdGhpcztcclxuXHJcbiAgICAvLyBFbmFibGUgY29uc3RydWN0b3IgdXNhZ2Ugd2l0aG91dCBuZXcuXHJcbiAgICBpZiAoISh4IGluc3RhbmNlb2YgQmlnKSkgcmV0dXJuIG4gPT09IFVOREVGSU5FRCA/IF9CaWdfKCkgOiBuZXcgQmlnKG4pO1xyXG5cclxuICAgIC8vIER1cGxpY2F0ZS5cclxuICAgIGlmIChuIGluc3RhbmNlb2YgQmlnKSB7XHJcbiAgICAgIHgucyA9IG4ucztcclxuICAgICAgeC5lID0gbi5lO1xyXG4gICAgICB4LmMgPSBuLmMuc2xpY2UoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBhcnNlKHgsIG4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXRhaW4gYSByZWZlcmVuY2UgdG8gdGhpcyBCaWcgY29uc3RydWN0b3IsIGFuZCBzaGFkb3cgQmlnLnByb3RvdHlwZS5jb25zdHJ1Y3RvciB3aGljaFxyXG4gICAgICogcG9pbnRzIHRvIE9iamVjdC5cclxuICAgICAqL1xyXG4gICAgeC5jb25zdHJ1Y3RvciA9IEJpZztcclxuICB9XHJcblxyXG4gIEJpZy5wcm90b3R5cGUgPSBQO1xyXG4gIEJpZy5EUCA9IERQO1xyXG4gIEJpZy5STSA9IFJNO1xyXG4gIEJpZy5ORSA9IE5FO1xyXG4gIEJpZy5QRSA9IFBFO1xyXG4gIEJpZy52ZXJzaW9uID0gJzUuMi4yJztcclxuXHJcbiAgcmV0dXJuIEJpZztcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFBhcnNlIHRoZSBudW1iZXIgb3Igc3RyaW5nIHZhbHVlIHBhc3NlZCB0byBhIEJpZyBjb25zdHJ1Y3Rvci5cclxuICpcclxuICogeCB7QmlnfSBBIEJpZyBudW1iZXIgaW5zdGFuY2UuXHJcbiAqIG4ge251bWJlcnxzdHJpbmd9IEEgbnVtZXJpYyB2YWx1ZS5cclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlKHgsIG4pIHtcclxuICB2YXIgZSwgaSwgbmw7XHJcblxyXG4gIC8vIE1pbnVzIHplcm8/XHJcbiAgaWYgKG4gPT09IDAgJiYgMSAvIG4gPCAwKSBuID0gJy0wJztcclxuICBlbHNlIGlmICghTlVNRVJJQy50ZXN0KG4gKz0gJycpKSB0aHJvdyBFcnJvcihJTlZBTElEICsgJ251bWJlcicpO1xyXG5cclxuICAvLyBEZXRlcm1pbmUgc2lnbi5cclxuICB4LnMgPSBuLmNoYXJBdCgwKSA9PSAnLScgPyAobiA9IG4uc2xpY2UoMSksIC0xKSA6IDE7XHJcblxyXG4gIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgaWYgKChlID0gbi5pbmRleE9mKCcuJykpID4gLTEpIG4gPSBuLnJlcGxhY2UoJy4nLCAnJyk7XHJcblxyXG4gIC8vIEV4cG9uZW50aWFsIGZvcm0/XHJcbiAgaWYgKChpID0gbi5zZWFyY2goL2UvaSkpID4gMCkge1xyXG5cclxuICAgIC8vIERldGVybWluZSBleHBvbmVudC5cclxuICAgIGlmIChlIDwgMCkgZSA9IGk7XHJcbiAgICBlICs9ICtuLnNsaWNlKGkgKyAxKTtcclxuICAgIG4gPSBuLnN1YnN0cmluZygwLCBpKTtcclxuICB9IGVsc2UgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgLy8gSW50ZWdlci5cclxuICAgIGUgPSBuLmxlbmd0aDtcclxuICB9XHJcblxyXG4gIG5sID0gbi5sZW5ndGg7XHJcblxyXG4gIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zLlxyXG4gIGZvciAoaSA9IDA7IGkgPCBubCAmJiBuLmNoYXJBdChpKSA9PSAnMCc7KSArK2k7XHJcblxyXG4gIGlmIChpID09IG5sKSB7XHJcblxyXG4gICAgLy8gWmVyby5cclxuICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICB9IGVsc2Uge1xyXG5cclxuICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoOyBubCA+IDAgJiYgbi5jaGFyQXQoLS1ubCkgPT0gJzAnOyk7XHJcbiAgICB4LmUgPSBlIC0gaSAtIDE7XHJcbiAgICB4LmMgPSBbXTtcclxuXHJcbiAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBhcnJheSBvZiBkaWdpdHMgd2l0aG91dCBsZWFkaW5nL3RyYWlsaW5nIHplcm9zLlxyXG4gICAgZm9yIChlID0gMDsgaSA8PSBubDspIHguY1tlKytdID0gK24uY2hhckF0KGkrKyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4geDtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJvdW5kIEJpZyB4IHRvIGEgbWF4aW11bSBvZiBkcCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLlxyXG4gKiBDYWxsZWQgYnkgc3RyaW5naWZ5LCBQLmRpdiwgUC5yb3VuZCBhbmQgUC5zcXJ0LlxyXG4gKlxyXG4gKiB4IHtCaWd9IFRoZSBCaWcgdG8gcm91bmQuXHJcbiAqIGRwIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYX0RQIGluY2x1c2l2ZS5cclxuICogcm0ge251bWJlcn0gMCwgMSwgMiBvciAzIChET1dOLCBIQUxGX1VQLCBIQUxGX0VWRU4sIFVQKVxyXG4gKiBbbW9yZV0ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbiB3YXMgdHJ1bmNhdGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gcm91bmQoeCwgZHAsIHJtLCBtb3JlKSB7XHJcbiAgdmFyIHhjID0geC5jLFxyXG4gICAgaSA9IHguZSArIGRwICsgMTtcclxuXHJcbiAgaWYgKGkgPCB4Yy5sZW5ndGgpIHtcclxuICAgIGlmIChybSA9PT0gMSkge1xyXG5cclxuICAgICAgLy8geGNbaV0gaXMgdGhlIGRpZ2l0IGFmdGVyIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICBtb3JlID0geGNbaV0gPj0gNTtcclxuICAgIH0gZWxzZSBpZiAocm0gPT09IDIpIHtcclxuICAgICAgbW9yZSA9IHhjW2ldID4gNSB8fCB4Y1tpXSA9PSA1ICYmXHJcbiAgICAgICAgKG1vcmUgfHwgaSA8IDAgfHwgeGNbaSArIDFdICE9PSBVTkRFRklORUQgfHwgeGNbaSAtIDFdICYgMSk7XHJcbiAgICB9IGVsc2UgaWYgKHJtID09PSAzKSB7XHJcbiAgICAgIG1vcmUgPSBtb3JlIHx8ICEheGNbMF07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBtb3JlID0gZmFsc2U7XHJcbiAgICAgIGlmIChybSAhPT0gMCkgdGhyb3cgRXJyb3IoSU5WQUxJRF9STSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGkgPCAxKSB7XHJcbiAgICAgIHhjLmxlbmd0aCA9IDE7XHJcblxyXG4gICAgICBpZiAobW9yZSkge1xyXG5cclxuICAgICAgICAvLyAxLCAwLjEsIDAuMDEsIDAuMDAxLCAwLjAwMDEgZXRjLlxyXG4gICAgICAgIHguZSA9IC1kcDtcclxuICAgICAgICB4Y1swXSA9IDE7XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgeGNbMF0gPSB4LmUgPSAwO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgLy8gUmVtb3ZlIGFueSBkaWdpdHMgYWZ0ZXIgdGhlIHJlcXVpcmVkIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICB4Yy5sZW5ndGggPSBpLS07XHJcblxyXG4gICAgICAvLyBSb3VuZCB1cD9cclxuICAgICAgaWYgKG1vcmUpIHtcclxuXHJcbiAgICAgICAgLy8gUm91bmRpbmcgdXAgbWF5IG1lYW4gdGhlIHByZXZpb3VzIGRpZ2l0IGhhcyB0byBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgIGZvciAoOyArK3hjW2ldID4gOTspIHtcclxuICAgICAgICAgIHhjW2ldID0gMDtcclxuICAgICAgICAgIGlmICghaS0tKSB7XHJcbiAgICAgICAgICAgICsreC5lO1xyXG4gICAgICAgICAgICB4Yy51bnNoaWZ0KDEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGkgPSB4Yy5sZW5ndGg7ICF4Y1stLWldOykgeGMucG9wKCk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChybSA8IDAgfHwgcm0gPiAzIHx8IHJtICE9PSB+fnJtKSB7XHJcbiAgICB0aHJvdyBFcnJvcihJTlZBTElEX1JNKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB4O1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgQmlnIHggaW4gbm9ybWFsIG9yIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gKiBIYW5kbGVzIFAudG9FeHBvbmVudGlhbCwgUC50b0ZpeGVkLCBQLnRvSlNPTiwgUC50b1ByZWNpc2lvbiwgUC50b1N0cmluZyBhbmQgUC52YWx1ZU9mLlxyXG4gKlxyXG4gKiB4IHtCaWd9XHJcbiAqIGlkPyB7bnVtYmVyfSBDYWxsZXIgaWQuXHJcbiAqICAgICAgICAgMSB0b0V4cG9uZW50aWFsXHJcbiAqICAgICAgICAgMiB0b0ZpeGVkXHJcbiAqICAgICAgICAgMyB0b1ByZWNpc2lvblxyXG4gKiAgICAgICAgIDQgdmFsdWVPZlxyXG4gKiBuPyB7bnVtYmVyfHVuZGVmaW5lZH0gQ2FsbGVyJ3MgYXJndW1lbnQuXHJcbiAqIGs/IHtudW1iZXJ8dW5kZWZpbmVkfVxyXG4gKi9cclxuZnVuY3Rpb24gc3RyaW5naWZ5KHgsIGlkLCBuLCBrKSB7XHJcbiAgdmFyIGUsIHMsXHJcbiAgICBCaWcgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgeiA9ICF4LmNbMF07XHJcblxyXG4gIGlmIChuICE9PSBVTkRFRklORUQpIHtcclxuICAgIGlmIChuICE9PSB+fm4gfHwgbiA8IChpZCA9PSAzKSB8fCBuID4gTUFYX0RQKSB7XHJcbiAgICAgIHRocm93IEVycm9yKGlkID09IDMgPyBJTlZBTElEICsgJ3ByZWNpc2lvbicgOiBJTlZBTElEX0RQKTtcclxuICAgIH1cclxuXHJcbiAgICB4ID0gbmV3IEJpZyh4KTtcclxuXHJcbiAgICAvLyBUaGUgaW5kZXggb2YgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICBuID0gayAtIHguZTtcclxuXHJcbiAgICAvLyBSb3VuZD9cclxuICAgIGlmICh4LmMubGVuZ3RoID4gKytrKSByb3VuZCh4LCBuLCBCaWcuUk0pO1xyXG5cclxuICAgIC8vIHRvRml4ZWQ6IHJlY2FsY3VsYXRlIGsgYXMgeC5lIG1heSBoYXZlIGNoYW5nZWQgaWYgdmFsdWUgcm91bmRlZCB1cC5cclxuICAgIGlmIChpZCA9PSAyKSBrID0geC5lICsgbiArIDE7XHJcblxyXG4gICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgZm9yICg7IHguYy5sZW5ndGggPCBrOykgeC5jLnB1c2goMCk7XHJcbiAgfVxyXG5cclxuICBlID0geC5lO1xyXG4gIHMgPSB4LmMuam9pbignJyk7XHJcbiAgbiA9IHMubGVuZ3RoO1xyXG5cclxuICAvLyBFeHBvbmVudGlhbCBub3RhdGlvbj9cclxuICBpZiAoaWQgIT0gMiAmJiAoaWQgPT0gMSB8fCBpZCA9PSAzICYmIGsgPD0gZSB8fCBlIDw9IEJpZy5ORSB8fCBlID49IEJpZy5QRSkpIHtcclxuICAgIHMgPSBzLmNoYXJBdCgwKSArIChuID4gMSA/ICcuJyArIHMuc2xpY2UoMSkgOiAnJykgKyAoZSA8IDAgPyAnZScgOiAnZSsnKSArIGU7XHJcblxyXG4gIC8vIE5vcm1hbCBub3RhdGlvbi5cclxuICB9IGVsc2UgaWYgKGUgPCAwKSB7XHJcbiAgICBmb3IgKDsgKytlOykgcyA9ICcwJyArIHM7XHJcbiAgICBzID0gJzAuJyArIHM7XHJcbiAgfSBlbHNlIGlmIChlID4gMCkge1xyXG4gICAgaWYgKCsrZSA+IG4pIGZvciAoZSAtPSBuOyBlLS07KSBzICs9ICcwJztcclxuICAgIGVsc2UgaWYgKGUgPCBuKSBzID0gcy5zbGljZSgwLCBlKSArICcuJyArIHMuc2xpY2UoZSk7XHJcbiAgfSBlbHNlIGlmIChuID4gMSkge1xyXG4gICAgcyA9IHMuY2hhckF0KDApICsgJy4nICsgcy5zbGljZSgxKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB4LnMgPCAwICYmICgheiB8fCBpZCA9PSA0KSA/ICctJyArIHMgOiBzO1xyXG59XHJcblxyXG5cclxuLy8gUHJvdG90eXBlL2luc3RhbmNlIG1ldGhvZHNcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgQmlnIHdob3NlIHZhbHVlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIEJpZy5cclxuICovXHJcblAuYWJzID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciB4ID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XHJcbiAgeC5zID0gMTtcclxuICByZXR1cm4geDtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWcgeSxcclxuICogICAgICAgLTEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnIHksIG9yXHJcbiAqICAgICAgICAwIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSB2YWx1ZS5cclxuKi9cclxuUC5jbXAgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHZhciBpc25lZyxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgeGMgPSB4LmMsXHJcbiAgICB5YyA9ICh5ID0gbmV3IHguY29uc3RydWN0b3IoeSkpLmMsXHJcbiAgICBpID0geC5zLFxyXG4gICAgaiA9IHkucyxcclxuICAgIGsgPSB4LmUsXHJcbiAgICBsID0geS5lO1xyXG5cclxuICAvLyBFaXRoZXIgemVybz9cclxuICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkgcmV0dXJuICF4Y1swXSA/ICF5Y1swXSA/IDAgOiAtaiA6IGk7XHJcblxyXG4gIC8vIFNpZ25zIGRpZmZlcj9cclxuICBpZiAoaSAhPSBqKSByZXR1cm4gaTtcclxuXHJcbiAgaXNuZWcgPSBpIDwgMDtcclxuXHJcbiAgLy8gQ29tcGFyZSBleHBvbmVudHMuXHJcbiAgaWYgKGsgIT0gbCkgcmV0dXJuIGsgPiBsIF4gaXNuZWcgPyAxIDogLTE7XHJcblxyXG4gIGogPSAoayA9IHhjLmxlbmd0aCkgPCAobCA9IHljLmxlbmd0aCkgPyBrIDogbDtcclxuXHJcbiAgLy8gQ29tcGFyZSBkaWdpdCBieSBkaWdpdC5cclxuICBmb3IgKGkgPSAtMTsgKytpIDwgajspIHtcclxuICAgIGlmICh4Y1tpXSAhPSB5Y1tpXSkgcmV0dXJuIHhjW2ldID4geWNbaV0gXiBpc25lZyA/IDEgOiAtMTtcclxuICB9XHJcblxyXG4gIC8vIENvbXBhcmUgbGVuZ3Rocy5cclxuICByZXR1cm4gayA9PSBsID8gMCA6IGsgPiBsIF4gaXNuZWcgPyAxIDogLTE7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IEJpZyB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgZGl2aWRlZCBieSB0aGUgdmFsdWUgb2YgQmlnIHksIHJvdW5kZWQsXHJcbiAqIGlmIG5lY2Vzc2FyeSwgdG8gYSBtYXhpbXVtIG9mIEJpZy5EUCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIEJpZy5STS5cclxuICovXHJcblAuZGl2ID0gZnVuY3Rpb24gKHkpIHtcclxuICB2YXIgeCA9IHRoaXMsXHJcbiAgICBCaWcgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgYSA9IHguYywgICAgICAgICAgICAgICAgICAvLyBkaXZpZGVuZFxyXG4gICAgYiA9ICh5ID0gbmV3IEJpZyh5KSkuYywgICAvLyBkaXZpc29yXHJcbiAgICBrID0geC5zID09IHkucyA/IDEgOiAtMSxcclxuICAgIGRwID0gQmlnLkRQO1xyXG5cclxuICBpZiAoZHAgIT09IH5+ZHAgfHwgZHAgPCAwIHx8IGRwID4gTUFYX0RQKSB0aHJvdyBFcnJvcihJTlZBTElEX0RQKTtcclxuXHJcbiAgLy8gRGl2aXNvciBpcyB6ZXJvP1xyXG4gIGlmICghYlswXSkgdGhyb3cgRXJyb3IoRElWX0JZX1pFUk8pO1xyXG5cclxuICAvLyBEaXZpZGVuZCBpcyAwPyBSZXR1cm4gKy0wLlxyXG4gIGlmICghYVswXSkgcmV0dXJuIG5ldyBCaWcoayAqIDApO1xyXG5cclxuICB2YXIgYmwsIGJ0LCBuLCBjbXAsIHJpLFxyXG4gICAgYnogPSBiLnNsaWNlKCksXHJcbiAgICBhaSA9IGJsID0gYi5sZW5ndGgsXHJcbiAgICBhbCA9IGEubGVuZ3RoLFxyXG4gICAgciA9IGEuc2xpY2UoMCwgYmwpLCAgIC8vIHJlbWFpbmRlclxyXG4gICAgcmwgPSByLmxlbmd0aCxcclxuICAgIHEgPSB5LCAgICAgICAgICAgICAgICAvLyBxdW90aWVudFxyXG4gICAgcWMgPSBxLmMgPSBbXSxcclxuICAgIHFpID0gMCxcclxuICAgIGQgPSBkcCArIChxLmUgPSB4LmUgLSB5LmUpICsgMTsgICAgLy8gbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgcmVzdWx0XHJcblxyXG4gIHEucyA9IGs7XHJcbiAgayA9IGQgPCAwID8gMCA6IGQ7XHJcblxyXG4gIC8vIENyZWF0ZSB2ZXJzaW9uIG9mIGRpdmlzb3Igd2l0aCBsZWFkaW5nIHplcm8uXHJcbiAgYnoudW5zaGlmdCgwKTtcclxuXHJcbiAgLy8gQWRkIHplcm9zIHRvIG1ha2UgcmVtYWluZGVyIGFzIGxvbmcgYXMgZGl2aXNvci5cclxuICBmb3IgKDsgcmwrKyA8IGJsOykgci5wdXNoKDApO1xyXG5cclxuICBkbyB7XHJcblxyXG4gICAgLy8gbiBpcyBob3cgbWFueSB0aW1lcyB0aGUgZGl2aXNvciBnb2VzIGludG8gY3VycmVudCByZW1haW5kZXIuXHJcbiAgICBmb3IgKG4gPSAwOyBuIDwgMTA7IG4rKykge1xyXG5cclxuICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCByZW1haW5kZXIuXHJcbiAgICAgIGlmIChibCAhPSAocmwgPSByLmxlbmd0aCkpIHtcclxuICAgICAgICBjbXAgPSBibCA+IHJsID8gMSA6IC0xO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAocmkgPSAtMSwgY21wID0gMDsgKytyaSA8IGJsOykge1xyXG4gICAgICAgICAgaWYgKGJbcmldICE9IHJbcmldKSB7XHJcbiAgICAgICAgICAgIGNtcCA9IGJbcmldID4gcltyaV0gPyAxIDogLTE7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSWYgZGl2aXNvciA8IHJlbWFpbmRlciwgc3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgaWYgKGNtcCA8IDApIHtcclxuXHJcbiAgICAgICAgLy8gUmVtYWluZGVyIGNhbid0IGJlIG1vcmUgdGhhbiAxIGRpZ2l0IGxvbmdlciB0aGFuIGRpdmlzb3IuXHJcbiAgICAgICAgLy8gRXF1YWxpc2UgbGVuZ3RocyB1c2luZyBkaXZpc29yIHdpdGggZXh0cmEgbGVhZGluZyB6ZXJvP1xyXG4gICAgICAgIGZvciAoYnQgPSBybCA9PSBibCA/IGIgOiBiejsgcmw7KSB7XHJcbiAgICAgICAgICBpZiAoclstLXJsXSA8IGJ0W3JsXSkge1xyXG4gICAgICAgICAgICByaSA9IHJsO1xyXG4gICAgICAgICAgICBmb3IgKDsgcmkgJiYgIXJbLS1yaV07KSByW3JpXSA9IDk7XHJcbiAgICAgICAgICAgIC0tcltyaV07XHJcbiAgICAgICAgICAgIHJbcmxdICs9IDEwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcltybF0gLT0gYnRbcmxdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICg7ICFyWzBdOykgci5zaGlmdCgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWRkIHRoZSBkaWdpdCBuIHRvIHRoZSByZXN1bHQgYXJyYXkuXHJcbiAgICBxY1txaSsrXSA9IGNtcCA/IG4gOiArK247XHJcblxyXG4gICAgLy8gVXBkYXRlIHRoZSByZW1haW5kZXIuXHJcbiAgICBpZiAoclswXSAmJiBjbXApIHJbcmxdID0gYVthaV0gfHwgMDtcclxuICAgIGVsc2UgciA9IFthW2FpXV07XHJcblxyXG4gIH0gd2hpbGUgKChhaSsrIDwgYWwgfHwgclswXSAhPT0gVU5ERUZJTkVEKSAmJiBrLS0pO1xyXG5cclxuICAvLyBMZWFkaW5nIHplcm8/IERvIG5vdCByZW1vdmUgaWYgcmVzdWx0IGlzIHNpbXBseSB6ZXJvIChxaSA9PSAxKS5cclxuICBpZiAoIXFjWzBdICYmIHFpICE9IDEpIHtcclxuXHJcbiAgICAvLyBUaGVyZSBjYW4ndCBiZSBtb3JlIHRoYW4gb25lIHplcm8uXHJcbiAgICBxYy5zaGlmdCgpO1xyXG4gICAgcS5lLS07XHJcbiAgfVxyXG5cclxuICAvLyBSb3VuZD9cclxuICBpZiAocWkgPiBkKSByb3VuZChxLCBkcCwgQmlnLlJNLCByWzBdICE9PSBVTkRFRklORUQpO1xyXG5cclxuICByZXR1cm4gcTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgaXMgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIEJpZyB5LCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gKi9cclxuUC5lcSA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgcmV0dXJuICF0aGlzLmNtcCh5KTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWcgeSwgb3RoZXJ3aXNlIHJldHVyblxyXG4gKiBmYWxzZS5cclxuICovXHJcblAuZ3QgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHJldHVybiB0aGlzLmNtcCh5KSA+IDA7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2YgQmlnIHksIG90aGVyd2lzZVxyXG4gKiByZXR1cm4gZmFsc2UuXHJcbiAqL1xyXG5QLmd0ZSA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgcmV0dXJuIHRoaXMuY21wKHkpID4gLTE7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnIHksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAqL1xyXG5QLmx0ID0gZnVuY3Rpb24gKHkpIHtcclxuICByZXR1cm4gdGhpcy5jbXAoeSkgPCAwO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIEJpZyB5LCBvdGhlcndpc2VcclxuICogcmV0dXJuIGZhbHNlLlxyXG4gKi9cclxuUC5sdGUgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHJldHVybiB0aGlzLmNtcCh5KSA8IDE7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IEJpZyB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgbWludXMgdGhlIHZhbHVlIG9mIEJpZyB5LlxyXG4gKi9cclxuUC5taW51cyA9IFAuc3ViID0gZnVuY3Rpb24gKHkpIHtcclxuICB2YXIgaSwgaiwgdCwgeGx0eSxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQmlnID0geC5jb25zdHJ1Y3RvcixcclxuICAgIGEgPSB4LnMsXHJcbiAgICBiID0gKHkgPSBuZXcgQmlnKHkpKS5zO1xyXG5cclxuICAvLyBTaWducyBkaWZmZXI/XHJcbiAgaWYgKGEgIT0gYikge1xyXG4gICAgeS5zID0gLWI7XHJcbiAgICByZXR1cm4geC5wbHVzKHkpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHhjID0geC5jLnNsaWNlKCksXHJcbiAgICB4ZSA9IHguZSxcclxuICAgIHljID0geS5jLFxyXG4gICAgeWUgPSB5LmU7XHJcblxyXG4gIC8vIEVpdGhlciB6ZXJvP1xyXG4gIGlmICgheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgLy8geSBpcyBub24temVybz8geCBpcyBub24temVybz8gT3IgYm90aCBhcmUgemVyby5cclxuICAgIHJldHVybiB5Y1swXSA/ICh5LnMgPSAtYiwgeSkgOiBuZXcgQmlnKHhjWzBdID8geCA6IDApO1xyXG4gIH1cclxuXHJcbiAgLy8gRGV0ZXJtaW5lIHdoaWNoIGlzIHRoZSBiaWdnZXIgbnVtYmVyLiBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy5cclxuICBpZiAoYSA9IHhlIC0geWUpIHtcclxuXHJcbiAgICBpZiAoeGx0eSA9IGEgPCAwKSB7XHJcbiAgICAgIGEgPSAtYTtcclxuICAgICAgdCA9IHhjO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgeWUgPSB4ZTtcclxuICAgICAgdCA9IHljO1xyXG4gICAgfVxyXG5cclxuICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgZm9yIChiID0gYTsgYi0tOykgdC5wdXNoKDApO1xyXG4gICAgdC5yZXZlcnNlKCk7XHJcbiAgfSBlbHNlIHtcclxuXHJcbiAgICAvLyBFeHBvbmVudHMgZXF1YWwuIENoZWNrIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgaiA9ICgoeGx0eSA9IHhjLmxlbmd0aCA8IHljLmxlbmd0aCkgPyB4YyA6IHljKS5sZW5ndGg7XHJcblxyXG4gICAgZm9yIChhID0gYiA9IDA7IGIgPCBqOyBiKyspIHtcclxuICAgICAgaWYgKHhjW2JdICE9IHljW2JdKSB7XHJcbiAgICAgICAgeGx0eSA9IHhjW2JdIDwgeWNbYl07XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIHggPCB5PyBQb2ludCB4YyB0byB0aGUgYXJyYXkgb2YgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgaWYgKHhsdHkpIHtcclxuICAgIHQgPSB4YztcclxuICAgIHhjID0geWM7XHJcbiAgICB5YyA9IHQ7XHJcbiAgICB5LnMgPSAteS5zO1xyXG4gIH1cclxuXHJcbiAgLypcclxuICAgKiBBcHBlbmQgemVyb3MgdG8geGMgaWYgc2hvcnRlci4gTm8gbmVlZCB0byBhZGQgemVyb3MgdG8geWMgaWYgc2hvcnRlciBhcyBzdWJ0cmFjdGlvbiBvbmx5XHJcbiAgICogbmVlZHMgdG8gc3RhcnQgYXQgeWMubGVuZ3RoLlxyXG4gICAqL1xyXG4gIGlmICgoYiA9IChqID0geWMubGVuZ3RoKSAtIChpID0geGMubGVuZ3RoKSkgPiAwKSBmb3IgKDsgYi0tOykgeGNbaSsrXSA9IDA7XHJcblxyXG4gIC8vIFN1YnRyYWN0IHljIGZyb20geGMuXHJcbiAgZm9yIChiID0gaTsgaiA+IGE7KSB7XHJcbiAgICBpZiAoeGNbLS1qXSA8IHljW2pdKSB7XHJcbiAgICAgIGZvciAoaSA9IGo7IGkgJiYgIXhjWy0taV07KSB4Y1tpXSA9IDk7XHJcbiAgICAgIC0teGNbaV07XHJcbiAgICAgIHhjW2pdICs9IDEwO1xyXG4gICAgfVxyXG5cclxuICAgIHhjW2pdIC09IHljW2pdO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gIGZvciAoOyB4Y1stLWJdID09PSAwOykgeGMucG9wKCk7XHJcblxyXG4gIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgZm9yICg7IHhjWzBdID09PSAwOykge1xyXG4gICAgeGMuc2hpZnQoKTtcclxuICAgIC0teWU7XHJcbiAgfVxyXG5cclxuICBpZiAoIXhjWzBdKSB7XHJcblxyXG4gICAgLy8gbiAtIG4gPSArMFxyXG4gICAgeS5zID0gMTtcclxuXHJcbiAgICAvLyBSZXN1bHQgbXVzdCBiZSB6ZXJvLlxyXG4gICAgeGMgPSBbeWUgPSAwXTtcclxuICB9XHJcblxyXG4gIHkuYyA9IHhjO1xyXG4gIHkuZSA9IHllO1xyXG5cclxuICByZXR1cm4geTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgQmlnIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBtb2R1bG8gdGhlIHZhbHVlIG9mIEJpZyB5LlxyXG4gKi9cclxuUC5tb2QgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHZhciB5Z3R4LFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBCaWcgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgYSA9IHgucyxcclxuICAgIGIgPSAoeSA9IG5ldyBCaWcoeSkpLnM7XHJcblxyXG4gIGlmICgheS5jWzBdKSB0aHJvdyBFcnJvcihESVZfQllfWkVSTyk7XHJcblxyXG4gIHgucyA9IHkucyA9IDE7XHJcbiAgeWd0eCA9IHkuY21wKHgpID09IDE7XHJcbiAgeC5zID0gYTtcclxuICB5LnMgPSBiO1xyXG5cclxuICBpZiAoeWd0eCkgcmV0dXJuIG5ldyBCaWcoeCk7XHJcblxyXG4gIGEgPSBCaWcuRFA7XHJcbiAgYiA9IEJpZy5STTtcclxuICBCaWcuRFAgPSBCaWcuUk0gPSAwO1xyXG4gIHggPSB4LmRpdih5KTtcclxuICBCaWcuRFAgPSBhO1xyXG4gIEJpZy5STSA9IGI7XHJcblxyXG4gIHJldHVybiB0aGlzLm1pbnVzKHgudGltZXMoeSkpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBCaWcgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIHBsdXMgdGhlIHZhbHVlIG9mIEJpZyB5LlxyXG4gKi9cclxuUC5wbHVzID0gUC5hZGQgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHZhciB0LFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBCaWcgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgYSA9IHgucyxcclxuICAgIGIgPSAoeSA9IG5ldyBCaWcoeSkpLnM7XHJcblxyXG4gIC8vIFNpZ25zIGRpZmZlcj9cclxuICBpZiAoYSAhPSBiKSB7XHJcbiAgICB5LnMgPSAtYjtcclxuICAgIHJldHVybiB4Lm1pbnVzKHkpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHhlID0geC5lLFxyXG4gICAgeGMgPSB4LmMsXHJcbiAgICB5ZSA9IHkuZSxcclxuICAgIHljID0geS5jO1xyXG5cclxuICAvLyBFaXRoZXIgemVybz8geSBpcyBub24temVybz8geCBpcyBub24temVybz8gT3IgYm90aCBhcmUgemVyby5cclxuICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkgcmV0dXJuIHljWzBdID8geSA6IG5ldyBCaWcoeGNbMF0gPyB4IDogYSAqIDApO1xyXG5cclxuICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLlxyXG4gIC8vIE5vdGU6IHJldmVyc2UgZmFzdGVyIHRoYW4gdW5zaGlmdHMuXHJcbiAgaWYgKGEgPSB4ZSAtIHllKSB7XHJcbiAgICBpZiAoYSA+IDApIHtcclxuICAgICAgeWUgPSB4ZTtcclxuICAgICAgdCA9IHljO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYSA9IC1hO1xyXG4gICAgICB0ID0geGM7XHJcbiAgICB9XHJcblxyXG4gICAgdC5yZXZlcnNlKCk7XHJcbiAgICBmb3IgKDsgYS0tOykgdC5wdXNoKDApO1xyXG4gICAgdC5yZXZlcnNlKCk7XHJcbiAgfVxyXG5cclxuICAvLyBQb2ludCB4YyB0byB0aGUgbG9uZ2VyIGFycmF5LlxyXG4gIGlmICh4Yy5sZW5ndGggLSB5Yy5sZW5ndGggPCAwKSB7XHJcbiAgICB0ID0geWM7XHJcbiAgICB5YyA9IHhjO1xyXG4gICAgeGMgPSB0O1xyXG4gIH1cclxuXHJcbiAgYSA9IHljLmxlbmd0aDtcclxuXHJcbiAgLy8gT25seSBzdGFydCBhZGRpbmcgYXQgeWMubGVuZ3RoIC0gMSBhcyB0aGUgZnVydGhlciBkaWdpdHMgb2YgeGMgY2FuIGJlIGxlZnQgYXMgdGhleSBhcmUuXHJcbiAgZm9yIChiID0gMDsgYTsgeGNbYV0gJT0gMTApIGIgPSAoeGNbLS1hXSA9IHhjW2FdICsgeWNbYV0gKyBiKSAvIDEwIHwgMDtcclxuXHJcbiAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgemVybywgYXMgK3ggKyAreSAhPSAwICYmIC14ICsgLXkgIT0gMFxyXG5cclxuICBpZiAoYikge1xyXG4gICAgeGMudW5zaGlmdChiKTtcclxuICAgICsreWU7XHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgZm9yIChhID0geGMubGVuZ3RoOyB4Y1stLWFdID09PSAwOykgeGMucG9wKCk7XHJcblxyXG4gIHkuYyA9IHhjO1xyXG4gIHkuZSA9IHllO1xyXG5cclxuICByZXR1cm4geTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBCaWcgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIHJhaXNlZCB0byB0aGUgcG93ZXIgbi5cclxuICogSWYgbiBpcyBuZWdhdGl2ZSwgcm91bmQgdG8gYSBtYXhpbXVtIG9mIEJpZy5EUCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZ1xyXG4gKiBtb2RlIEJpZy5STS5cclxuICpcclxuICogbiB7bnVtYmVyfSBJbnRlZ2VyLCAtTUFYX1BPV0VSIHRvIE1BWF9QT1dFUiBpbmNsdXNpdmUuXHJcbiAqL1xyXG5QLnBvdyA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgdmFyIHggPSB0aGlzLFxyXG4gICAgb25lID0gbmV3IHguY29uc3RydWN0b3IoMSksXHJcbiAgICB5ID0gb25lLFxyXG4gICAgaXNuZWcgPSBuIDwgMDtcclxuXHJcbiAgaWYgKG4gIT09IH5+biB8fCBuIDwgLU1BWF9QT1dFUiB8fCBuID4gTUFYX1BPV0VSKSB0aHJvdyBFcnJvcihJTlZBTElEICsgJ2V4cG9uZW50Jyk7XHJcbiAgaWYgKGlzbmVnKSBuID0gLW47XHJcblxyXG4gIGZvciAoOzspIHtcclxuICAgIGlmIChuICYgMSkgeSA9IHkudGltZXMoeCk7XHJcbiAgICBuID4+PSAxO1xyXG4gICAgaWYgKCFuKSBicmVhaztcclxuICAgIHggPSB4LnRpbWVzKHgpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGlzbmVnID8gb25lLmRpdih5KSA6IHk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IEJpZyB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgcm91bmRlZCB1c2luZyByb3VuZGluZyBtb2RlIHJtXHJcbiAqIHRvIGEgbWF4aW11bSBvZiBkcCBkZWNpbWFsIHBsYWNlcywgb3IsIGlmIGRwIGlzIG5lZ2F0aXZlLCB0byBhbiBpbnRlZ2VyIHdoaWNoIGlzIGFcclxuICogbXVsdGlwbGUgb2YgMTAqKi1kcC5cclxuICogSWYgZHAgaXMgbm90IHNwZWNpZmllZCwgcm91bmQgdG8gMCBkZWNpbWFsIHBsYWNlcy5cclxuICogSWYgcm0gaXMgbm90IHNwZWNpZmllZCwgdXNlIEJpZy5STS5cclxuICpcclxuICogZHA/IHtudW1iZXJ9IEludGVnZXIsIC1NQVhfRFAgdG8gTUFYX0RQIGluY2x1c2l2ZS5cclxuICogcm0/IDAsIDEsIDIgb3IgMyAoUk9VTkRfRE9XTiwgUk9VTkRfSEFMRl9VUCwgUk9VTkRfSEFMRl9FVkVOLCBST1VORF9VUClcclxuICovXHJcblAucm91bmQgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgdmFyIEJpZyA9IHRoaXMuY29uc3RydWN0b3I7XHJcbiAgaWYgKGRwID09PSBVTkRFRklORUQpIGRwID0gMDtcclxuICBlbHNlIGlmIChkcCAhPT0gfn5kcCB8fCBkcCA8IC1NQVhfRFAgfHwgZHAgPiBNQVhfRFApIHRocm93IEVycm9yKElOVkFMSURfRFApO1xyXG4gIHJldHVybiByb3VuZChuZXcgQmlnKHRoaXMpLCBkcCwgcm0gPT09IFVOREVGSU5FRCA/IEJpZy5STSA6IHJtKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgQmlnIHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWcsIHJvdW5kZWQsIGlmXHJcbiAqIG5lY2Vzc2FyeSwgdG8gYSBtYXhpbXVtIG9mIEJpZy5EUCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIEJpZy5STS5cclxuICovXHJcblAuc3FydCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgciwgYywgdCxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQmlnID0geC5jb25zdHJ1Y3RvcixcclxuICAgIHMgPSB4LnMsXHJcbiAgICBlID0geC5lLFxyXG4gICAgaGFsZiA9IG5ldyBCaWcoMC41KTtcclxuXHJcbiAgLy8gWmVybz9cclxuICBpZiAoIXguY1swXSkgcmV0dXJuIG5ldyBCaWcoeCk7XHJcblxyXG4gIC8vIE5lZ2F0aXZlP1xyXG4gIGlmIChzIDwgMCkgdGhyb3cgRXJyb3IoTkFNRSArICdObyBzcXVhcmUgcm9vdCcpO1xyXG5cclxuICAvLyBFc3RpbWF0ZS5cclxuICBzID0gTWF0aC5zcXJ0KHggKyAnJyk7XHJcblxyXG4gIC8vIE1hdGguc3FydCB1bmRlcmZsb3cvb3ZlcmZsb3c/XHJcbiAgLy8gUmUtZXN0aW1hdGU6IHBhc3MgeCBjb2VmZmljaWVudCB0byBNYXRoLnNxcnQgYXMgaW50ZWdlciwgdGhlbiBhZGp1c3QgdGhlIHJlc3VsdCBleHBvbmVudC5cclxuICBpZiAocyA9PT0gMCB8fCBzID09PSAxIC8gMCkge1xyXG4gICAgYyA9IHguYy5qb2luKCcnKTtcclxuICAgIGlmICghKGMubGVuZ3RoICsgZSAmIDEpKSBjICs9ICcwJztcclxuICAgIHMgPSBNYXRoLnNxcnQoYyk7XHJcbiAgICBlID0gKChlICsgMSkgLyAyIHwgMCkgLSAoZSA8IDAgfHwgZSAmIDEpO1xyXG4gICAgciA9IG5ldyBCaWcoKHMgPT0gMSAvIDAgPyAnMWUnIDogKHMgPSBzLnRvRXhwb25lbnRpYWwoKSkuc2xpY2UoMCwgcy5pbmRleE9mKCdlJykgKyAxKSkgKyBlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgciA9IG5ldyBCaWcocyk7XHJcbiAgfVxyXG5cclxuICBlID0gci5lICsgKEJpZy5EUCArPSA0KTtcclxuXHJcbiAgLy8gTmV3dG9uLVJhcGhzb24gaXRlcmF0aW9uLlxyXG4gIGRvIHtcclxuICAgIHQgPSByO1xyXG4gICAgciA9IGhhbGYudGltZXModC5wbHVzKHguZGl2KHQpKSk7XHJcbiAgfSB3aGlsZSAodC5jLnNsaWNlKDAsIGUpLmpvaW4oJycpICE9PSByLmMuc2xpY2UoMCwgZSkuam9pbignJykpO1xyXG5cclxuICByZXR1cm4gcm91bmQociwgQmlnLkRQIC09IDQsIEJpZy5STSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IEJpZyB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgdGltZXMgdGhlIHZhbHVlIG9mIEJpZyB5LlxyXG4gKi9cclxuUC50aW1lcyA9IFAubXVsID0gZnVuY3Rpb24gKHkpIHtcclxuICB2YXIgYyxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQmlnID0geC5jb25zdHJ1Y3RvcixcclxuICAgIHhjID0geC5jLFxyXG4gICAgeWMgPSAoeSA9IG5ldyBCaWcoeSkpLmMsXHJcbiAgICBhID0geGMubGVuZ3RoLFxyXG4gICAgYiA9IHljLmxlbmd0aCxcclxuICAgIGkgPSB4LmUsXHJcbiAgICBqID0geS5lO1xyXG5cclxuICAvLyBEZXRlcm1pbmUgc2lnbiBvZiByZXN1bHQuXHJcbiAgeS5zID0geC5zID09IHkucyA/IDEgOiAtMTtcclxuXHJcbiAgLy8gUmV0dXJuIHNpZ25lZCAwIGlmIGVpdGhlciAwLlxyXG4gIGlmICgheGNbMF0gfHwgIXljWzBdKSByZXR1cm4gbmV3IEJpZyh5LnMgKiAwKTtcclxuXHJcbiAgLy8gSW5pdGlhbGlzZSBleHBvbmVudCBvZiByZXN1bHQgYXMgeC5lICsgeS5lLlxyXG4gIHkuZSA9IGkgKyBqO1xyXG5cclxuICAvLyBJZiBhcnJheSB4YyBoYXMgZmV3ZXIgZGlnaXRzIHRoYW4geWMsIHN3YXAgeGMgYW5kIHljLCBhbmQgbGVuZ3Rocy5cclxuICBpZiAoYSA8IGIpIHtcclxuICAgIGMgPSB4YztcclxuICAgIHhjID0geWM7XHJcbiAgICB5YyA9IGM7XHJcbiAgICBqID0gYTtcclxuICAgIGEgPSBiO1xyXG4gICAgYiA9IGo7XHJcbiAgfVxyXG5cclxuICAvLyBJbml0aWFsaXNlIGNvZWZmaWNpZW50IGFycmF5IG9mIHJlc3VsdCB3aXRoIHplcm9zLlxyXG4gIGZvciAoYyA9IG5ldyBBcnJheShqID0gYSArIGIpOyBqLS07KSBjW2pdID0gMDtcclxuXHJcbiAgLy8gTXVsdGlwbHkuXHJcblxyXG4gIC8vIGkgaXMgaW5pdGlhbGx5IHhjLmxlbmd0aC5cclxuICBmb3IgKGkgPSBiOyBpLS07KSB7XHJcbiAgICBiID0gMDtcclxuXHJcbiAgICAvLyBhIGlzIHljLmxlbmd0aC5cclxuICAgIGZvciAoaiA9IGEgKyBpOyBqID4gaTspIHtcclxuXHJcbiAgICAgIC8vIEN1cnJlbnQgc3VtIG9mIHByb2R1Y3RzIGF0IHRoaXMgZGlnaXQgcG9zaXRpb24sIHBsdXMgY2FycnkuXHJcbiAgICAgIGIgPSBjW2pdICsgeWNbaV0gKiB4Y1tqIC0gaSAtIDFdICsgYjtcclxuICAgICAgY1tqLS1dID0gYiAlIDEwO1xyXG5cclxuICAgICAgLy8gY2FycnlcclxuICAgICAgYiA9IGIgLyAxMCB8IDA7XHJcbiAgICB9XHJcblxyXG4gICAgY1tqXSA9IChjW2pdICsgYikgJSAxMDtcclxuICB9XHJcblxyXG4gIC8vIEluY3JlbWVudCByZXN1bHQgZXhwb25lbnQgaWYgdGhlcmUgaXMgYSBmaW5hbCBjYXJyeSwgb3RoZXJ3aXNlIHJlbW92ZSBsZWFkaW5nIHplcm8uXHJcbiAgaWYgKGIpICsreS5lO1xyXG4gIGVsc2UgYy5zaGlmdCgpO1xyXG5cclxuICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgZm9yIChpID0gYy5sZW5ndGg7ICFjWy0taV07KSBjLnBvcCgpO1xyXG4gIHkuYyA9IGM7XHJcblxyXG4gIHJldHVybiB5O1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIGluIGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGRwIGZpeGVkIGRlY2ltYWxcclxuICogcGxhY2VzIGFuZCByb3VuZGVkIHVzaW5nIEJpZy5STS5cclxuICpcclxuICogZHA/IHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYX0RQIGluY2x1c2l2ZS5cclxuICovXHJcblAudG9FeHBvbmVudGlhbCA9IGZ1bmN0aW9uIChkcCkge1xyXG4gIHJldHVybiBzdHJpbmdpZnkodGhpcywgMSwgZHAsIGRwKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBpbiBub3JtYWwgbm90YXRpb24gdG8gZHAgZml4ZWQgZGVjaW1hbFxyXG4gKiBwbGFjZXMgYW5kIHJvdW5kZWQgdXNpbmcgQmlnLlJNLlxyXG4gKlxyXG4gKiBkcD8ge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVhfRFAgaW5jbHVzaXZlLlxyXG4gKlxyXG4gKiAoLTApLnRvRml4ZWQoMCkgaXMgJzAnLCBidXQgKC0wLjEpLnRvRml4ZWQoMCkgaXMgJy0wJy5cclxuICogKC0wKS50b0ZpeGVkKDEpIGlzICcwLjAnLCBidXQgKC0wLjAxKS50b0ZpeGVkKDEpIGlzICctMC4wJy5cclxuICovXHJcblAudG9GaXhlZCA9IGZ1bmN0aW9uIChkcCkge1xyXG4gIHJldHVybiBzdHJpbmdpZnkodGhpcywgMiwgZHAsIHRoaXMuZSArIGRwKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyByb3VuZGVkIHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZ1xyXG4gKiBCaWcuUk0uIFVzZSBleHBvbmVudGlhbCBub3RhdGlvbiBpZiBzZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHMgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudFxyXG4gKiB0aGUgaW50ZWdlciBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBub3JtYWwgbm90YXRpb24uXHJcbiAqXHJcbiAqIHNkIHtudW1iZXJ9IEludGVnZXIsIDEgdG8gTUFYX0RQIGluY2x1c2l2ZS5cclxuICovXHJcblAudG9QcmVjaXNpb24gPSBmdW5jdGlvbiAoc2QpIHtcclxuICByZXR1cm4gc3RyaW5naWZ5KHRoaXMsIDMsIHNkLCBzZCAtIDEpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnLlxyXG4gKiBSZXR1cm4gZXhwb25lbnRpYWwgbm90YXRpb24gaWYgdGhpcyBCaWcgaGFzIGEgcG9zaXRpdmUgZXhwb25lbnQgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuXHJcbiAqIEJpZy5QRSwgb3IgYSBuZWdhdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBsZXNzIHRoYW4gQmlnLk5FLlxyXG4gKiBPbWl0IHRoZSBzaWduIGZvciBuZWdhdGl2ZSB6ZXJvLlxyXG4gKi9cclxuUC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gc3RyaW5naWZ5KHRoaXMpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnLlxyXG4gKiBSZXR1cm4gZXhwb25lbnRpYWwgbm90YXRpb24gaWYgdGhpcyBCaWcgaGFzIGEgcG9zaXRpdmUgZXhwb25lbnQgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuXHJcbiAqIEJpZy5QRSwgb3IgYSBuZWdhdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBsZXNzIHRoYW4gQmlnLk5FLlxyXG4gKiBJbmNsdWRlIHRoZSBzaWduIGZvciBuZWdhdGl2ZSB6ZXJvLlxyXG4gKi9cclxuUC52YWx1ZU9mID0gUC50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHN0cmluZ2lmeSh0aGlzLCA0KTtcclxufTtcclxuXHJcblxyXG4vLyBFeHBvcnRcclxuXHJcblxyXG5leHBvcnQgdmFyIEJpZyA9IF9CaWdfKCk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCaWc7XHJcbiJdLCJuYW1lcyI6WyJEUCIsIlJNIiwiTUFYX0RQIiwiTUFYX1BPV0VSIiwiTkUiLCJQRSIsIk5BTUUiLCJJTlZBTElEIiwiSU5WQUxJRF9EUCIsIklOVkFMSURfUk0iLCJESVZfQllfWkVSTyIsIlAiLCJVTkRFRklORUQiLCJOVU1FUklDIiwiX0JpZ18iLCJCaWciLCJuIiwieCIsInMiLCJlIiwiYyIsInNsaWNlIiwicGFyc2UiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsInZlcnNpb24iLCJpIiwibmwiLCJ0ZXN0IiwiRXJyb3IiLCJjaGFyQXQiLCJpbmRleE9mIiwicmVwbGFjZSIsInNlYXJjaCIsInN1YnN0cmluZyIsImxlbmd0aCIsInJvdW5kIiwiZHAiLCJybSIsIm1vcmUiLCJ4YyIsInVuc2hpZnQiLCJwb3AiLCJzdHJpbmdpZnkiLCJpZCIsImsiLCJ6IiwicHVzaCIsImpvaW4iLCJhYnMiLCJjbXAiLCJ5IiwiaXNuZWciLCJ5YyIsImoiLCJsIiwiZGl2IiwiYSIsImIiLCJibCIsImJ0IiwicmkiLCJieiIsImFpIiwiYWwiLCJyIiwicmwiLCJxIiwicWMiLCJxaSIsImQiLCJzaGlmdCIsImVxIiwiZ3QiLCJndGUiLCJsdCIsImx0ZSIsIm1pbnVzIiwic3ViIiwidCIsInhsdHkiLCJwbHVzIiwieGUiLCJ5ZSIsInJldmVyc2UiLCJtb2QiLCJ5Z3R4IiwidGltZXMiLCJhZGQiLCJwb3ciLCJvbmUiLCJzcXJ0IiwiaGFsZiIsIk1hdGgiLCJ0b0V4cG9uZW50aWFsIiwibXVsIiwiQXJyYXkiLCJ0b0ZpeGVkIiwidG9QcmVjaXNpb24iLCJzZCIsInRvU3RyaW5nIiwidmFsdWVPZiIsInRvSlNPTiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/big.js@5.2.2/node_modules/big.js/big.mjs\n");

/***/ })

};
;
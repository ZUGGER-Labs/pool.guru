"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/i18next@23.7.16";
exports.ids = ["vendor-chunks/i18next@23.7.16"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/i18next@23.7.16/node_modules/i18next/dist/esm/i18next.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/i18next@23.7.16/node_modules/i18next/dist/esm/i18next.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   changeLanguage: () => (/* binding */ changeLanguage),\n/* harmony export */   createInstance: () => (/* binding */ createInstance),\n/* harmony export */   \"default\": () => (/* binding */ instance),\n/* harmony export */   dir: () => (/* binding */ dir),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   getFixedT: () => (/* binding */ getFixedT),\n/* harmony export */   hasLoadedNamespace: () => (/* binding */ hasLoadedNamespace),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   loadLanguages: () => (/* binding */ loadLanguages),\n/* harmony export */   loadNamespaces: () => (/* binding */ loadNamespaces),\n/* harmony export */   loadResources: () => (/* binding */ loadResources),\n/* harmony export */   reloadResources: () => (/* binding */ reloadResources),\n/* harmony export */   setDefaultNamespace: () => (/* binding */ setDefaultNamespace),\n/* harmony export */   t: () => (/* binding */ t),\n/* harmony export */   use: () => (/* binding */ use)\n/* harmony export */ });\nconst consoleLogger = {\n    type: \"logger\",\n    log (args) {\n        this.output(\"log\", args);\n    },\n    warn (args) {\n        this.output(\"warn\", args);\n    },\n    error (args) {\n        this.output(\"error\", args);\n    },\n    output (type, args) {\n        if (console && console[type]) console[type].apply(console, args);\n    }\n};\nclass Logger {\n    constructor(concreteLogger){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.init(concreteLogger, options);\n    }\n    init(concreteLogger) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.prefix = options.prefix || \"i18next:\";\n        this.logger = concreteLogger || consoleLogger;\n        this.options = options;\n        this.debug = options.debug;\n    }\n    log() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return this.forward(args, \"log\", \"\", true);\n    }\n    warn() {\n        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            args[_key2] = arguments[_key2];\n        }\n        return this.forward(args, \"warn\", \"\", true);\n    }\n    error() {\n        for(var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){\n            args[_key3] = arguments[_key3];\n        }\n        return this.forward(args, \"error\", \"\");\n    }\n    deprecate() {\n        for(var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++){\n            args[_key4] = arguments[_key4];\n        }\n        return this.forward(args, \"warn\", \"WARNING DEPRECATED: \", true);\n    }\n    forward(args, lvl, prefix, debugOnly) {\n        if (debugOnly && !this.debug) return null;\n        if (typeof args[0] === \"string\") args[0] = `${prefix}${this.prefix} ${args[0]}`;\n        return this.logger[lvl](args);\n    }\n    create(moduleName) {\n        return new Logger(this.logger, {\n            ...{\n                prefix: `${this.prefix}:${moduleName}:`\n            },\n            ...this.options\n        });\n    }\n    clone(options) {\n        options = options || this.options;\n        options.prefix = options.prefix || this.prefix;\n        return new Logger(this.logger, options);\n    }\n}\nvar baseLogger = new Logger();\nclass EventEmitter {\n    constructor(){\n        this.observers = {};\n    }\n    on(events, listener) {\n        events.split(\" \").forEach((event)=>{\n            this.observers[event] = this.observers[event] || [];\n            this.observers[event].push(listener);\n        });\n        return this;\n    }\n    off(event, listener) {\n        if (!this.observers[event]) return;\n        if (!listener) {\n            delete this.observers[event];\n            return;\n        }\n        this.observers[event] = this.observers[event].filter((l)=>l !== listener);\n    }\n    emit(event) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        if (this.observers[event]) {\n            const cloned = [].concat(this.observers[event]);\n            cloned.forEach((observer)=>{\n                observer(...args);\n            });\n        }\n        if (this.observers[\"*\"]) {\n            const cloned = [].concat(this.observers[\"*\"]);\n            cloned.forEach((observer)=>{\n                observer.apply(observer, [\n                    event,\n                    ...args\n                ]);\n            });\n        }\n    }\n}\nfunction defer() {\n    let res;\n    let rej;\n    const promise = new Promise((resolve, reject)=>{\n        res = resolve;\n        rej = reject;\n    });\n    promise.resolve = res;\n    promise.reject = rej;\n    return promise;\n}\nfunction makeString(object) {\n    if (object == null) return \"\";\n    return \"\" + object;\n}\nfunction copy(a, s, t) {\n    a.forEach((m)=>{\n        if (s[m]) t[m] = s[m];\n    });\n}\nfunction getLastOfPath(object, path, Empty) {\n    function cleanKey(key) {\n        return key && key.indexOf(\"###\") > -1 ? key.replace(/###/g, \".\") : key;\n    }\n    function canNotTraverseDeeper() {\n        return !object || typeof object === \"string\";\n    }\n    const stack = typeof path !== \"string\" ? [].concat(path) : path.split(\".\");\n    while(stack.length > 1){\n        if (canNotTraverseDeeper()) return {};\n        const key = cleanKey(stack.shift());\n        if (!object[key] && Empty) object[key] = new Empty();\n        if (Object.prototype.hasOwnProperty.call(object, key)) {\n            object = object[key];\n        } else {\n            object = {};\n        }\n    }\n    if (canNotTraverseDeeper()) return {};\n    return {\n        obj: object,\n        k: cleanKey(stack.shift())\n    };\n}\nfunction setPath(object, path, newValue) {\n    const { obj, k } = getLastOfPath(object, path, Object);\n    obj[k] = newValue;\n}\nfunction pushPath(object, path, newValue, concat) {\n    const { obj, k } = getLastOfPath(object, path, Object);\n    obj[k] = obj[k] || [];\n    if (concat) obj[k] = obj[k].concat(newValue);\n    if (!concat) obj[k].push(newValue);\n}\nfunction getPath(object, path) {\n    const { obj, k } = getLastOfPath(object, path);\n    if (!obj) return undefined;\n    return obj[k];\n}\nfunction getPathWithDefaults(data, defaultData, key) {\n    const value = getPath(data, key);\n    if (value !== undefined) {\n        return value;\n    }\n    return getPath(defaultData, key);\n}\nfunction deepExtend(target, source, overwrite) {\n    for(const prop in source){\n        if (prop !== \"__proto__\" && prop !== \"constructor\") {\n            if (prop in target) {\n                if (typeof target[prop] === \"string\" || target[prop] instanceof String || typeof source[prop] === \"string\" || source[prop] instanceof String) {\n                    if (overwrite) target[prop] = source[prop];\n                } else {\n                    deepExtend(target[prop], source[prop], overwrite);\n                }\n            } else {\n                target[prop] = source[prop];\n            }\n        }\n    }\n    return target;\n}\nfunction regexEscape(str) {\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n}\nvar _entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\",\n    \"/\": \"&#x2F;\"\n};\nfunction escape(data) {\n    if (typeof data === \"string\") {\n        return data.replace(/[&<>\"'\\/]/g, (s)=>_entityMap[s]);\n    }\n    return data;\n}\nconst chars = [\n    \" \",\n    \",\",\n    \"?\",\n    \"!\",\n    \";\"\n];\nfunction looksLikeObjectPath(key, nsSeparator, keySeparator) {\n    nsSeparator = nsSeparator || \"\";\n    keySeparator = keySeparator || \"\";\n    const possibleChars = chars.filter((c)=>nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);\n    if (possibleChars.length === 0) return true;\n    const r = new RegExp(`(${possibleChars.map((c)=>c === \"?\" ? \"\\\\?\" : c).join(\"|\")})`);\n    let matched = !r.test(key);\n    if (!matched) {\n        const ki = key.indexOf(keySeparator);\n        if (ki > 0 && !r.test(key.substring(0, ki))) {\n            matched = true;\n        }\n    }\n    return matched;\n}\nfunction deepFind(obj, path) {\n    let keySeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \".\";\n    if (!obj) return undefined;\n    if (obj[path]) return obj[path];\n    const paths = path.split(keySeparator);\n    let current = obj;\n    for(let i = 0; i < paths.length; ++i){\n        if (!current) return undefined;\n        if (typeof current[paths[i]] === \"string\" && i + 1 < paths.length) {\n            return undefined;\n        }\n        if (current[paths[i]] === undefined) {\n            let j = 2;\n            let p = paths.slice(i, i + j).join(keySeparator);\n            let mix = current[p];\n            while(mix === undefined && paths.length > i + j){\n                j++;\n                p = paths.slice(i, i + j).join(keySeparator);\n                mix = current[p];\n            }\n            if (mix === undefined) return undefined;\n            if (mix === null) return null;\n            if (path.endsWith(p)) {\n                if (typeof mix === \"string\") return mix;\n                if (p && typeof mix[p] === \"string\") return mix[p];\n            }\n            const joinedPath = paths.slice(i + j).join(keySeparator);\n            if (joinedPath) return deepFind(mix, joinedPath, keySeparator);\n            return undefined;\n        }\n        current = current[paths[i]];\n    }\n    return current;\n}\nfunction getCleanedCode(code) {\n    if (code && code.indexOf(\"_\") > 0) return code.replace(\"_\", \"-\");\n    return code;\n}\nclass ResourceStore extends EventEmitter {\n    constructor(data){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            ns: [\n                \"translation\"\n            ],\n            defaultNS: \"translation\"\n        };\n        super();\n        this.data = data || {};\n        this.options = options;\n        if (this.options.keySeparator === undefined) {\n            this.options.keySeparator = \".\";\n        }\n        if (this.options.ignoreJSONStructure === undefined) {\n            this.options.ignoreJSONStructure = true;\n        }\n    }\n    addNamespaces(ns) {\n        if (this.options.ns.indexOf(ns) < 0) {\n            this.options.ns.push(ns);\n        }\n    }\n    removeNamespaces(ns) {\n        const index = this.options.ns.indexOf(ns);\n        if (index > -1) {\n            this.options.ns.splice(index, 1);\n        }\n    }\n    getResource(lng, ns, key) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        const ignoreJSONStructure = options.ignoreJSONStructure !== undefined ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;\n        let path = [\n            lng,\n            ns\n        ];\n        if (key && typeof key !== \"string\") path = path.concat(key);\n        if (key && typeof key === \"string\") path = path.concat(keySeparator ? key.split(keySeparator) : key);\n        if (lng.indexOf(\".\") > -1) {\n            path = lng.split(\".\");\n        }\n        const result = getPath(this.data, path);\n        if (result || !ignoreJSONStructure || typeof key !== \"string\") return result;\n        return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);\n    }\n    addResource(lng, ns, key, value) {\n        let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n            silent: false\n        };\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        let path = [\n            lng,\n            ns\n        ];\n        if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);\n        if (lng.indexOf(\".\") > -1) {\n            path = lng.split(\".\");\n            value = ns;\n            ns = path[1];\n        }\n        this.addNamespaces(ns);\n        setPath(this.data, path, value);\n        if (!options.silent) this.emit(\"added\", lng, ns, key, value);\n    }\n    addResources(lng, ns, resources) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n            silent: false\n        };\n        for(const m in resources){\n            if (typeof resources[m] === \"string\" || Object.prototype.toString.apply(resources[m]) === \"[object Array]\") this.addResource(lng, ns, m, resources[m], {\n                silent: true\n            });\n        }\n        if (!options.silent) this.emit(\"added\", lng, ns, resources);\n    }\n    addResourceBundle(lng, ns, resources, deep, overwrite) {\n        let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {\n            silent: false\n        };\n        let path = [\n            lng,\n            ns\n        ];\n        if (lng.indexOf(\".\") > -1) {\n            path = lng.split(\".\");\n            deep = resources;\n            resources = ns;\n            ns = path[1];\n        }\n        this.addNamespaces(ns);\n        let pack = getPath(this.data, path) || {};\n        if (deep) {\n            deepExtend(pack, resources, overwrite);\n        } else {\n            pack = {\n                ...pack,\n                ...resources\n            };\n        }\n        setPath(this.data, path, pack);\n        if (!options.silent) this.emit(\"added\", lng, ns, resources);\n    }\n    removeResourceBundle(lng, ns) {\n        if (this.hasResourceBundle(lng, ns)) {\n            delete this.data[lng][ns];\n        }\n        this.removeNamespaces(ns);\n        this.emit(\"removed\", lng, ns);\n    }\n    hasResourceBundle(lng, ns) {\n        return this.getResource(lng, ns) !== undefined;\n    }\n    getResourceBundle(lng, ns) {\n        if (!ns) ns = this.options.defaultNS;\n        if (this.options.compatibilityAPI === \"v1\") return {\n            ...{},\n            ...this.getResource(lng, ns)\n        };\n        return this.getResource(lng, ns);\n    }\n    getDataByLanguage(lng) {\n        return this.data[lng];\n    }\n    hasLanguageSomeTranslations(lng) {\n        const data = this.getDataByLanguage(lng);\n        const n = data && Object.keys(data) || [];\n        return !!n.find((v)=>data[v] && Object.keys(data[v]).length > 0);\n    }\n    toJSON() {\n        return this.data;\n    }\n}\nvar postProcessor = {\n    processors: {},\n    addPostProcessor (module) {\n        this.processors[module.name] = module;\n    },\n    handle (processors, value, key, options, translator) {\n        processors.forEach((processor)=>{\n            if (this.processors[processor]) value = this.processors[processor].process(value, key, options, translator);\n        });\n        return value;\n    }\n};\nconst checkedLoadedFor = {};\nclass Translator extends EventEmitter {\n    constructor(services){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        super();\n        copy([\n            \"resourceStore\",\n            \"languageUtils\",\n            \"pluralResolver\",\n            \"interpolator\",\n            \"backendConnector\",\n            \"i18nFormat\",\n            \"utils\"\n        ], services, this);\n        this.options = options;\n        if (this.options.keySeparator === undefined) {\n            this.options.keySeparator = \".\";\n        }\n        this.logger = baseLogger.create(\"translator\");\n    }\n    changeLanguage(lng) {\n        if (lng) this.language = lng;\n    }\n    exists(key) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            interpolation: {}\n        };\n        if (key === undefined || key === null) {\n            return false;\n        }\n        const resolved = this.resolve(key, options);\n        return resolved && resolved.res !== undefined;\n    }\n    extractFromKey(key, options) {\n        let nsSeparator = options.nsSeparator !== undefined ? options.nsSeparator : this.options.nsSeparator;\n        if (nsSeparator === undefined) nsSeparator = \":\";\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        let namespaces = options.ns || this.options.defaultNS || [];\n        const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;\n        const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);\n        if (wouldCheckForNsInKey && !seemsNaturalLanguage) {\n            const m = key.match(this.interpolator.nestingRegexp);\n            if (m && m.length > 0) {\n                return {\n                    key,\n                    namespaces\n                };\n            }\n            const parts = key.split(nsSeparator);\n            if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();\n            key = parts.join(keySeparator);\n        }\n        if (typeof namespaces === \"string\") namespaces = [\n            namespaces\n        ];\n        return {\n            key,\n            namespaces\n        };\n    }\n    translate(keys, options, lastKey) {\n        if (typeof options !== \"object\" && this.options.overloadTranslationOptionHandler) {\n            options = this.options.overloadTranslationOptionHandler(arguments);\n        }\n        if (typeof options === \"object\") options = {\n            ...options\n        };\n        if (!options) options = {};\n        if (keys === undefined || keys === null) return \"\";\n        if (!Array.isArray(keys)) keys = [\n            String(keys)\n        ];\n        const returnDetails = options.returnDetails !== undefined ? options.returnDetails : this.options.returnDetails;\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        const { key, namespaces } = this.extractFromKey(keys[keys.length - 1], options);\n        const namespace = namespaces[namespaces.length - 1];\n        const lng = options.lng || this.language;\n        const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;\n        if (lng && lng.toLowerCase() === \"cimode\") {\n            if (appendNamespaceToCIMode) {\n                const nsSeparator = options.nsSeparator || this.options.nsSeparator;\n                if (returnDetails) {\n                    return {\n                        res: `${namespace}${nsSeparator}${key}`,\n                        usedKey: key,\n                        exactUsedKey: key,\n                        usedLng: lng,\n                        usedNS: namespace,\n                        usedParams: this.getUsedParamsDetails(options)\n                    };\n                }\n                return `${namespace}${nsSeparator}${key}`;\n            }\n            if (returnDetails) {\n                return {\n                    res: key,\n                    usedKey: key,\n                    exactUsedKey: key,\n                    usedLng: lng,\n                    usedNS: namespace,\n                    usedParams: this.getUsedParamsDetails(options)\n                };\n            }\n            return key;\n        }\n        const resolved = this.resolve(keys, options);\n        let res = resolved && resolved.res;\n        const resUsedKey = resolved && resolved.usedKey || key;\n        const resExactUsedKey = resolved && resolved.exactUsedKey || key;\n        const resType = Object.prototype.toString.apply(res);\n        const noObject = [\n            \"[object Number]\",\n            \"[object Function]\",\n            \"[object RegExp]\"\n        ];\n        const joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;\n        const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;\n        const handleAsObject = typeof res !== \"string\" && typeof res !== \"boolean\" && typeof res !== \"number\";\n        if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === \"string\" && resType === \"[object Array]\")) {\n            if (!options.returnObjects && !this.options.returnObjects) {\n                if (!this.options.returnedObjectHandler) {\n                    this.logger.warn(\"accessing an object - but returnObjects options is not enabled!\");\n                }\n                const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {\n                    ...options,\n                    ns: namespaces\n                }) : `key '${key} (${this.language})' returned an object instead of string.`;\n                if (returnDetails) {\n                    resolved.res = r;\n                    resolved.usedParams = this.getUsedParamsDetails(options);\n                    return resolved;\n                }\n                return r;\n            }\n            if (keySeparator) {\n                const resTypeIsArray = resType === \"[object Array]\";\n                const copy = resTypeIsArray ? [] : {};\n                const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;\n                for(const m in res){\n                    if (Object.prototype.hasOwnProperty.call(res, m)) {\n                        const deepKey = `${newKeyToUse}${keySeparator}${m}`;\n                        copy[m] = this.translate(deepKey, {\n                            ...options,\n                            ...{\n                                joinArrays: false,\n                                ns: namespaces\n                            }\n                        });\n                        if (copy[m] === deepKey) copy[m] = res[m];\n                    }\n                }\n                res = copy;\n            }\n        } else if (handleAsObjectInI18nFormat && typeof joinArrays === \"string\" && resType === \"[object Array]\") {\n            res = res.join(joinArrays);\n            if (res) res = this.extendTranslation(res, keys, options, lastKey);\n        } else {\n            let usedDefault = false;\n            let usedKey = false;\n            const needsPluralHandling = options.count !== undefined && typeof options.count !== \"string\";\n            const hasDefaultValue = Translator.hasDefaultValue(options);\n            const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : \"\";\n            const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {\n                ordinal: false\n            }) : \"\";\n            const defaultValue = options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;\n            if (!this.isValidLookup(res) && hasDefaultValue) {\n                usedDefault = true;\n                res = defaultValue;\n            }\n            if (!this.isValidLookup(res)) {\n                usedKey = true;\n                res = key;\n            }\n            const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;\n            const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;\n            const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;\n            if (usedKey || usedDefault || updateMissing) {\n                this.logger.log(updateMissing ? \"updateKey\" : \"missingKey\", lng, namespace, key, updateMissing ? defaultValue : res);\n                if (keySeparator) {\n                    const fk = this.resolve(key, {\n                        ...options,\n                        keySeparator: false\n                    });\n                    if (fk && fk.res) this.logger.warn(\"Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.\");\n                }\n                let lngs = [];\n                const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);\n                if (this.options.saveMissingTo === \"fallback\" && fallbackLngs && fallbackLngs[0]) {\n                    for(let i = 0; i < fallbackLngs.length; i++){\n                        lngs.push(fallbackLngs[i]);\n                    }\n                } else if (this.options.saveMissingTo === \"all\") {\n                    lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);\n                } else {\n                    lngs.push(options.lng || this.language);\n                }\n                const send = (l, k, specificDefaultValue)=>{\n                    const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;\n                    if (this.options.missingKeyHandler) {\n                        this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);\n                    } else if (this.backendConnector && this.backendConnector.saveMissing) {\n                        this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);\n                    }\n                    this.emit(\"missingKey\", l, namespace, k, res);\n                };\n                if (this.options.saveMissing) {\n                    if (this.options.saveMissingPlurals && needsPluralHandling) {\n                        lngs.forEach((language)=>{\n                            this.pluralResolver.getSuffixes(language, options).forEach((suffix)=>{\n                                send([\n                                    language\n                                ], key + suffix, options[`defaultValue${suffix}`] || defaultValue);\n                            });\n                        });\n                    } else {\n                        send(lngs, key, defaultValue);\n                    }\n                }\n            }\n            res = this.extendTranslation(res, keys, options, resolved, lastKey);\n            if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = `${namespace}:${key}`;\n            if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {\n                if (this.options.compatibilityAPI !== \"v1\") {\n                    res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key}` : key, usedDefault ? res : undefined);\n                } else {\n                    res = this.options.parseMissingKeyHandler(res);\n                }\n            }\n        }\n        if (returnDetails) {\n            resolved.res = res;\n            resolved.usedParams = this.getUsedParamsDetails(options);\n            return resolved;\n        }\n        return res;\n    }\n    extendTranslation(res, key, options, resolved, lastKey) {\n        var _this = this;\n        if (this.i18nFormat && this.i18nFormat.parse) {\n            res = this.i18nFormat.parse(res, {\n                ...this.options.interpolation.defaultVariables,\n                ...options\n            }, options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {\n                resolved\n            });\n        } else if (!options.skipInterpolation) {\n            if (options.interpolation) this.interpolator.init({\n                ...options,\n                ...{\n                    interpolation: {\n                        ...this.options.interpolation,\n                        ...options.interpolation\n                    }\n                }\n            });\n            const skipOnVariables = typeof res === \"string\" && (options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);\n            let nestBef;\n            if (skipOnVariables) {\n                const nb = res.match(this.interpolator.nestingRegexp);\n                nestBef = nb && nb.length;\n            }\n            let data = options.replace && typeof options.replace !== \"string\" ? options.replace : options;\n            if (this.options.interpolation.defaultVariables) data = {\n                ...this.options.interpolation.defaultVariables,\n                ...data\n            };\n            res = this.interpolator.interpolate(res, data, options.lng || this.language, options);\n            if (skipOnVariables) {\n                const na = res.match(this.interpolator.nestingRegexp);\n                const nestAft = na && na.length;\n                if (nestBef < nestAft) options.nest = false;\n            }\n            if (!options.lng && this.options.compatibilityAPI !== \"v1\" && resolved && resolved.res) options.lng = resolved.usedLng;\n            if (options.nest !== false) res = this.interpolator.nest(res, function() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                if (lastKey && lastKey[0] === args[0] && !options.context) {\n                    _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);\n                    return null;\n                }\n                return _this.translate(...args, key);\n            }, options);\n            if (options.interpolation) this.interpolator.reset();\n        }\n        const postProcess = options.postProcess || this.options.postProcess;\n        const postProcessorNames = typeof postProcess === \"string\" ? [\n            postProcess\n        ] : postProcess;\n        if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {\n            res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {\n                i18nResolved: {\n                    ...resolved,\n                    usedParams: this.getUsedParamsDetails(options)\n                },\n                ...options\n            } : options, this);\n        }\n        return res;\n    }\n    resolve(keys) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let found;\n        let usedKey;\n        let exactUsedKey;\n        let usedLng;\n        let usedNS;\n        if (typeof keys === \"string\") keys = [\n            keys\n        ];\n        keys.forEach((k)=>{\n            if (this.isValidLookup(found)) return;\n            const extracted = this.extractFromKey(k, options);\n            const key = extracted.key;\n            usedKey = key;\n            let namespaces = extracted.namespaces;\n            if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);\n            const needsPluralHandling = options.count !== undefined && typeof options.count !== \"string\";\n            const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();\n            const needsContextHandling = options.context !== undefined && (typeof options.context === \"string\" || typeof options.context === \"number\") && options.context !== \"\";\n            const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);\n            namespaces.forEach((ns)=>{\n                if (this.isValidLookup(found)) return;\n                usedNS = ns;\n                if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {\n                    checkedLoadedFor[`${codes[0]}-${ns}`] = true;\n                    this.logger.warn(`key \"${usedKey}\" for languages \"${codes.join(\", \")}\" won't get resolved as namespace \"${usedNS}\" was not yet loaded`, \"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!\");\n                }\n                codes.forEach((code)=>{\n                    if (this.isValidLookup(found)) return;\n                    usedLng = code;\n                    const finalKeys = [\n                        key\n                    ];\n                    if (this.i18nFormat && this.i18nFormat.addLookupKeys) {\n                        this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);\n                    } else {\n                        let pluralSuffix;\n                        if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);\n                        const zeroSuffix = `${this.options.pluralSeparator}zero`;\n                        const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;\n                        if (needsPluralHandling) {\n                            finalKeys.push(key + pluralSuffix);\n                            if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {\n                                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));\n                            }\n                            if (needsZeroSuffixLookup) {\n                                finalKeys.push(key + zeroSuffix);\n                            }\n                        }\n                        if (needsContextHandling) {\n                            const contextKey = `${key}${this.options.contextSeparator}${options.context}`;\n                            finalKeys.push(contextKey);\n                            if (needsPluralHandling) {\n                                finalKeys.push(contextKey + pluralSuffix);\n                                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {\n                                    finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));\n                                }\n                                if (needsZeroSuffixLookup) {\n                                    finalKeys.push(contextKey + zeroSuffix);\n                                }\n                            }\n                        }\n                    }\n                    let possibleKey;\n                    while(possibleKey = finalKeys.pop()){\n                        if (!this.isValidLookup(found)) {\n                            exactUsedKey = possibleKey;\n                            found = this.getResource(code, ns, possibleKey, options);\n                        }\n                    }\n                });\n            });\n        });\n        return {\n            res: found,\n            usedKey,\n            exactUsedKey,\n            usedLng,\n            usedNS\n        };\n    }\n    isValidLookup(res) {\n        return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === \"\");\n    }\n    getResource(code, ns, key) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);\n        return this.resourceStore.getResource(code, ns, key, options);\n    }\n    getUsedParamsDetails() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        const optionsKeys = [\n            \"defaultValue\",\n            \"ordinal\",\n            \"context\",\n            \"replace\",\n            \"lng\",\n            \"lngs\",\n            \"fallbackLng\",\n            \"ns\",\n            \"keySeparator\",\n            \"nsSeparator\",\n            \"returnObjects\",\n            \"returnDetails\",\n            \"joinArrays\",\n            \"postProcess\",\n            \"interpolation\"\n        ];\n        const useOptionsReplaceForData = options.replace && typeof options.replace !== \"string\";\n        let data = useOptionsReplaceForData ? options.replace : options;\n        if (useOptionsReplaceForData && typeof options.count !== \"undefined\") {\n            data.count = options.count;\n        }\n        if (this.options.interpolation.defaultVariables) {\n            data = {\n                ...this.options.interpolation.defaultVariables,\n                ...data\n            };\n        }\n        if (!useOptionsReplaceForData) {\n            data = {\n                ...data\n            };\n            for (const key of optionsKeys){\n                delete data[key];\n            }\n        }\n        return data;\n    }\n    static hasDefaultValue(options) {\n        const prefix = \"defaultValue\";\n        for(const option in options){\n            if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && undefined !== options[option]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nfunction capitalize(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n}\nclass LanguageUtil {\n    constructor(options){\n        this.options = options;\n        this.supportedLngs = this.options.supportedLngs || false;\n        this.logger = baseLogger.create(\"languageUtils\");\n    }\n    getScriptPartFromCode(code) {\n        code = getCleanedCode(code);\n        if (!code || code.indexOf(\"-\") < 0) return null;\n        const p = code.split(\"-\");\n        if (p.length === 2) return null;\n        p.pop();\n        if (p[p.length - 1].toLowerCase() === \"x\") return null;\n        return this.formatLanguageCode(p.join(\"-\"));\n    }\n    getLanguagePartFromCode(code) {\n        code = getCleanedCode(code);\n        if (!code || code.indexOf(\"-\") < 0) return code;\n        const p = code.split(\"-\");\n        return this.formatLanguageCode(p[0]);\n    }\n    formatLanguageCode(code) {\n        if (typeof code === \"string\" && code.indexOf(\"-\") > -1) {\n            const specialCases = [\n                \"hans\",\n                \"hant\",\n                \"latn\",\n                \"cyrl\",\n                \"cans\",\n                \"mong\",\n                \"arab\"\n            ];\n            let p = code.split(\"-\");\n            if (this.options.lowerCaseLng) {\n                p = p.map((part)=>part.toLowerCase());\n            } else if (p.length === 2) {\n                p[0] = p[0].toLowerCase();\n                p[1] = p[1].toUpperCase();\n                if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());\n            } else if (p.length === 3) {\n                p[0] = p[0].toLowerCase();\n                if (p[1].length === 2) p[1] = p[1].toUpperCase();\n                if (p[0] !== \"sgn\" && p[2].length === 2) p[2] = p[2].toUpperCase();\n                if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());\n                if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());\n            }\n            return p.join(\"-\");\n        }\n        return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;\n    }\n    isSupportedCode(code) {\n        if (this.options.load === \"languageOnly\" || this.options.nonExplicitSupportedLngs) {\n            code = this.getLanguagePartFromCode(code);\n        }\n        return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;\n    }\n    getBestMatchFromCodes(codes) {\n        if (!codes) return null;\n        let found;\n        codes.forEach((code)=>{\n            if (found) return;\n            const cleanedLng = this.formatLanguageCode(code);\n            if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;\n        });\n        if (!found && this.options.supportedLngs) {\n            codes.forEach((code)=>{\n                if (found) return;\n                const lngOnly = this.getLanguagePartFromCode(code);\n                if (this.isSupportedCode(lngOnly)) return found = lngOnly;\n                found = this.options.supportedLngs.find((supportedLng)=>{\n                    if (supportedLng === lngOnly) return supportedLng;\n                    if (supportedLng.indexOf(\"-\") < 0 && lngOnly.indexOf(\"-\") < 0) return;\n                    if (supportedLng.indexOf(lngOnly) === 0) return supportedLng;\n                });\n            });\n        }\n        if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];\n        return found;\n    }\n    getFallbackCodes(fallbacks, code) {\n        if (!fallbacks) return [];\n        if (typeof fallbacks === \"function\") fallbacks = fallbacks(code);\n        if (typeof fallbacks === \"string\") fallbacks = [\n            fallbacks\n        ];\n        if (Object.prototype.toString.apply(fallbacks) === \"[object Array]\") return fallbacks;\n        if (!code) return fallbacks.default || [];\n        let found = fallbacks[code];\n        if (!found) found = fallbacks[this.getScriptPartFromCode(code)];\n        if (!found) found = fallbacks[this.formatLanguageCode(code)];\n        if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];\n        if (!found) found = fallbacks.default;\n        return found || [];\n    }\n    toResolveHierarchy(code, fallbackCode) {\n        const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);\n        const codes = [];\n        const addCode = (c)=>{\n            if (!c) return;\n            if (this.isSupportedCode(c)) {\n                codes.push(c);\n            } else {\n                this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);\n            }\n        };\n        if (typeof code === \"string\" && (code.indexOf(\"-\") > -1 || code.indexOf(\"_\") > -1)) {\n            if (this.options.load !== \"languageOnly\") addCode(this.formatLanguageCode(code));\n            if (this.options.load !== \"languageOnly\" && this.options.load !== \"currentOnly\") addCode(this.getScriptPartFromCode(code));\n            if (this.options.load !== \"currentOnly\") addCode(this.getLanguagePartFromCode(code));\n        } else if (typeof code === \"string\") {\n            addCode(this.formatLanguageCode(code));\n        }\n        fallbackCodes.forEach((fc)=>{\n            if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));\n        });\n        return codes;\n    }\n}\nlet sets = [\n    {\n        lngs: [\n            \"ach\",\n            \"ak\",\n            \"am\",\n            \"arn\",\n            \"br\",\n            \"fil\",\n            \"gun\",\n            \"ln\",\n            \"mfe\",\n            \"mg\",\n            \"mi\",\n            \"oc\",\n            \"pt\",\n            \"pt-BR\",\n            \"tg\",\n            \"tl\",\n            \"ti\",\n            \"tr\",\n            \"uz\",\n            \"wa\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 1\n    },\n    {\n        lngs: [\n            \"af\",\n            \"an\",\n            \"ast\",\n            \"az\",\n            \"bg\",\n            \"bn\",\n            \"ca\",\n            \"da\",\n            \"de\",\n            \"dev\",\n            \"el\",\n            \"en\",\n            \"eo\",\n            \"es\",\n            \"et\",\n            \"eu\",\n            \"fi\",\n            \"fo\",\n            \"fur\",\n            \"fy\",\n            \"gl\",\n            \"gu\",\n            \"ha\",\n            \"hi\",\n            \"hu\",\n            \"hy\",\n            \"ia\",\n            \"it\",\n            \"kk\",\n            \"kn\",\n            \"ku\",\n            \"lb\",\n            \"mai\",\n            \"ml\",\n            \"mn\",\n            \"mr\",\n            \"nah\",\n            \"nap\",\n            \"nb\",\n            \"ne\",\n            \"nl\",\n            \"nn\",\n            \"no\",\n            \"nso\",\n            \"pa\",\n            \"pap\",\n            \"pms\",\n            \"ps\",\n            \"pt-PT\",\n            \"rm\",\n            \"sco\",\n            \"se\",\n            \"si\",\n            \"so\",\n            \"son\",\n            \"sq\",\n            \"sv\",\n            \"sw\",\n            \"ta\",\n            \"te\",\n            \"tk\",\n            \"ur\",\n            \"yo\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 2\n    },\n    {\n        lngs: [\n            \"ay\",\n            \"bo\",\n            \"cgg\",\n            \"fa\",\n            \"ht\",\n            \"id\",\n            \"ja\",\n            \"jbo\",\n            \"ka\",\n            \"km\",\n            \"ko\",\n            \"ky\",\n            \"lo\",\n            \"ms\",\n            \"sah\",\n            \"su\",\n            \"th\",\n            \"tt\",\n            \"ug\",\n            \"vi\",\n            \"wo\",\n            \"zh\"\n        ],\n        nr: [\n            1\n        ],\n        fc: 3\n    },\n    {\n        lngs: [\n            \"be\",\n            \"bs\",\n            \"cnr\",\n            \"dz\",\n            \"hr\",\n            \"ru\",\n            \"sr\",\n            \"uk\"\n        ],\n        nr: [\n            1,\n            2,\n            5\n        ],\n        fc: 4\n    },\n    {\n        lngs: [\n            \"ar\"\n        ],\n        nr: [\n            0,\n            1,\n            2,\n            3,\n            11,\n            100\n        ],\n        fc: 5\n    },\n    {\n        lngs: [\n            \"cs\",\n            \"sk\"\n        ],\n        nr: [\n            1,\n            2,\n            5\n        ],\n        fc: 6\n    },\n    {\n        lngs: [\n            \"csb\",\n            \"pl\"\n        ],\n        nr: [\n            1,\n            2,\n            5\n        ],\n        fc: 7\n    },\n    {\n        lngs: [\n            \"cy\"\n        ],\n        nr: [\n            1,\n            2,\n            3,\n            8\n        ],\n        fc: 8\n    },\n    {\n        lngs: [\n            \"fr\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 9\n    },\n    {\n        lngs: [\n            \"ga\"\n        ],\n        nr: [\n            1,\n            2,\n            3,\n            7,\n            11\n        ],\n        fc: 10\n    },\n    {\n        lngs: [\n            \"gd\"\n        ],\n        nr: [\n            1,\n            2,\n            3,\n            20\n        ],\n        fc: 11\n    },\n    {\n        lngs: [\n            \"is\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 12\n    },\n    {\n        lngs: [\n            \"jv\"\n        ],\n        nr: [\n            0,\n            1\n        ],\n        fc: 13\n    },\n    {\n        lngs: [\n            \"kw\"\n        ],\n        nr: [\n            1,\n            2,\n            3,\n            4\n        ],\n        fc: 14\n    },\n    {\n        lngs: [\n            \"lt\"\n        ],\n        nr: [\n            1,\n            2,\n            10\n        ],\n        fc: 15\n    },\n    {\n        lngs: [\n            \"lv\"\n        ],\n        nr: [\n            1,\n            2,\n            0\n        ],\n        fc: 16\n    },\n    {\n        lngs: [\n            \"mk\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 17\n    },\n    {\n        lngs: [\n            \"mnk\"\n        ],\n        nr: [\n            0,\n            1,\n            2\n        ],\n        fc: 18\n    },\n    {\n        lngs: [\n            \"mt\"\n        ],\n        nr: [\n            1,\n            2,\n            11,\n            20\n        ],\n        fc: 19\n    },\n    {\n        lngs: [\n            \"or\"\n        ],\n        nr: [\n            2,\n            1\n        ],\n        fc: 2\n    },\n    {\n        lngs: [\n            \"ro\"\n        ],\n        nr: [\n            1,\n            2,\n            20\n        ],\n        fc: 20\n    },\n    {\n        lngs: [\n            \"sl\"\n        ],\n        nr: [\n            5,\n            1,\n            2,\n            3\n        ],\n        fc: 21\n    },\n    {\n        lngs: [\n            \"he\",\n            \"iw\"\n        ],\n        nr: [\n            1,\n            2,\n            20,\n            21\n        ],\n        fc: 22\n    }\n];\nlet _rulesPluralsTypes = {\n    1: function(n) {\n        return Number(n > 1);\n    },\n    2: function(n) {\n        return Number(n != 1);\n    },\n    3: function(n) {\n        return 0;\n    },\n    4: function(n) {\n        return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n    },\n    5: function(n) {\n        return Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);\n    },\n    6: function(n) {\n        return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);\n    },\n    7: function(n) {\n        return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n    },\n    8: function(n) {\n        return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);\n    },\n    9: function(n) {\n        return Number(n >= 2);\n    },\n    10: function(n) {\n        return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);\n    },\n    11: function(n) {\n        return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);\n    },\n    12: function(n) {\n        return Number(n % 10 != 1 || n % 100 == 11);\n    },\n    13: function(n) {\n        return Number(n !== 0);\n    },\n    14: function(n) {\n        return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);\n    },\n    15: function(n) {\n        return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n    },\n    16: function(n) {\n        return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);\n    },\n    17: function(n) {\n        return Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1);\n    },\n    18: function(n) {\n        return Number(n == 0 ? 0 : n == 1 ? 1 : 2);\n    },\n    19: function(n) {\n        return Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);\n    },\n    20: function(n) {\n        return Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);\n    },\n    21: function(n) {\n        return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);\n    },\n    22: function(n) {\n        return Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);\n    }\n};\nconst nonIntlVersions = [\n    \"v1\",\n    \"v2\",\n    \"v3\"\n];\nconst intlVersions = [\n    \"v4\"\n];\nconst suffixesOrder = {\n    zero: 0,\n    one: 1,\n    two: 2,\n    few: 3,\n    many: 4,\n    other: 5\n};\nfunction createRules() {\n    const rules = {};\n    sets.forEach((set)=>{\n        set.lngs.forEach((l)=>{\n            rules[l] = {\n                numbers: set.nr,\n                plurals: _rulesPluralsTypes[set.fc]\n            };\n        });\n    });\n    return rules;\n}\nclass PluralResolver {\n    constructor(languageUtils){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.languageUtils = languageUtils;\n        this.options = options;\n        this.logger = baseLogger.create(\"pluralResolver\");\n        if ((!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl === \"undefined\" || !Intl.PluralRules)) {\n            this.options.compatibilityJSON = \"v3\";\n            this.logger.error(\"Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.\");\n        }\n        this.rules = createRules();\n    }\n    addRule(lng, obj) {\n        this.rules[lng] = obj;\n    }\n    getRule(code) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        if (this.shouldUseIntlApi()) {\n            try {\n                return new Intl.PluralRules(getCleanedCode(code), {\n                    type: options.ordinal ? \"ordinal\" : \"cardinal\"\n                });\n            } catch (err) {\n                return;\n            }\n        }\n        return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];\n    }\n    needsPlural(code) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        const rule = this.getRule(code, options);\n        if (this.shouldUseIntlApi()) {\n            return rule && rule.resolvedOptions().pluralCategories.length > 1;\n        }\n        return rule && rule.numbers.length > 1;\n    }\n    getPluralFormsOfKey(code, key) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return this.getSuffixes(code, options).map((suffix)=>`${key}${suffix}`);\n    }\n    getSuffixes(code) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        const rule = this.getRule(code, options);\n        if (!rule) {\n            return [];\n        }\n        if (this.shouldUseIntlApi()) {\n            return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2)=>suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory)=>`${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : \"\"}${pluralCategory}`);\n        }\n        return rule.numbers.map((number)=>this.getSuffix(code, number, options));\n    }\n    getSuffix(code, count) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        const rule = this.getRule(code, options);\n        if (rule) {\n            if (this.shouldUseIntlApi()) {\n                return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : \"\"}${rule.select(count)}`;\n            }\n            return this.getSuffixRetroCompatible(rule, count);\n        }\n        this.logger.warn(`no plural rule found for: ${code}`);\n        return \"\";\n    }\n    getSuffixRetroCompatible(rule, count) {\n        const idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));\n        let suffix = rule.numbers[idx];\n        if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {\n            if (suffix === 2) {\n                suffix = \"plural\";\n            } else if (suffix === 1) {\n                suffix = \"\";\n            }\n        }\n        const returnSuffix = ()=>this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();\n        if (this.options.compatibilityJSON === \"v1\") {\n            if (suffix === 1) return \"\";\n            if (typeof suffix === \"number\") return `_plural_${suffix.toString()}`;\n            return returnSuffix();\n        } else if (this.options.compatibilityJSON === \"v2\") {\n            return returnSuffix();\n        } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {\n            return returnSuffix();\n        }\n        return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();\n    }\n    shouldUseIntlApi() {\n        return !nonIntlVersions.includes(this.options.compatibilityJSON);\n    }\n}\nfunction deepFindWithDefaults(data, defaultData, key) {\n    let keySeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \".\";\n    let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    let path = getPathWithDefaults(data, defaultData, key);\n    if (!path && ignoreJSONStructure && typeof key === \"string\") {\n        path = deepFind(data, key, keySeparator);\n        if (path === undefined) path = deepFind(defaultData, key, keySeparator);\n    }\n    return path;\n}\nclass Interpolator {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        this.logger = baseLogger.create(\"interpolator\");\n        this.options = options;\n        this.format = options.interpolation && options.interpolation.format || ((value)=>value);\n        this.init(options);\n    }\n    init() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (!options.interpolation) options.interpolation = {\n            escapeValue: true\n        };\n        const iOpts = options.interpolation;\n        this.escape = iOpts.escape !== undefined ? iOpts.escape : escape;\n        this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;\n        this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;\n        this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || \"{{\";\n        this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || \"}}\";\n        this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || \",\";\n        this.unescapePrefix = iOpts.unescapeSuffix ? \"\" : iOpts.unescapePrefix || \"-\";\n        this.unescapeSuffix = this.unescapePrefix ? \"\" : iOpts.unescapeSuffix || \"\";\n        this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape(\"$t(\");\n        this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(\")\");\n        this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || \",\";\n        this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000;\n        this.alwaysFormat = iOpts.alwaysFormat !== undefined ? iOpts.alwaysFormat : false;\n        this.resetRegExp();\n    }\n    reset() {\n        if (this.options) this.init(this.options);\n    }\n    resetRegExp() {\n        const regexpStr = `${this.prefix}(.+?)${this.suffix}`;\n        this.regexp = new RegExp(regexpStr, \"g\");\n        const regexpUnescapeStr = `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`;\n        this.regexpUnescape = new RegExp(regexpUnescapeStr, \"g\");\n        const nestingRegexpStr = `${this.nestingPrefix}(.+?)${this.nestingSuffix}`;\n        this.nestingRegexp = new RegExp(nestingRegexpStr, \"g\");\n    }\n    interpolate(str, data, lng, options) {\n        let match;\n        let value;\n        let replaces;\n        const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};\n        function regexSafe(val) {\n            return val.replace(/\\$/g, \"$$$$\");\n        }\n        const handleFormat = (key)=>{\n            if (key.indexOf(this.formatSeparator) < 0) {\n                const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);\n                return this.alwaysFormat ? this.format(path, undefined, lng, {\n                    ...options,\n                    ...data,\n                    interpolationkey: key\n                }) : path;\n            }\n            const p = key.split(this.formatSeparator);\n            const k = p.shift().trim();\n            const f = p.join(this.formatSeparator).trim();\n            return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {\n                ...options,\n                ...data,\n                interpolationkey: k\n            });\n        };\n        this.resetRegExp();\n        const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;\n        const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;\n        const todos = [\n            {\n                regex: this.regexpUnescape,\n                safeValue: (val)=>regexSafe(val)\n            },\n            {\n                regex: this.regexp,\n                safeValue: (val)=>this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)\n            }\n        ];\n        todos.forEach((todo)=>{\n            replaces = 0;\n            while(match = todo.regex.exec(str)){\n                const matchedVar = match[1].trim();\n                value = handleFormat(matchedVar);\n                if (value === undefined) {\n                    if (typeof missingInterpolationHandler === \"function\") {\n                        const temp = missingInterpolationHandler(str, match, options);\n                        value = typeof temp === \"string\" ? temp : \"\";\n                    } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {\n                        value = \"\";\n                    } else if (skipOnVariables) {\n                        value = match[0];\n                        continue;\n                    } else {\n                        this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);\n                        value = \"\";\n                    }\n                } else if (typeof value !== \"string\" && !this.useRawValueToEscape) {\n                    value = makeString(value);\n                }\n                const safeValue = todo.safeValue(value);\n                str = str.replace(match[0], safeValue);\n                if (skipOnVariables) {\n                    todo.regex.lastIndex += value.length;\n                    todo.regex.lastIndex -= match[0].length;\n                } else {\n                    todo.regex.lastIndex = 0;\n                }\n                replaces++;\n                if (replaces >= this.maxReplaces) {\n                    break;\n                }\n            }\n        });\n        return str;\n    }\n    nest(str, fc) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        let match;\n        let value;\n        let clonedOptions;\n        function handleHasOptions(key, inheritedOptions) {\n            const sep = this.nestingOptionsSeparator;\n            if (key.indexOf(sep) < 0) return key;\n            const c = key.split(new RegExp(`${sep}[ ]*{`));\n            let optionsString = `{${c[1]}`;\n            key = c[0];\n            optionsString = this.interpolate(optionsString, clonedOptions);\n            const matchedSingleQuotes = optionsString.match(/'/g);\n            const matchedDoubleQuotes = optionsString.match(/\"/g);\n            if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {\n                optionsString = optionsString.replace(/'/g, '\"');\n            }\n            try {\n                clonedOptions = JSON.parse(optionsString);\n                if (inheritedOptions) clonedOptions = {\n                    ...inheritedOptions,\n                    ...clonedOptions\n                };\n            } catch (e) {\n                this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);\n                return `${key}${sep}${optionsString}`;\n            }\n            delete clonedOptions.defaultValue;\n            return key;\n        }\n        while(match = this.nestingRegexp.exec(str)){\n            let formatters = [];\n            clonedOptions = {\n                ...options\n            };\n            clonedOptions = clonedOptions.replace && typeof clonedOptions.replace !== \"string\" ? clonedOptions.replace : clonedOptions;\n            clonedOptions.applyPostProcessor = false;\n            delete clonedOptions.defaultValue;\n            let doReduce = false;\n            if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {\n                const r = match[1].split(this.formatSeparator).map((elem)=>elem.trim());\n                match[1] = r.shift();\n                formatters = r;\n                doReduce = true;\n            }\n            value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);\n            if (value && match[0] === str && typeof value !== \"string\") return value;\n            if (typeof value !== \"string\") value = makeString(value);\n            if (!value) {\n                this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);\n                value = \"\";\n            }\n            if (doReduce) {\n                value = formatters.reduce((v, f)=>this.format(v, f, options.lng, {\n                        ...options,\n                        interpolationkey: match[1].trim()\n                    }), value.trim());\n            }\n            str = str.replace(match[0], value);\n            this.regexp.lastIndex = 0;\n        }\n        return str;\n    }\n}\nfunction parseFormatStr(formatStr) {\n    let formatName = formatStr.toLowerCase().trim();\n    const formatOptions = {};\n    if (formatStr.indexOf(\"(\") > -1) {\n        const p = formatStr.split(\"(\");\n        formatName = p[0].toLowerCase().trim();\n        const optStr = p[1].substring(0, p[1].length - 1);\n        if (formatName === \"currency\" && optStr.indexOf(\":\") < 0) {\n            if (!formatOptions.currency) formatOptions.currency = optStr.trim();\n        } else if (formatName === \"relativetime\" && optStr.indexOf(\":\") < 0) {\n            if (!formatOptions.range) formatOptions.range = optStr.trim();\n        } else {\n            const opts = optStr.split(\";\");\n            opts.forEach((opt)=>{\n                if (!opt) return;\n                const [key, ...rest] = opt.split(\":\");\n                const val = rest.join(\":\").trim().replace(/^'+|'+$/g, \"\");\n                if (!formatOptions[key.trim()]) formatOptions[key.trim()] = val;\n                if (val === \"false\") formatOptions[key.trim()] = false;\n                if (val === \"true\") formatOptions[key.trim()] = true;\n                if (!isNaN(val)) formatOptions[key.trim()] = parseInt(val, 10);\n            });\n        }\n    }\n    return {\n        formatName,\n        formatOptions\n    };\n}\nfunction createCachedFormatter(fn) {\n    const cache = {};\n    return function invokeFormatter(val, lng, options) {\n        const key = lng + JSON.stringify(options);\n        let formatter = cache[key];\n        if (!formatter) {\n            formatter = fn(getCleanedCode(lng), options);\n            cache[key] = formatter;\n        }\n        return formatter(val);\n    };\n}\nclass Formatter {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        this.logger = baseLogger.create(\"formatter\");\n        this.options = options;\n        this.formats = {\n            number: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.NumberFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val);\n            }),\n            currency: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.NumberFormat(lng, {\n                    ...opt,\n                    style: \"currency\"\n                });\n                return (val)=>formatter.format(val);\n            }),\n            datetime: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.DateTimeFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val);\n            }),\n            relativetime: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.RelativeTimeFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val, opt.range || \"day\");\n            }),\n            list: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.ListFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val);\n            })\n        };\n        this.init(options);\n    }\n    init(services) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            interpolation: {}\n        };\n        const iOpts = options.interpolation;\n        this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || \",\";\n    }\n    add(name, fc) {\n        this.formats[name.toLowerCase().trim()] = fc;\n    }\n    addCached(name, fc) {\n        this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);\n    }\n    format(value, format, lng) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        const formats = format.split(this.formatSeparator);\n        const result = formats.reduce((mem, f)=>{\n            const { formatName, formatOptions } = parseFormatStr(f);\n            if (this.formats[formatName]) {\n                let formatted = mem;\n                try {\n                    const valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};\n                    const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;\n                    formatted = this.formats[formatName](mem, l, {\n                        ...formatOptions,\n                        ...options,\n                        ...valOptions\n                    });\n                } catch (error) {\n                    this.logger.warn(error);\n                }\n                return formatted;\n            } else {\n                this.logger.warn(`there was no format function for ${formatName}`);\n            }\n            return mem;\n        }, value);\n        return result;\n    }\n}\nfunction removePending(q, name) {\n    if (q.pending[name] !== undefined) {\n        delete q.pending[name];\n        q.pendingCount--;\n    }\n}\nclass Connector extends EventEmitter {\n    constructor(backend, store, services){\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        super();\n        this.backend = backend;\n        this.store = store;\n        this.services = services;\n        this.languageUtils = services.languageUtils;\n        this.options = options;\n        this.logger = baseLogger.create(\"backendConnector\");\n        this.waitingReads = [];\n        this.maxParallelReads = options.maxParallelReads || 10;\n        this.readingCalls = 0;\n        this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;\n        this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;\n        this.state = {};\n        this.queue = [];\n        if (this.backend && this.backend.init) {\n            this.backend.init(services, options.backend, options);\n        }\n    }\n    queueLoad(languages, namespaces, options, callback) {\n        const toLoad = {};\n        const pending = {};\n        const toLoadLanguages = {};\n        const toLoadNamespaces = {};\n        languages.forEach((lng)=>{\n            let hasAllNamespaces = true;\n            namespaces.forEach((ns)=>{\n                const name = `${lng}|${ns}`;\n                if (!options.reload && this.store.hasResourceBundle(lng, ns)) {\n                    this.state[name] = 2;\n                } else if (this.state[name] < 0) ;\n                else if (this.state[name] === 1) {\n                    if (pending[name] === undefined) pending[name] = true;\n                } else {\n                    this.state[name] = 1;\n                    hasAllNamespaces = false;\n                    if (pending[name] === undefined) pending[name] = true;\n                    if (toLoad[name] === undefined) toLoad[name] = true;\n                    if (toLoadNamespaces[ns] === undefined) toLoadNamespaces[ns] = true;\n                }\n            });\n            if (!hasAllNamespaces) toLoadLanguages[lng] = true;\n        });\n        if (Object.keys(toLoad).length || Object.keys(pending).length) {\n            this.queue.push({\n                pending,\n                pendingCount: Object.keys(pending).length,\n                loaded: {},\n                errors: [],\n                callback\n            });\n        }\n        return {\n            toLoad: Object.keys(toLoad),\n            pending: Object.keys(pending),\n            toLoadLanguages: Object.keys(toLoadLanguages),\n            toLoadNamespaces: Object.keys(toLoadNamespaces)\n        };\n    }\n    loaded(name, err, data) {\n        const s = name.split(\"|\");\n        const lng = s[0];\n        const ns = s[1];\n        if (err) this.emit(\"failedLoading\", lng, ns, err);\n        if (data) {\n            this.store.addResourceBundle(lng, ns, data);\n        }\n        this.state[name] = err ? -1 : 2;\n        const loaded = {};\n        this.queue.forEach((q)=>{\n            pushPath(q.loaded, [\n                lng\n            ], ns);\n            removePending(q, name);\n            if (err) q.errors.push(err);\n            if (q.pendingCount === 0 && !q.done) {\n                Object.keys(q.loaded).forEach((l)=>{\n                    if (!loaded[l]) loaded[l] = {};\n                    const loadedKeys = q.loaded[l];\n                    if (loadedKeys.length) {\n                        loadedKeys.forEach((n)=>{\n                            if (loaded[l][n] === undefined) loaded[l][n] = true;\n                        });\n                    }\n                });\n                q.done = true;\n                if (q.errors.length) {\n                    q.callback(q.errors);\n                } else {\n                    q.callback();\n                }\n            }\n        });\n        this.emit(\"loaded\", loaded);\n        this.queue = this.queue.filter((q)=>!q.done);\n    }\n    read(lng, ns, fcName) {\n        let tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n        let wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.retryTimeout;\n        let callback = arguments.length > 5 ? arguments[5] : undefined;\n        if (!lng.length) return callback(null, {});\n        if (this.readingCalls >= this.maxParallelReads) {\n            this.waitingReads.push({\n                lng,\n                ns,\n                fcName,\n                tried,\n                wait,\n                callback\n            });\n            return;\n        }\n        this.readingCalls++;\n        const resolver = (err, data)=>{\n            this.readingCalls--;\n            if (this.waitingReads.length > 0) {\n                const next = this.waitingReads.shift();\n                this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);\n            }\n            if (err && data && tried < this.maxRetries) {\n                setTimeout(()=>{\n                    this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);\n                }, wait);\n                return;\n            }\n            callback(err, data);\n        };\n        const fc = this.backend[fcName].bind(this.backend);\n        if (fc.length === 2) {\n            try {\n                const r = fc(lng, ns);\n                if (r && typeof r.then === \"function\") {\n                    r.then((data)=>resolver(null, data)).catch(resolver);\n                } else {\n                    resolver(null, r);\n                }\n            } catch (err) {\n                resolver(err);\n            }\n            return;\n        }\n        return fc(lng, ns, resolver);\n    }\n    prepareLoading(languages, namespaces) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        let callback = arguments.length > 3 ? arguments[3] : undefined;\n        if (!this.backend) {\n            this.logger.warn(\"No backend was added via i18next.use. Will not load resources.\");\n            return callback && callback();\n        }\n        if (typeof languages === \"string\") languages = this.languageUtils.toResolveHierarchy(languages);\n        if (typeof namespaces === \"string\") namespaces = [\n            namespaces\n        ];\n        const toLoad = this.queueLoad(languages, namespaces, options, callback);\n        if (!toLoad.toLoad.length) {\n            if (!toLoad.pending.length) callback();\n            return null;\n        }\n        toLoad.toLoad.forEach((name)=>{\n            this.loadOne(name);\n        });\n    }\n    load(languages, namespaces, callback) {\n        this.prepareLoading(languages, namespaces, {}, callback);\n    }\n    reload(languages, namespaces, callback) {\n        this.prepareLoading(languages, namespaces, {\n            reload: true\n        }, callback);\n    }\n    loadOne(name) {\n        let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n        const s = name.split(\"|\");\n        const lng = s[0];\n        const ns = s[1];\n        this.read(lng, ns, \"read\", undefined, undefined, (err, data)=>{\n            if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);\n            if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);\n            this.loaded(name, err, data);\n        });\n    }\n    saveMissing(languages, namespace, key, fallbackValue, isUpdate) {\n        let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n        let clb = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : ()=>{};\n        if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {\n            this.logger.warn(`did not save key \"${key}\" as the namespace \"${namespace}\" was not yet loaded`, \"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!\");\n            return;\n        }\n        if (key === undefined || key === null || key === \"\") return;\n        if (this.backend && this.backend.create) {\n            const opts = {\n                ...options,\n                isUpdate\n            };\n            const fc = this.backend.create.bind(this.backend);\n            if (fc.length < 6) {\n                try {\n                    let r;\n                    if (fc.length === 5) {\n                        r = fc(languages, namespace, key, fallbackValue, opts);\n                    } else {\n                        r = fc(languages, namespace, key, fallbackValue);\n                    }\n                    if (r && typeof r.then === \"function\") {\n                        r.then((data)=>clb(null, data)).catch(clb);\n                    } else {\n                        clb(null, r);\n                    }\n                } catch (err) {\n                    clb(err);\n                }\n            } else {\n                fc(languages, namespace, key, fallbackValue, clb, opts);\n            }\n        }\n        if (!languages || !languages[0]) return;\n        this.store.addResource(languages[0], namespace, key, fallbackValue);\n    }\n}\nfunction get() {\n    return {\n        debug: false,\n        initImmediate: true,\n        ns: [\n            \"translation\"\n        ],\n        defaultNS: [\n            \"translation\"\n        ],\n        fallbackLng: [\n            \"dev\"\n        ],\n        fallbackNS: false,\n        supportedLngs: false,\n        nonExplicitSupportedLngs: false,\n        load: \"all\",\n        preload: false,\n        simplifyPluralSuffix: true,\n        keySeparator: \".\",\n        nsSeparator: \":\",\n        pluralSeparator: \"_\",\n        contextSeparator: \"_\",\n        partialBundledLanguages: false,\n        saveMissing: false,\n        updateMissing: false,\n        saveMissingTo: \"fallback\",\n        saveMissingPlurals: true,\n        missingKeyHandler: false,\n        missingInterpolationHandler: false,\n        postProcess: false,\n        postProcessPassResolved: false,\n        returnNull: false,\n        returnEmptyString: true,\n        returnObjects: false,\n        joinArrays: false,\n        returnedObjectHandler: false,\n        parseMissingKeyHandler: false,\n        appendNamespaceToMissingKey: false,\n        appendNamespaceToCIMode: false,\n        overloadTranslationOptionHandler: function handle(args) {\n            let ret = {};\n            if (typeof args[1] === \"object\") ret = args[1];\n            if (typeof args[1] === \"string\") ret.defaultValue = args[1];\n            if (typeof args[2] === \"string\") ret.tDescription = args[2];\n            if (typeof args[2] === \"object\" || typeof args[3] === \"object\") {\n                const options = args[3] || args[2];\n                Object.keys(options).forEach((key)=>{\n                    ret[key] = options[key];\n                });\n            }\n            return ret;\n        },\n        interpolation: {\n            escapeValue: true,\n            format: (value)=>value,\n            prefix: \"{{\",\n            suffix: \"}}\",\n            formatSeparator: \",\",\n            unescapePrefix: \"-\",\n            nestingPrefix: \"$t(\",\n            nestingSuffix: \")\",\n            nestingOptionsSeparator: \",\",\n            maxReplaces: 1000,\n            skipOnVariables: true\n        }\n    };\n}\nfunction transformOptions(options) {\n    if (typeof options.ns === \"string\") options.ns = [\n        options.ns\n    ];\n    if (typeof options.fallbackLng === \"string\") options.fallbackLng = [\n        options.fallbackLng\n    ];\n    if (typeof options.fallbackNS === \"string\") options.fallbackNS = [\n        options.fallbackNS\n    ];\n    if (options.supportedLngs && options.supportedLngs.indexOf(\"cimode\") < 0) {\n        options.supportedLngs = options.supportedLngs.concat([\n            \"cimode\"\n        ]);\n    }\n    return options;\n}\nfunction noop() {}\nfunction bindMemberFunctions(inst) {\n    const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));\n    mems.forEach((mem)=>{\n        if (typeof inst[mem] === \"function\") {\n            inst[mem] = inst[mem].bind(inst);\n        }\n    });\n}\nclass I18n extends EventEmitter {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 ? arguments[1] : undefined;\n        super();\n        this.options = transformOptions(options);\n        this.services = {};\n        this.logger = baseLogger;\n        this.modules = {\n            external: []\n        };\n        bindMemberFunctions(this);\n        if (callback && !this.isInitialized && !options.isClone) {\n            if (!this.options.initImmediate) {\n                this.init(options, callback);\n                return this;\n            }\n            setTimeout(()=>{\n                this.init(options, callback);\n            }, 0);\n        }\n    }\n    init() {\n        var _this = this;\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 ? arguments[1] : undefined;\n        if (typeof options === \"function\") {\n            callback = options;\n            options = {};\n        }\n        if (!options.defaultNS && options.defaultNS !== false && options.ns) {\n            if (typeof options.ns === \"string\") {\n                options.defaultNS = options.ns;\n            } else if (options.ns.indexOf(\"translation\") < 0) {\n                options.defaultNS = options.ns[0];\n            }\n        }\n        const defOpts = get();\n        this.options = {\n            ...defOpts,\n            ...this.options,\n            ...transformOptions(options)\n        };\n        if (this.options.compatibilityAPI !== \"v1\") {\n            this.options.interpolation = {\n                ...defOpts.interpolation,\n                ...this.options.interpolation\n            };\n        }\n        if (options.keySeparator !== undefined) {\n            this.options.userDefinedKeySeparator = options.keySeparator;\n        }\n        if (options.nsSeparator !== undefined) {\n            this.options.userDefinedNsSeparator = options.nsSeparator;\n        }\n        function createClassOnDemand(ClassOrObject) {\n            if (!ClassOrObject) return null;\n            if (typeof ClassOrObject === \"function\") return new ClassOrObject();\n            return ClassOrObject;\n        }\n        if (!this.options.isClone) {\n            if (this.modules.logger) {\n                baseLogger.init(createClassOnDemand(this.modules.logger), this.options);\n            } else {\n                baseLogger.init(null, this.options);\n            }\n            let formatter;\n            if (this.modules.formatter) {\n                formatter = this.modules.formatter;\n            } else if (typeof Intl !== \"undefined\") {\n                formatter = Formatter;\n            }\n            const lu = new LanguageUtil(this.options);\n            this.store = new ResourceStore(this.options.resources, this.options);\n            const s = this.services;\n            s.logger = baseLogger;\n            s.resourceStore = this.store;\n            s.languageUtils = lu;\n            s.pluralResolver = new PluralResolver(lu, {\n                prepend: this.options.pluralSeparator,\n                compatibilityJSON: this.options.compatibilityJSON,\n                simplifyPluralSuffix: this.options.simplifyPluralSuffix\n            });\n            if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {\n                s.formatter = createClassOnDemand(formatter);\n                s.formatter.init(s, this.options);\n                this.options.interpolation.format = s.formatter.format.bind(s.formatter);\n            }\n            s.interpolator = new Interpolator(this.options);\n            s.utils = {\n                hasLoadedNamespace: this.hasLoadedNamespace.bind(this)\n            };\n            s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);\n            s.backendConnector.on(\"*\", function(event) {\n                for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    args[_key - 1] = arguments[_key];\n                }\n                _this.emit(event, ...args);\n            });\n            if (this.modules.languageDetector) {\n                s.languageDetector = createClassOnDemand(this.modules.languageDetector);\n                if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);\n            }\n            if (this.modules.i18nFormat) {\n                s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);\n                if (s.i18nFormat.init) s.i18nFormat.init(this);\n            }\n            this.translator = new Translator(this.services, this.options);\n            this.translator.on(\"*\", function(event) {\n                for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                    args[_key2 - 1] = arguments[_key2];\n                }\n                _this.emit(event, ...args);\n            });\n            this.modules.external.forEach((m)=>{\n                if (m.init) m.init(this);\n            });\n        }\n        this.format = this.options.interpolation.format;\n        if (!callback) callback = noop;\n        if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {\n            const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n            if (codes.length > 0 && codes[0] !== \"dev\") this.options.lng = codes[0];\n        }\n        if (!this.services.languageDetector && !this.options.lng) {\n            this.logger.warn(\"init: no languageDetector is used and no lng is defined\");\n        }\n        const storeApi = [\n            \"getResource\",\n            \"hasResourceBundle\",\n            \"getResourceBundle\",\n            \"getDataByLanguage\"\n        ];\n        storeApi.forEach((fcName)=>{\n            this[fcName] = function() {\n                return _this.store[fcName](...arguments);\n            };\n        });\n        const storeApiChained = [\n            \"addResource\",\n            \"addResources\",\n            \"addResourceBundle\",\n            \"removeResourceBundle\"\n        ];\n        storeApiChained.forEach((fcName)=>{\n            this[fcName] = function() {\n                _this.store[fcName](...arguments);\n                return _this;\n            };\n        });\n        const deferred = defer();\n        const load = ()=>{\n            const finish = (err, t)=>{\n                if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn(\"init: i18next is already initialized. You should call init just once!\");\n                this.isInitialized = true;\n                if (!this.options.isClone) this.logger.log(\"initialized\", this.options);\n                this.emit(\"initialized\", this.options);\n                deferred.resolve(t);\n                callback(err, t);\n            };\n            if (this.languages && this.options.compatibilityAPI !== \"v1\" && !this.isInitialized) return finish(null, this.t.bind(this));\n            this.changeLanguage(this.options.lng, finish);\n        };\n        if (this.options.resources || !this.options.initImmediate) {\n            load();\n        } else {\n            setTimeout(load, 0);\n        }\n        return deferred;\n    }\n    loadResources(language) {\n        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n        let usedCallback = callback;\n        const usedLng = typeof language === \"string\" ? language : this.language;\n        if (typeof language === \"function\") usedCallback = language;\n        if (!this.options.resources || this.options.partialBundledLanguages) {\n            if (usedLng && usedLng.toLowerCase() === \"cimode\" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();\n            const toLoad = [];\n            const append = (lng)=>{\n                if (!lng) return;\n                if (lng === \"cimode\") return;\n                const lngs = this.services.languageUtils.toResolveHierarchy(lng);\n                lngs.forEach((l)=>{\n                    if (l === \"cimode\") return;\n                    if (toLoad.indexOf(l) < 0) toLoad.push(l);\n                });\n            };\n            if (!usedLng) {\n                const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n                fallbacks.forEach((l)=>append(l));\n            } else {\n                append(usedLng);\n            }\n            if (this.options.preload) {\n                this.options.preload.forEach((l)=>append(l));\n            }\n            this.services.backendConnector.load(toLoad, this.options.ns, (e)=>{\n                if (!e && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);\n                usedCallback(e);\n            });\n        } else {\n            usedCallback(null);\n        }\n    }\n    reloadResources(lngs, ns, callback) {\n        const deferred = defer();\n        if (!lngs) lngs = this.languages;\n        if (!ns) ns = this.options.ns;\n        if (!callback) callback = noop;\n        this.services.backendConnector.reload(lngs, ns, (err)=>{\n            deferred.resolve();\n            callback(err);\n        });\n        return deferred;\n    }\n    use(module) {\n        if (!module) throw new Error(\"You are passing an undefined module! Please check the object you are passing to i18next.use()\");\n        if (!module.type) throw new Error(\"You are passing a wrong module! Please check the object you are passing to i18next.use()\");\n        if (module.type === \"backend\") {\n            this.modules.backend = module;\n        }\n        if (module.type === \"logger\" || module.log && module.warn && module.error) {\n            this.modules.logger = module;\n        }\n        if (module.type === \"languageDetector\") {\n            this.modules.languageDetector = module;\n        }\n        if (module.type === \"i18nFormat\") {\n            this.modules.i18nFormat = module;\n        }\n        if (module.type === \"postProcessor\") {\n            postProcessor.addPostProcessor(module);\n        }\n        if (module.type === \"formatter\") {\n            this.modules.formatter = module;\n        }\n        if (module.type === \"3rdParty\") {\n            this.modules.external.push(module);\n        }\n        return this;\n    }\n    setResolvedLanguage(l) {\n        if (!l || !this.languages) return;\n        if ([\n            \"cimode\",\n            \"dev\"\n        ].indexOf(l) > -1) return;\n        for(let li = 0; li < this.languages.length; li++){\n            const lngInLngs = this.languages[li];\n            if ([\n                \"cimode\",\n                \"dev\"\n            ].indexOf(lngInLngs) > -1) continue;\n            if (this.store.hasLanguageSomeTranslations(lngInLngs)) {\n                this.resolvedLanguage = lngInLngs;\n                break;\n            }\n        }\n    }\n    changeLanguage(lng, callback) {\n        var _this2 = this;\n        this.isLanguageChangingTo = lng;\n        const deferred = defer();\n        this.emit(\"languageChanging\", lng);\n        const setLngProps = (l)=>{\n            this.language = l;\n            this.languages = this.services.languageUtils.toResolveHierarchy(l);\n            this.resolvedLanguage = undefined;\n            this.setResolvedLanguage(l);\n        };\n        const done = (err, l)=>{\n            if (l) {\n                setLngProps(l);\n                this.translator.changeLanguage(l);\n                this.isLanguageChangingTo = undefined;\n                this.emit(\"languageChanged\", l);\n                this.logger.log(\"languageChanged\", l);\n            } else {\n                this.isLanguageChangingTo = undefined;\n            }\n            deferred.resolve(function() {\n                return _this2.t(...arguments);\n            });\n            if (callback) callback(err, function() {\n                return _this2.t(...arguments);\n            });\n        };\n        const setLng = (lngs)=>{\n            if (!lng && !lngs && this.services.languageDetector) lngs = [];\n            const l = typeof lngs === \"string\" ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);\n            if (l) {\n                if (!this.language) {\n                    setLngProps(l);\n                }\n                if (!this.translator.language) this.translator.changeLanguage(l);\n                if (this.services.languageDetector && this.services.languageDetector.cacheUserLanguage) this.services.languageDetector.cacheUserLanguage(l);\n            }\n            this.loadResources(l, (err)=>{\n                done(err, l);\n            });\n        };\n        if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {\n            setLng(this.services.languageDetector.detect());\n        } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {\n            if (this.services.languageDetector.detect.length === 0) {\n                this.services.languageDetector.detect().then(setLng);\n            } else {\n                this.services.languageDetector.detect(setLng);\n            }\n        } else {\n            setLng(lng);\n        }\n        return deferred;\n    }\n    getFixedT(lng, ns, keyPrefix) {\n        var _this3 = this;\n        const fixedT = function(key, opts) {\n            let options;\n            if (typeof opts !== \"object\") {\n                for(var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++){\n                    rest[_key3 - 2] = arguments[_key3];\n                }\n                options = _this3.options.overloadTranslationOptionHandler([\n                    key,\n                    opts\n                ].concat(rest));\n            } else {\n                options = {\n                    ...opts\n                };\n            }\n            options.lng = options.lng || fixedT.lng;\n            options.lngs = options.lngs || fixedT.lngs;\n            options.ns = options.ns || fixedT.ns;\n            options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;\n            const keySeparator = _this3.options.keySeparator || \".\";\n            let resultKey;\n            if (options.keyPrefix && Array.isArray(key)) {\n                resultKey = key.map((k)=>`${options.keyPrefix}${keySeparator}${k}`);\n            } else {\n                resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key}` : key;\n            }\n            return _this3.t(resultKey, options);\n        };\n        if (typeof lng === \"string\") {\n            fixedT.lng = lng;\n        } else {\n            fixedT.lngs = lng;\n        }\n        fixedT.ns = ns;\n        fixedT.keyPrefix = keyPrefix;\n        return fixedT;\n    }\n    t() {\n        return this.translator && this.translator.translate(...arguments);\n    }\n    exists() {\n        return this.translator && this.translator.exists(...arguments);\n    }\n    setDefaultNamespace(ns) {\n        this.options.defaultNS = ns;\n    }\n    hasLoadedNamespace(ns) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        if (!this.isInitialized) {\n            this.logger.warn(\"hasLoadedNamespace: i18next was not initialized\", this.languages);\n            return false;\n        }\n        if (!this.languages || !this.languages.length) {\n            this.logger.warn(\"hasLoadedNamespace: i18n.languages were undefined or empty\", this.languages);\n            return false;\n        }\n        const lng = options.lng || this.resolvedLanguage || this.languages[0];\n        const fallbackLng = this.options ? this.options.fallbackLng : false;\n        const lastLng = this.languages[this.languages.length - 1];\n        if (lng.toLowerCase() === \"cimode\") return true;\n        const loadNotPending = (l, n)=>{\n            const loadState = this.services.backendConnector.state[`${l}|${n}`];\n            return loadState === -1 || loadState === 2;\n        };\n        if (options.precheck) {\n            const preResult = options.precheck(this, loadNotPending);\n            if (preResult !== undefined) return preResult;\n        }\n        if (this.hasResourceBundle(lng, ns)) return true;\n        if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;\n        if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;\n        return false;\n    }\n    loadNamespaces(ns, callback) {\n        const deferred = defer();\n        if (!this.options.ns) {\n            if (callback) callback();\n            return Promise.resolve();\n        }\n        if (typeof ns === \"string\") ns = [\n            ns\n        ];\n        ns.forEach((n)=>{\n            if (this.options.ns.indexOf(n) < 0) this.options.ns.push(n);\n        });\n        this.loadResources((err)=>{\n            deferred.resolve();\n            if (callback) callback(err);\n        });\n        return deferred;\n    }\n    loadLanguages(lngs, callback) {\n        const deferred = defer();\n        if (typeof lngs === \"string\") lngs = [\n            lngs\n        ];\n        const preloaded = this.options.preload || [];\n        const newLngs = lngs.filter((lng)=>preloaded.indexOf(lng) < 0);\n        if (!newLngs.length) {\n            if (callback) callback();\n            return Promise.resolve();\n        }\n        this.options.preload = preloaded.concat(newLngs);\n        this.loadResources((err)=>{\n            deferred.resolve();\n            if (callback) callback(err);\n        });\n        return deferred;\n    }\n    dir(lng) {\n        if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);\n        if (!lng) return \"rtl\";\n        const rtlLngs = [\n            \"ar\",\n            \"shu\",\n            \"sqr\",\n            \"ssh\",\n            \"xaa\",\n            \"yhd\",\n            \"yud\",\n            \"aao\",\n            \"abh\",\n            \"abv\",\n            \"acm\",\n            \"acq\",\n            \"acw\",\n            \"acx\",\n            \"acy\",\n            \"adf\",\n            \"ads\",\n            \"aeb\",\n            \"aec\",\n            \"afb\",\n            \"ajp\",\n            \"apc\",\n            \"apd\",\n            \"arb\",\n            \"arq\",\n            \"ars\",\n            \"ary\",\n            \"arz\",\n            \"auz\",\n            \"avl\",\n            \"ayh\",\n            \"ayl\",\n            \"ayn\",\n            \"ayp\",\n            \"bbz\",\n            \"pga\",\n            \"he\",\n            \"iw\",\n            \"ps\",\n            \"pbt\",\n            \"pbu\",\n            \"pst\",\n            \"prp\",\n            \"prd\",\n            \"ug\",\n            \"ur\",\n            \"ydd\",\n            \"yds\",\n            \"yih\",\n            \"ji\",\n            \"yi\",\n            \"hbo\",\n            \"men\",\n            \"xmn\",\n            \"fa\",\n            \"jpr\",\n            \"peo\",\n            \"pes\",\n            \"prs\",\n            \"dv\",\n            \"sam\",\n            \"ckb\"\n        ];\n        const languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get());\n        return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf(\"-arab\") > 1 ? \"rtl\" : \"ltr\";\n    }\n    static createInstance() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 ? arguments[1] : undefined;\n        return new I18n(options, callback);\n    }\n    cloneInstance() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n        const forkResourceStore = options.forkResourceStore;\n        if (forkResourceStore) delete options.forkResourceStore;\n        const mergedOptions = {\n            ...this.options,\n            ...options,\n            ...{\n                isClone: true\n            }\n        };\n        const clone = new I18n(mergedOptions);\n        if (options.debug !== undefined || options.prefix !== undefined) {\n            clone.logger = clone.logger.clone(options);\n        }\n        const membersToCopy = [\n            \"store\",\n            \"services\",\n            \"language\"\n        ];\n        membersToCopy.forEach((m)=>{\n            clone[m] = this[m];\n        });\n        clone.services = {\n            ...this.services\n        };\n        clone.services.utils = {\n            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n        };\n        if (forkResourceStore) {\n            clone.store = new ResourceStore(this.store.data, mergedOptions);\n            clone.services.resourceStore = clone.store;\n        }\n        clone.translator = new Translator(clone.services, mergedOptions);\n        clone.translator.on(\"*\", function(event) {\n            for(var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++){\n                args[_key4 - 1] = arguments[_key4];\n            }\n            clone.emit(event, ...args);\n        });\n        clone.init(mergedOptions, callback);\n        clone.translator.options = mergedOptions;\n        clone.translator.backendConnector.services.utils = {\n            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n        };\n        return clone;\n    }\n    toJSON() {\n        return {\n            options: this.options,\n            store: this.store,\n            language: this.language,\n            languages: this.languages,\n            resolvedLanguage: this.resolvedLanguage\n        };\n    }\n}\nconst instance = I18n.createInstance();\ninstance.createInstance = I18n.createInstance;\nconst createInstance = instance.createInstance;\nconst dir = instance.dir;\nconst init = instance.init;\nconst loadResources = instance.loadResources;\nconst reloadResources = instance.reloadResources;\nconst use = instance.use;\nconst changeLanguage = instance.changeLanguage;\nconst getFixedT = instance.getFixedT;\nconst t = instance.t;\nconst exists = instance.exists;\nconst setDefaultNamespace = instance.setDefaultNamespace;\nconst hasLoadedNamespace = instance.hasLoadedNamespace;\nconst loadNamespaces = instance.loadNamespaces;\nconst loadLanguages = instance.loadLanguages;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vaTE4bmV4dEAyMy43LjE2L25vZGVfbW9kdWxlcy9pMThuZXh0L2Rpc3QvZXNtL2kxOG5leHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsTUFBTUEsZ0JBQWdCO0lBQ3BCQyxNQUFNO0lBQ05DLEtBQUlDLElBQUk7UUFDTixJQUFJLENBQUNDLE1BQU0sQ0FBQyxPQUFPRDtJQUNyQjtJQUNBRSxNQUFLRixJQUFJO1FBQ1AsSUFBSSxDQUFDQyxNQUFNLENBQUMsUUFBUUQ7SUFDdEI7SUFDQUcsT0FBTUgsSUFBSTtRQUNSLElBQUksQ0FBQ0MsTUFBTSxDQUFDLFNBQVNEO0lBQ3ZCO0lBQ0FDLFFBQU9ILElBQUksRUFBRUUsSUFBSTtRQUNmLElBQUlJLFdBQVdBLE9BQU8sQ0FBQ04sS0FBSyxFQUFFTSxPQUFPLENBQUNOLEtBQUssQ0FBQ08sS0FBSyxDQUFDRCxTQUFTSjtJQUM3RDtBQUNGO0FBQ0EsTUFBTU07SUFDSkMsWUFBWUMsY0FBYyxDQUFFO1FBQzFCLElBQUlDLFVBQVVDLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbkYsSUFBSSxDQUFDRyxJQUFJLENBQUNMLGdCQUFnQkM7SUFDNUI7SUFDQUksS0FBS0wsY0FBYyxFQUFFO1FBQ25CLElBQUlDLFVBQVVDLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbkYsSUFBSSxDQUFDSSxNQUFNLEdBQUdMLFFBQVFLLE1BQU0sSUFBSTtRQUNoQyxJQUFJLENBQUNDLE1BQU0sR0FBR1Asa0JBQWtCWDtRQUNoQyxJQUFJLENBQUNZLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNPLEtBQUssR0FBR1AsUUFBUU8sS0FBSztJQUM1QjtJQUNBakIsTUFBTTtRQUNKLElB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LE9BQU9xSyxPQUFPckssS0FBSyxJQUFJLElBQUlBLEtBQUssSUFBSSxJQUFJQSxJQUFJLElBQUksSUFBSUEsSUFBSSxLQUFLLElBQUk7SUFDbkU7SUFDQSxJQUFJLFNBQVVBLENBQUM7UUFDYixPQUFPcUssT0FBT3JLLEtBQUssS0FBS0EsS0FBSyxLQUFLLElBQUlBLEtBQUssS0FBS0EsS0FBSyxLQUFLLElBQUlBLElBQUksS0FBS0EsSUFBSSxLQUFLLElBQUk7SUFDdEY7SUFDQSxJQUFJLFNBQVVBLENBQUM7UUFDYixPQUFPcUssT0FBT3JLLElBQUksTUFBTSxLQUFLQSxJQUFJLE9BQU87SUFDMUM7SUFDQSxJQUFJLFNBQVVBLENBQUM7UUFDYixPQUFPcUssT0FBT3JLLE1BQU07SUFDdEI7SUFDQSxJQUFJLFNBQVVBLENBQUM7UUFDYixPQUFPcUssT0FBT3JLLEtBQUssSUFBSSxJQUFJQSxLQUFLLElBQUksSUFBSUEsS0FBSyxJQUFJLElBQUk7SUFDdkQ7SUFDQSxJQUFJLFNBQVVBLENBQUM7UUFDYixPQUFPcUssT0FBT3JLLElBQUksTUFBTSxLQUFLQSxJQUFJLE9BQU8sS0FBSyxJQUFJQSxJQUFJLE1BQU0sS0FBTUEsQ0FBQUEsSUFBSSxNQUFNLE1BQU1BLElBQUksT0FBTyxFQUFDLElBQUssSUFBSTtJQUN4RztJQUNBLElBQUksU0FBVUEsQ0FBQztRQUNiLE9BQU9xSyxPQUFPckssSUFBSSxNQUFNLEtBQUtBLElBQUksT0FBTyxLQUFLLElBQUlBLE1BQU0sSUFBSSxJQUFJO0lBQ2pFO0lBQ0EsSUFBSSxTQUFVQSxDQUFDO1FBQ2IsT0FBT3FLLE9BQU9ySyxLQUFLLEtBQUtBLElBQUksTUFBTSxLQUFLQSxJQUFJLE9BQU8sS0FBSyxJQUFJO0lBQzdEO0lBQ0EsSUFBSSxTQUFVQSxDQUFDO1FBQ2IsT0FBT3FLLE9BQU9ySyxLQUFLLElBQUksSUFBSUEsS0FBSyxJQUFJLElBQUk7SUFDMUM7SUFDQSxJQUFJLFNBQVVBLENBQUM7UUFDYixPQUFPcUssT0FBT3JLLEtBQUssSUFBSSxJQUFJQSxLQUFL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UixTQUFTN1Isa0JBQWtCO0FBQ3RELE1BQU1rUixpQkFBaUJXLFNBQVNYLGNBQWM7QUFDOUMsTUFBTUMsZ0JBQWdCVSxTQUFTVixhQUFhO0FBRWlLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9vbC5ndXJ1Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2kxOG5leHRAMjMuNy4xNi9ub2RlX21vZHVsZXMvaTE4bmV4dC9kaXN0L2VzbS9pMThuZXh0LmpzP2JmZTkiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29uc29sZUxvZ2dlciA9IHtcbiAgdHlwZTogJ2xvZ2dlcicsXG4gIGxvZyhhcmdzKSB7XG4gICAgdGhpcy5vdXRwdXQoJ2xvZycsIGFyZ3MpO1xuICB9LFxuICB3YXJuKGFyZ3MpIHtcbiAgICB0aGlzLm91dHB1dCgnd2FybicsIGFyZ3MpO1xuICB9LFxuICBlcnJvcihhcmdzKSB7XG4gICAgdGhpcy5vdXRwdXQoJ2Vycm9yJywgYXJncyk7XG4gIH0sXG4gIG91dHB1dCh0eXBlLCBhcmdzKSB7XG4gICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZVt0eXBlXSkgY29uc29sZVt0eXBlXS5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgfVxufTtcbmNsYXNzIExvZ2dlciB7XG4gIGNvbnN0cnVjdG9yKGNvbmNyZXRlTG9nZ2VyKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHRoaXMuaW5pdChjb25jcmV0ZUxvZ2dlciwgb3B0aW9ucyk7XG4gIH1cbiAgaW5pdChjb25jcmV0ZUxvZ2dlcikge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB0aGlzLnByZWZpeCA9IG9wdGlvbnMucHJlZml4IHx8ICdpMThuZXh0Oic7XG4gICAgdGhpcy5sb2dnZXIgPSBjb25jcmV0ZUxvZ2dlciB8fCBjb25zb2xlTG9nZ2VyO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5kZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gIH1cbiAgbG9nKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZm9yd2FyZChhcmdzLCAnbG9nJywgJycsIHRydWUpO1xuICB9XG4gIHdhcm4oKSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZvcndhcmQoYXJncywgJ3dhcm4nLCAnJywgdHJ1ZSk7XG4gIH1cbiAgZXJyb3IoKSB7XG4gICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZvcndhcmQoYXJncywgJ2Vycm9yJywgJycpO1xuICB9XG4gIGRlcHJlY2F0ZSgpIHtcbiAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgIGFyZ3NbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZm9yd2FyZChhcmdzLCAnd2FybicsICdXQVJOSU5HIERFUFJFQ0FURUQ6ICcsIHRydWUpO1xuICB9XG4gIGZvcndhcmQoYXJncywgbHZsLCBwcmVmaXgsIGRlYnVnT25seSkge1xuICAgIGlmIChkZWJ1Z09ubHkgJiYgIXRoaXMuZGVidWcpIHJldHVybiBudWxsO1xuICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycpIGFyZ3NbMF0gPSBgJHtwcmVmaXh9JHt0aGlzLnByZWZpeH0gJHthcmdzWzBdfWA7XG4gICAgcmV0dXJuIHRoaXMubG9nZ2VyW2x2bF0oYXJncyk7XG4gIH1cbiAgY3JlYXRlKG1vZHVsZU5hbWUpIHtcbiAgICByZXR1cm4gbmV3IExvZ2dlcih0aGlzLmxvZ2dlciwge1xuICAgICAgLi4ue1xuICAgICAgICBwcmVmaXg6IGAke3RoaXMucHJlZml4fToke21vZHVsZU5hbWV9OmBcbiAgICAgIH0sXG4gICAgICAuLi50aGlzLm9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICBjbG9uZShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgdGhpcy5vcHRpb25zO1xuICAgIG9wdGlvbnMucHJlZml4ID0gb3B0aW9ucy5wcmVmaXggfHwgdGhpcy5wcmVmaXg7XG4gICAgcmV0dXJuIG5ldyBMb2dnZXIodGhpcy5sb2dnZXIsIG9wdGlvbnMpO1xuICB9XG59XG52YXIgYmFzZUxvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxuY2xhc3MgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5vYnNlcnZlcnMgPSB7fTtcbiAgfVxuICBvbihldmVudHMsIGxpc3RlbmVyKSB7XG4gICAgZXZlbnRzLnNwbGl0KCcgJykuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICB0aGlzLm9ic2VydmVyc1tldmVudF0gPSB0aGlzLm9ic2VydmVyc1tldmVudF0gfHwgW107XG4gICAgICB0aGlzLm9ic2VydmVyc1tldmVudF0ucHVzaChsaXN0ZW5lcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmICghdGhpcy5vYnNlcnZlcnNbZXZlbnRdKSByZXR1cm47XG4gICAgaWYgKCFsaXN0ZW5lcikge1xuICAgICAgZGVsZXRlIHRoaXMub2JzZXJ2ZXJzW2V2ZW50XTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5vYnNlcnZlcnNbZXZlbnRdID0gdGhpcy5vYnNlcnZlcnNbZXZlbnRdLmZpbHRlcihsID0+IGwgIT09IGxpc3RlbmVyKTtcbiAgfVxuICBlbWl0KGV2ZW50KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGlmICh0aGlzLm9ic2VydmVyc1tldmVudF0pIHtcbiAgICAgIGNvbnN0IGNsb25lZCA9IFtdLmNvbmNhdCh0aGlzLm9ic2VydmVyc1tldmVudF0pO1xuICAgICAgY2xvbmVkLmZvckVhY2gob2JzZXJ2ZXIgPT4ge1xuICAgICAgICBvYnNlcnZlciguLi5hcmdzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5vYnNlcnZlcnNbJyonXSkge1xuICAgICAgY29uc3QgY2xvbmVkID0gW10uY29uY2F0KHRoaXMub2JzZXJ2ZXJzWycqJ10pO1xuICAgICAgY2xvbmVkLmZvckVhY2gob2JzZXJ2ZXIgPT4ge1xuICAgICAgICBvYnNlcnZlci5hcHBseShvYnNlcnZlciwgW2V2ZW50LCAuLi5hcmdzXSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmZXIoKSB7XG4gIGxldCByZXM7XG4gIGxldCByZWo7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmVzID0gcmVzb2x2ZTtcbiAgICByZWogPSByZWplY3Q7XG4gIH0pO1xuICBwcm9taXNlLnJlc29sdmUgPSByZXM7XG4gIHByb21pc2UucmVqZWN0ID0gcmVqO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIG1ha2VTdHJpbmcob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkgcmV0dXJuICcnO1xuICByZXR1cm4gJycgKyBvYmplY3Q7XG59XG5mdW5jdGlvbiBjb3B5KGEsIHMsIHQpIHtcbiAgYS5mb3JFYWNoKG0gPT4ge1xuICAgIGlmIChzW21dKSB0W21dID0gc1ttXTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRMYXN0T2ZQYXRoKG9iamVjdCwgcGF0aCwgRW1wdHkpIHtcbiAgZnVuY3Rpb24gY2xlYW5LZXkoa2V5KSB7XG4gICAgcmV0dXJuIGtleSAmJiBrZXkuaW5kZXhPZignIyMjJykgPiAtMSA/IGtleS5yZXBsYWNlKC8jIyMvZywgJy4nKSA6IGtleTtcbiAgfVxuICBmdW5jdGlvbiBjYW5Ob3RUcmF2ZXJzZURlZXBlcigpIHtcbiAgICByZXR1cm4gIW9iamVjdCB8fCB0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJztcbiAgfVxuICBjb25zdCBzdGFjayA9IHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJyA/IFtdLmNvbmNhdChwYXRoKSA6IHBhdGguc3BsaXQoJy4nKTtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoY2FuTm90VHJhdmVyc2VEZWVwZXIoKSkgcmV0dXJuIHt9O1xuICAgIGNvbnN0IGtleSA9IGNsZWFuS2V5KHN0YWNrLnNoaWZ0KCkpO1xuICAgIGlmICghb2JqZWN0W2tleV0gJiYgRW1wdHkpIG9iamVjdFtrZXldID0gbmV3IEVtcHR5KCk7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3QgPSB7fTtcbiAgICB9XG4gIH1cbiAgaWYgKGNhbk5vdFRyYXZlcnNlRGVlcGVyKCkpIHJldHVybiB7fTtcbiAgcmV0dXJuIHtcbiAgICBvYmo6IG9iamVjdCxcbiAgICBrOiBjbGVhbktleShzdGFjay5zaGlmdCgpKVxuICB9O1xufVxuZnVuY3Rpb24gc2V0UGF0aChvYmplY3QsIHBhdGgsIG5ld1ZhbHVlKSB7XG4gIGNvbnN0IHtcbiAgICBvYmosXG4gICAga1xuICB9ID0gZ2V0TGFzdE9mUGF0aChvYmplY3QsIHBhdGgsIE9iamVjdCk7XG4gIG9ialtrXSA9IG5ld1ZhbHVlO1xufVxuZnVuY3Rpb24gcHVzaFBhdGgob2JqZWN0LCBwYXRoLCBuZXdWYWx1ZSwgY29uY2F0KSB7XG4gIGNvbnN0IHtcbiAgICBvYmosXG4gICAga1xuICB9ID0gZ2V0TGFzdE9mUGF0aChvYmplY3QsIHBhdGgsIE9iamVjdCk7XG4gIG9ialtrXSA9IG9ialtrXSB8fCBbXTtcbiAgaWYgKGNvbmNhdCkgb2JqW2tdID0gb2JqW2tdLmNvbmNhdChuZXdWYWx1ZSk7XG4gIGlmICghY29uY2F0KSBvYmpba10ucHVzaChuZXdWYWx1ZSk7XG59XG5mdW5jdGlvbiBnZXRQYXRoKG9iamVjdCwgcGF0aCkge1xuICBjb25zdCB7XG4gICAgb2JqLFxuICAgIGtcbiAgfSA9IGdldExhc3RPZlBhdGgob2JqZWN0LCBwYXRoKTtcbiAgaWYgKCFvYmopIHJldHVybiB1bmRlZmluZWQ7XG4gIHJldHVybiBvYmpba107XG59XG5mdW5jdGlvbiBnZXRQYXRoV2l0aERlZmF1bHRzKGRhdGEsIGRlZmF1bHREYXRhLCBrZXkpIHtcbiAgY29uc3QgdmFsdWUgPSBnZXRQYXRoKGRhdGEsIGtleSk7XG4gIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBnZXRQYXRoKGRlZmF1bHREYXRhLCBrZXkpO1xufVxuZnVuY3Rpb24gZGVlcEV4dGVuZCh0YXJnZXQsIHNvdXJjZSwgb3ZlcndyaXRlKSB7XG4gIGZvciAoY29uc3QgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICBpZiAocHJvcCAhPT0gJ19fcHJvdG9fXycgJiYgcHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgaWYgKHByb3AgaW4gdGFyZ2V0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0W3Byb3BdID09PSAnc3RyaW5nJyB8fCB0YXJnZXRbcHJvcF0gaW5zdGFuY2VvZiBTdHJpbmcgfHwgdHlwZW9mIHNvdXJjZVtwcm9wXSA9PT0gJ3N0cmluZycgfHwgc291cmNlW3Byb3BdIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgICAgaWYgKG92ZXJ3cml0ZSkgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlZXBFeHRlbmQodGFyZ2V0W3Byb3BdLCBzb3VyY2VbcHJvcF0sIG92ZXJ3cml0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHJlZ2V4RXNjYXBlKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXC1cXFtcXF1cXC9cXHtcXH1cXChcXClcXCpcXCtcXD9cXC5cXFxcXFxeXFwkXFx8XS9nLCAnXFxcXCQmJyk7XG59XG52YXIgX2VudGl0eU1hcCA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICBcIidcIjogJyYjMzk7JyxcbiAgJy8nOiAnJiN4MkY7J1xufTtcbmZ1bmN0aW9uIGVzY2FwZShkYXRhKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGF0YS5yZXBsYWNlKC9bJjw+XCInXFwvXS9nLCBzID0+IF9lbnRpdHlNYXBbc10pO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuY29uc3QgY2hhcnMgPSBbJyAnLCAnLCcsICc/JywgJyEnLCAnOyddO1xuZnVuY3Rpb24gbG9va3NMaWtlT2JqZWN0UGF0aChrZXksIG5zU2VwYXJhdG9yLCBrZXlTZXBhcmF0b3IpIHtcbiAgbnNTZXBhcmF0b3IgPSBuc1NlcGFyYXRvciB8fCAnJztcbiAga2V5U2VwYXJhdG9yID0ga2V5U2VwYXJhdG9yIHx8ICcnO1xuICBjb25zdCBwb3NzaWJsZUNoYXJzID0gY2hhcnMuZmlsdGVyKGMgPT4gbnNTZXBhcmF0b3IuaW5kZXhPZihjKSA8IDAgJiYga2V5U2VwYXJhdG9yLmluZGV4T2YoYykgPCAwKTtcbiAgaWYgKHBvc3NpYmxlQ2hhcnMubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgY29uc3QgciA9IG5ldyBSZWdFeHAoYCgke3Bvc3NpYmxlQ2hhcnMubWFwKGMgPT4gYyA9PT0gJz8nID8gJ1xcXFw/JyA6IGMpLmpvaW4oJ3wnKX0pYCk7XG4gIGxldCBtYXRjaGVkID0gIXIudGVzdChrZXkpO1xuICBpZiAoIW1hdGNoZWQpIHtcbiAgICBjb25zdCBraSA9IGtleS5pbmRleE9mKGtleVNlcGFyYXRvcik7XG4gICAgaWYgKGtpID4gMCAmJiAhci50ZXN0KGtleS5zdWJzdHJpbmcoMCwga2kpKSkge1xuICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXRjaGVkO1xufVxuZnVuY3Rpb24gZGVlcEZpbmQob2JqLCBwYXRoKSB7XG4gIGxldCBrZXlTZXBhcmF0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICcuJztcbiAgaWYgKCFvYmopIHJldHVybiB1bmRlZmluZWQ7XG4gIGlmIChvYmpbcGF0aF0pIHJldHVybiBvYmpbcGF0aF07XG4gIGNvbnN0IHBhdGhzID0gcGF0aC5zcGxpdChrZXlTZXBhcmF0b3IpO1xuICBsZXQgY3VycmVudCA9IG9iajtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7ICsraSkge1xuICAgIGlmICghY3VycmVudCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIGN1cnJlbnRbcGF0aHNbaV1dID09PSAnc3RyaW5nJyAmJiBpICsgMSA8IHBhdGhzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRbcGF0aHNbaV1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCBqID0gMjtcbiAgICAgIGxldCBwID0gcGF0aHMuc2xpY2UoaSwgaSArIGopLmpvaW4oa2V5U2VwYXJhdG9yKTtcbiAgICAgIGxldCBtaXggPSBjdXJyZW50W3BdO1xuICAgICAgd2hpbGUgKG1peCA9PT0gdW5kZWZpbmVkICYmIHBhdGhzLmxlbmd0aCA+IGkgKyBqKSB7XG4gICAgICAgIGorKztcbiAgICAgICAgcCA9IHBhdGhzLnNsaWNlKGksIGkgKyBqKS5qb2luKGtleVNlcGFyYXRvcik7XG4gICAgICAgIG1peCA9IGN1cnJlbnRbcF07XG4gICAgICB9XG4gICAgICBpZiAobWl4ID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICBpZiAobWl4ID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChwYXRoLmVuZHNXaXRoKHApKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWl4ID09PSAnc3RyaW5nJykgcmV0dXJuIG1peDtcbiAgICAgICAgaWYgKHAgJiYgdHlwZW9mIG1peFtwXSA9PT0gJ3N0cmluZycpIHJldHVybiBtaXhbcF07XG4gICAgICB9XG4gICAgICBjb25zdCBqb2luZWRQYXRoID0gcGF0aHMuc2xpY2UoaSArIGopLmpvaW4oa2V5U2VwYXJhdG9yKTtcbiAgICAgIGlmIChqb2luZWRQYXRoKSByZXR1cm4gZGVlcEZpbmQobWl4LCBqb2luZWRQYXRoLCBrZXlTZXBhcmF0b3IpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY3VycmVudCA9IGN1cnJlbnRbcGF0aHNbaV1dO1xuICB9XG4gIHJldHVybiBjdXJyZW50O1xufVxuZnVuY3Rpb24gZ2V0Q2xlYW5lZENvZGUoY29kZSkge1xuICBpZiAoY29kZSAmJiBjb2RlLmluZGV4T2YoJ18nKSA+IDApIHJldHVybiBjb2RlLnJlcGxhY2UoJ18nLCAnLScpO1xuICByZXR1cm4gY29kZTtcbn1cblxuY2xhc3MgUmVzb3VyY2VTdG9yZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge1xuICAgICAgbnM6IFsndHJhbnNsYXRpb24nXSxcbiAgICAgIGRlZmF1bHROUzogJ3RyYW5zbGF0aW9uJ1xuICAgIH07XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5vcHRpb25zLmtleVNlcGFyYXRvciA9ICcuJztcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pZ25vcmVKU09OU3RydWN0dXJlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5pZ25vcmVKU09OU3RydWN0dXJlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgYWRkTmFtZXNwYWNlcyhucykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubnMuaW5kZXhPZihucykgPCAwKSB7XG4gICAgICB0aGlzLm9wdGlvbnMubnMucHVzaChucyk7XG4gICAgfVxuICB9XG4gIHJlbW92ZU5hbWVzcGFjZXMobnMpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMub3B0aW9ucy5ucy5pbmRleE9mKG5zKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5vcHRpb25zLm5zLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG4gIGdldFJlc291cmNlKGxuZywgbnMsIGtleSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICBjb25zdCBrZXlTZXBhcmF0b3IgPSBvcHRpb25zLmtleVNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5rZXlTZXBhcmF0b3IgOiB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yO1xuICAgIGNvbnN0IGlnbm9yZUpTT05TdHJ1Y3R1cmUgPSBvcHRpb25zLmlnbm9yZUpTT05TdHJ1Y3R1cmUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaWdub3JlSlNPTlN0cnVjdHVyZSA6IHRoaXMub3B0aW9ucy5pZ25vcmVKU09OU3RydWN0dXJlO1xuICAgIGxldCBwYXRoID0gW2xuZywgbnNdO1xuICAgIGlmIChrZXkgJiYgdHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoLmNvbmNhdChrZXkpO1xuICAgIGlmIChrZXkgJiYgdHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHBhdGggPSBwYXRoLmNvbmNhdChrZXlTZXBhcmF0b3IgPyBrZXkuc3BsaXQoa2V5U2VwYXJhdG9yKSA6IGtleSk7XG4gICAgaWYgKGxuZy5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgICAgcGF0aCA9IGxuZy5zcGxpdCgnLicpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBnZXRQYXRoKHRoaXMuZGF0YSwgcGF0aCk7XG4gICAgaWYgKHJlc3VsdCB8fCAhaWdub3JlSlNPTlN0cnVjdHVyZSB8fCB0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykgcmV0dXJuIHJlc3VsdDtcbiAgICByZXR1cm4gZGVlcEZpbmQodGhpcy5kYXRhICYmIHRoaXMuZGF0YVtsbmddICYmIHRoaXMuZGF0YVtsbmddW25zXSwga2V5LCBrZXlTZXBhcmF0b3IpO1xuICB9XG4gIGFkZFJlc291cmNlKGxuZywgbnMsIGtleSwgdmFsdWUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDoge1xuICAgICAgc2lsZW50OiBmYWxzZVxuICAgIH07XG4gICAgY29uc3Qga2V5U2VwYXJhdG9yID0gb3B0aW9ucy5rZXlTZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMua2V5U2VwYXJhdG9yIDogdGhpcy5vcHRpb25zLmtleVNlcGFyYXRvcjtcbiAgICBsZXQgcGF0aCA9IFtsbmcsIG5zXTtcbiAgICBpZiAoa2V5KSBwYXRoID0gcGF0aC5jb25jYXQoa2V5U2VwYXJhdG9yID8ga2V5LnNwbGl0KGtleVNlcGFyYXRvcikgOiBrZXkpO1xuICAgIGlmIChsbmcuaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgIHBhdGggPSBsbmcuc3BsaXQoJy4nKTtcbiAgICAgIHZhbHVlID0gbnM7XG4gICAgICBucyA9IHBhdGhbMV07XG4gICAgfVxuICAgIHRoaXMuYWRkTmFtZXNwYWNlcyhucyk7XG4gICAgc2V0UGF0aCh0aGlzLmRhdGEsIHBhdGgsIHZhbHVlKTtcbiAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB0aGlzLmVtaXQoJ2FkZGVkJywgbG5nLCBucywga2V5LCB2YWx1ZSk7XG4gIH1cbiAgYWRkUmVzb3VyY2VzKGxuZywgbnMsIHJlc291cmNlcykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7XG4gICAgICBzaWxlbnQ6IGZhbHNlXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IG0gaW4gcmVzb3VyY2VzKSB7XG4gICAgICBpZiAodHlwZW9mIHJlc291cmNlc1ttXSA9PT0gJ3N0cmluZycgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShyZXNvdXJjZXNbbV0pID09PSAnW29iamVjdCBBcnJheV0nKSB0aGlzLmFkZFJlc291cmNlKGxuZywgbnMsIG0sIHJlc291cmNlc1ttXSwge1xuICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB0aGlzLmVtaXQoJ2FkZGVkJywgbG5nLCBucywgcmVzb3VyY2VzKTtcbiAgfVxuICBhZGRSZXNvdXJjZUJ1bmRsZShsbmcsIG5zLCByZXNvdXJjZXMsIGRlZXAsIG92ZXJ3cml0ZSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB7XG4gICAgICBzaWxlbnQ6IGZhbHNlXG4gICAgfTtcbiAgICBsZXQgcGF0aCA9IFtsbmcsIG5zXTtcbiAgICBpZiAobG5nLmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgICBwYXRoID0gbG5nLnNwbGl0KCcuJyk7XG4gICAgICBkZWVwID0gcmVzb3VyY2VzO1xuICAgICAgcmVzb3VyY2VzID0gbnM7XG4gICAgICBucyA9IHBhdGhbMV07XG4gICAgfVxuICAgIHRoaXMuYWRkTmFtZXNwYWNlcyhucyk7XG4gICAgbGV0IHBhY2sgPSBnZXRQYXRoKHRoaXMuZGF0YSwgcGF0aCkgfHwge307XG4gICAgaWYgKGRlZXApIHtcbiAgICAgIGRlZXBFeHRlbmQocGFjaywgcmVzb3VyY2VzLCBvdmVyd3JpdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNrID0ge1xuICAgICAgICAuLi5wYWNrLFxuICAgICAgICAuLi5yZXNvdXJjZXNcbiAgICAgIH07XG4gICAgfVxuICAgIHNldFBhdGgodGhpcy5kYXRhLCBwYXRoLCBwYWNrKTtcbiAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB0aGlzLmVtaXQoJ2FkZGVkJywgbG5nLCBucywgcmVzb3VyY2VzKTtcbiAgfVxuICByZW1vdmVSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSB7XG4gICAgaWYgKHRoaXMuaGFzUmVzb3VyY2VCdW5kbGUobG5nLCBucykpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmRhdGFbbG5nXVtuc107XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlTmFtZXNwYWNlcyhucyk7XG4gICAgdGhpcy5lbWl0KCdyZW1vdmVkJywgbG5nLCBucyk7XG4gIH1cbiAgaGFzUmVzb3VyY2VCdW5kbGUobG5nLCBucykge1xuICAgIHJldHVybiB0aGlzLmdldFJlc291cmNlKGxuZywgbnMpICE9PSB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0UmVzb3VyY2VCdW5kbGUobG5nLCBucykge1xuICAgIGlmICghbnMpIG5zID0gdGhpcy5vcHRpb25zLmRlZmF1bHROUztcbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbXBhdGliaWxpdHlBUEkgPT09ICd2MScpIHJldHVybiB7XG4gICAgICAuLi57fSxcbiAgICAgIC4uLnRoaXMuZ2V0UmVzb3VyY2UobG5nLCBucylcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmdldFJlc291cmNlKGxuZywgbnMpO1xuICB9XG4gIGdldERhdGFCeUxhbmd1YWdlKGxuZykge1xuICAgIHJldHVybiB0aGlzLmRhdGFbbG5nXTtcbiAgfVxuICBoYXNMYW5ndWFnZVNvbWVUcmFuc2xhdGlvbnMobG5nKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YUJ5TGFuZ3VhZ2UobG5nKTtcbiAgICBjb25zdCBuID0gZGF0YSAmJiBPYmplY3Qua2V5cyhkYXRhKSB8fCBbXTtcbiAgICByZXR1cm4gISFuLmZpbmQodiA9PiBkYXRhW3ZdICYmIE9iamVjdC5rZXlzKGRhdGFbdl0pLmxlbmd0aCA+IDApO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhO1xuICB9XG59XG5cbnZhciBwb3N0UHJvY2Vzc29yID0ge1xuICBwcm9jZXNzb3JzOiB7fSxcbiAgYWRkUG9zdFByb2Nlc3Nvcihtb2R1bGUpIHtcbiAgICB0aGlzLnByb2Nlc3NvcnNbbW9kdWxlLm5hbWVdID0gbW9kdWxlO1xuICB9LFxuICBoYW5kbGUocHJvY2Vzc29ycywgdmFsdWUsIGtleSwgb3B0aW9ucywgdHJhbnNsYXRvcikge1xuICAgIHByb2Nlc3NvcnMuZm9yRWFjaChwcm9jZXNzb3IgPT4ge1xuICAgICAgaWYgKHRoaXMucHJvY2Vzc29yc1twcm9jZXNzb3JdKSB2YWx1ZSA9IHRoaXMucHJvY2Vzc29yc1twcm9jZXNzb3JdLnByb2Nlc3ModmFsdWUsIGtleSwgb3B0aW9ucywgdHJhbnNsYXRvcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59O1xuXG5jb25zdCBjaGVja2VkTG9hZGVkRm9yID0ge307XG5jbGFzcyBUcmFuc2xhdG9yIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3Ioc2VydmljZXMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgc3VwZXIoKTtcbiAgICBjb3B5KFsncmVzb3VyY2VTdG9yZScsICdsYW5ndWFnZVV0aWxzJywgJ3BsdXJhbFJlc29sdmVyJywgJ2ludGVycG9sYXRvcicsICdiYWNrZW5kQ29ubmVjdG9yJywgJ2kxOG5Gb3JtYXQnLCAndXRpbHMnXSwgc2VydmljZXMsIHRoaXMpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5vcHRpb25zLmtleVNlcGFyYXRvciA9ICcuJztcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyLmNyZWF0ZSgndHJhbnNsYXRvcicpO1xuICB9XG4gIGNoYW5nZUxhbmd1YWdlKGxuZykge1xuICAgIGlmIChsbmcpIHRoaXMubGFuZ3VhZ2UgPSBsbmc7XG4gIH1cbiAgZXhpc3RzKGtleSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgICBpbnRlcnBvbGF0aW9uOiB7fVxuICAgIH07XG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkIHx8IGtleSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZCA9IHRoaXMucmVzb2x2ZShrZXksIG9wdGlvbnMpO1xuICAgIHJldHVybiByZXNvbHZlZCAmJiByZXNvbHZlZC5yZXMgIT09IHVuZGVmaW5lZDtcbiAgfVxuICBleHRyYWN0RnJvbUtleShrZXksIG9wdGlvbnMpIHtcbiAgICBsZXQgbnNTZXBhcmF0b3IgPSBvcHRpb25zLm5zU2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zU2VwYXJhdG9yIDogdGhpcy5vcHRpb25zLm5zU2VwYXJhdG9yO1xuICAgIGlmIChuc1NlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSBuc1NlcGFyYXRvciA9ICc6JztcbiAgICBjb25zdCBrZXlTZXBhcmF0b3IgPSBvcHRpb25zLmtleVNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5rZXlTZXBhcmF0b3IgOiB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yO1xuICAgIGxldCBuYW1lc3BhY2VzID0gb3B0aW9ucy5ucyB8fCB0aGlzLm9wdGlvbnMuZGVmYXVsdE5TIHx8IFtdO1xuICAgIGNvbnN0IHdvdWxkQ2hlY2tGb3JOc0luS2V5ID0gbnNTZXBhcmF0b3IgJiYga2V5LmluZGV4T2YobnNTZXBhcmF0b3IpID4gLTE7XG4gICAgY29uc3Qgc2VlbXNOYXR1cmFsTGFuZ3VhZ2UgPSAhdGhpcy5vcHRpb25zLnVzZXJEZWZpbmVkS2V5U2VwYXJhdG9yICYmICFvcHRpb25zLmtleVNlcGFyYXRvciAmJiAhdGhpcy5vcHRpb25zLnVzZXJEZWZpbmVkTnNTZXBhcmF0b3IgJiYgIW9wdGlvbnMubnNTZXBhcmF0b3IgJiYgIWxvb2tzTGlrZU9iamVjdFBhdGgoa2V5LCBuc1NlcGFyYXRvciwga2V5U2VwYXJhdG9yKTtcbiAgICBpZiAod291bGRDaGVja0Zvck5zSW5LZXkgJiYgIXNlZW1zTmF0dXJhbExhbmd1YWdlKSB7XG4gICAgICBjb25zdCBtID0ga2V5Lm1hdGNoKHRoaXMuaW50ZXJwb2xhdG9yLm5lc3RpbmdSZWdleHApO1xuICAgICAgaWYgKG0gJiYgbS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAga2V5LFxuICAgICAgICAgIG5hbWVzcGFjZXNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcnRzID0ga2V5LnNwbGl0KG5zU2VwYXJhdG9yKTtcbiAgICAgIGlmIChuc1NlcGFyYXRvciAhPT0ga2V5U2VwYXJhdG9yIHx8IG5zU2VwYXJhdG9yID09PSBrZXlTZXBhcmF0b3IgJiYgdGhpcy5vcHRpb25zLm5zLmluZGV4T2YocGFydHNbMF0pID4gLTEpIG5hbWVzcGFjZXMgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAga2V5ID0gcGFydHMuam9pbihrZXlTZXBhcmF0b3IpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnKSBuYW1lc3BhY2VzID0gW25hbWVzcGFjZXNdO1xuICAgIHJldHVybiB7XG4gICAgICBrZXksXG4gICAgICBuYW1lc3BhY2VzXG4gICAgfTtcbiAgfVxuICB0cmFuc2xhdGUoa2V5cywgb3B0aW9ucywgbGFzdEtleSkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgJiYgdGhpcy5vcHRpb25zLm92ZXJsb2FkVHJhbnNsYXRpb25PcHRpb25IYW5kbGVyKSB7XG4gICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLm92ZXJsb2FkVHJhbnNsYXRpb25PcHRpb25IYW5kbGVyKGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIG9wdGlvbnMgPSB7XG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICBpZiAoa2V5cyA9PT0gdW5kZWZpbmVkIHx8IGtleXMgPT09IG51bGwpIHJldHVybiAnJztcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5cykpIGtleXMgPSBbU3RyaW5nKGtleXMpXTtcbiAgICBjb25zdCByZXR1cm5EZXRhaWxzID0gb3B0aW9ucy5yZXR1cm5EZXRhaWxzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJldHVybkRldGFpbHMgOiB0aGlzLm9wdGlvbnMucmV0dXJuRGV0YWlscztcbiAgICBjb25zdCBrZXlTZXBhcmF0b3IgPSBvcHRpb25zLmtleVNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5rZXlTZXBhcmF0b3IgOiB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yO1xuICAgIGNvbnN0IHtcbiAgICAgIGtleSxcbiAgICAgIG5hbWVzcGFjZXNcbiAgICB9ID0gdGhpcy5leHRyYWN0RnJvbUtleShrZXlzW2tleXMubGVuZ3RoIC0gMV0sIG9wdGlvbnMpO1xuICAgIGNvbnN0IG5hbWVzcGFjZSA9IG5hbWVzcGFjZXNbbmFtZXNwYWNlcy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBsbmcgPSBvcHRpb25zLmxuZyB8fCB0aGlzLmxhbmd1YWdlO1xuICAgIGNvbnN0IGFwcGVuZE5hbWVzcGFjZVRvQ0lNb2RlID0gb3B0aW9ucy5hcHBlbmROYW1lc3BhY2VUb0NJTW9kZSB8fCB0aGlzLm9wdGlvbnMuYXBwZW5kTmFtZXNwYWNlVG9DSU1vZGU7XG4gICAgaWYgKGxuZyAmJiBsbmcudG9Mb3dlckNhc2UoKSA9PT0gJ2NpbW9kZScpIHtcbiAgICAgIGlmIChhcHBlbmROYW1lc3BhY2VUb0NJTW9kZSkge1xuICAgICAgICBjb25zdCBuc1NlcGFyYXRvciA9IG9wdGlvbnMubnNTZXBhcmF0b3IgfHwgdGhpcy5vcHRpb25zLm5zU2VwYXJhdG9yO1xuICAgICAgICBpZiAocmV0dXJuRGV0YWlscykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXM6IGAke25hbWVzcGFjZX0ke25zU2VwYXJhdG9yfSR7a2V5fWAsXG4gICAgICAgICAgICB1c2VkS2V5OiBrZXksXG4gICAgICAgICAgICBleGFjdFVzZWRLZXk6IGtleSxcbiAgICAgICAgICAgIHVzZWRMbmc6IGxuZyxcbiAgICAgICAgICAgIHVzZWROUzogbmFtZXNwYWNlLFxuICAgICAgICAgICAgdXNlZFBhcmFtczogdGhpcy5nZXRVc2VkUGFyYW1zRGV0YWlscyhvcHRpb25zKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke25hbWVzcGFjZX0ke25zU2VwYXJhdG9yfSR7a2V5fWA7XG4gICAgICB9XG4gICAgICBpZiAocmV0dXJuRGV0YWlscykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlczoga2V5LFxuICAgICAgICAgIHVzZWRLZXk6IGtleSxcbiAgICAgICAgICBleGFjdFVzZWRLZXk6IGtleSxcbiAgICAgICAgICB1c2VkTG5nOiBsbmcsXG4gICAgICAgICAgdXNlZE5TOiBuYW1lc3BhY2UsXG4gICAgICAgICAgdXNlZFBhcmFtczogdGhpcy5nZXRVc2VkUGFyYW1zRGV0YWlscyhvcHRpb25zKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWQgPSB0aGlzLnJlc29sdmUoa2V5cywgb3B0aW9ucyk7XG4gICAgbGV0IHJlcyA9IHJlc29sdmVkICYmIHJlc29sdmVkLnJlcztcbiAgICBjb25zdCByZXNVc2VkS2V5ID0gcmVzb2x2ZWQgJiYgcmVzb2x2ZWQudXNlZEtleSB8fCBrZXk7XG4gICAgY29uc3QgcmVzRXhhY3RVc2VkS2V5ID0gcmVzb2x2ZWQgJiYgcmVzb2x2ZWQuZXhhY3RVc2VkS2V5IHx8IGtleTtcbiAgICBjb25zdCByZXNUeXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShyZXMpO1xuICAgIGNvbnN0IG5vT2JqZWN0ID0gWydbb2JqZWN0IE51bWJlcl0nLCAnW29iamVjdCBGdW5jdGlvbl0nLCAnW29iamVjdCBSZWdFeHBdJ107XG4gICAgY29uc3Qgam9pbkFycmF5cyA9IG9wdGlvbnMuam9pbkFycmF5cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5qb2luQXJyYXlzIDogdGhpcy5vcHRpb25zLmpvaW5BcnJheXM7XG4gICAgY29uc3QgaGFuZGxlQXNPYmplY3RJbkkxOG5Gb3JtYXQgPSAhdGhpcy5pMThuRm9ybWF0IHx8IHRoaXMuaTE4bkZvcm1hdC5oYW5kbGVBc09iamVjdDtcbiAgICBjb25zdCBoYW5kbGVBc09iamVjdCA9IHR5cGVvZiByZXMgIT09ICdzdHJpbmcnICYmIHR5cGVvZiByZXMgIT09ICdib29sZWFuJyAmJiB0eXBlb2YgcmVzICE9PSAnbnVtYmVyJztcbiAgICBpZiAoaGFuZGxlQXNPYmplY3RJbkkxOG5Gb3JtYXQgJiYgcmVzICYmIGhhbmRsZUFzT2JqZWN0ICYmIG5vT2JqZWN0LmluZGV4T2YocmVzVHlwZSkgPCAwICYmICEodHlwZW9mIGpvaW5BcnJheXMgPT09ICdzdHJpbmcnICYmIHJlc1R5cGUgPT09ICdbb2JqZWN0IEFycmF5XScpKSB7XG4gICAgICBpZiAoIW9wdGlvbnMucmV0dXJuT2JqZWN0cyAmJiAhdGhpcy5vcHRpb25zLnJldHVybk9iamVjdHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucmV0dXJuZWRPYmplY3RIYW5kbGVyKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybignYWNjZXNzaW5nIGFuIG9iamVjdCAtIGJ1dCByZXR1cm5PYmplY3RzIG9wdGlvbnMgaXMgbm90IGVuYWJsZWQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgciA9IHRoaXMub3B0aW9ucy5yZXR1cm5lZE9iamVjdEhhbmRsZXIgPyB0aGlzLm9wdGlvbnMucmV0dXJuZWRPYmplY3RIYW5kbGVyKHJlc1VzZWRLZXksIHJlcywge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgbnM6IG5hbWVzcGFjZXNcbiAgICAgICAgfSkgOiBga2V5ICcke2tleX0gKCR7dGhpcy5sYW5ndWFnZX0pJyByZXR1cm5lZCBhbiBvYmplY3QgaW5zdGVhZCBvZiBzdHJpbmcuYDtcbiAgICAgICAgaWYgKHJldHVybkRldGFpbHMpIHtcbiAgICAgICAgICByZXNvbHZlZC5yZXMgPSByO1xuICAgICAgICAgIHJlc29sdmVkLnVzZWRQYXJhbXMgPSB0aGlzLmdldFVzZWRQYXJhbXNEZXRhaWxzKG9wdGlvbnMpO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cbiAgICAgIGlmIChrZXlTZXBhcmF0b3IpIHtcbiAgICAgICAgY29uc3QgcmVzVHlwZUlzQXJyYXkgPSByZXNUeXBlID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgICAgICBjb25zdCBjb3B5ID0gcmVzVHlwZUlzQXJyYXkgPyBbXSA6IHt9O1xuICAgICAgICBjb25zdCBuZXdLZXlUb1VzZSA9IHJlc1R5cGVJc0FycmF5ID8gcmVzRXhhY3RVc2VkS2V5IDogcmVzVXNlZEtleTtcbiAgICAgICAgZm9yIChjb25zdCBtIGluIHJlcykge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzLCBtKSkge1xuICAgICAgICAgICAgY29uc3QgZGVlcEtleSA9IGAke25ld0tleVRvVXNlfSR7a2V5U2VwYXJhdG9yfSR7bX1gO1xuICAgICAgICAgICAgY29weVttXSA9IHRoaXMudHJhbnNsYXRlKGRlZXBLZXksIHtcbiAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgLi4ue1xuICAgICAgICAgICAgICAgIGpvaW5BcnJheXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG5zOiBuYW1lc3BhY2VzXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNvcHlbbV0gPT09IGRlZXBLZXkpIGNvcHlbbV0gPSByZXNbbV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcyA9IGNvcHk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoYW5kbGVBc09iamVjdEluSTE4bkZvcm1hdCAmJiB0eXBlb2Ygam9pbkFycmF5cyA9PT0gJ3N0cmluZycgJiYgcmVzVHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgcmVzID0gcmVzLmpvaW4oam9pbkFycmF5cyk7XG4gICAgICBpZiAocmVzKSByZXMgPSB0aGlzLmV4dGVuZFRyYW5zbGF0aW9uKHJlcywga2V5cywgb3B0aW9ucywgbGFzdEtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB1c2VkRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgbGV0IHVzZWRLZXkgPSBmYWxzZTtcbiAgICAgIGNvbnN0IG5lZWRzUGx1cmFsSGFuZGxpbmcgPSBvcHRpb25zLmNvdW50ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdGlvbnMuY291bnQgIT09ICdzdHJpbmcnO1xuICAgICAgY29uc3QgaGFzRGVmYXVsdFZhbHVlID0gVHJhbnNsYXRvci5oYXNEZWZhdWx0VmFsdWUob3B0aW9ucyk7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWVTdWZmaXggPSBuZWVkc1BsdXJhbEhhbmRsaW5nID8gdGhpcy5wbHVyYWxSZXNvbHZlci5nZXRTdWZmaXgobG5nLCBvcHRpb25zLmNvdW50LCBvcHRpb25zKSA6ICcnO1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlU3VmZml4T3JkaW5hbEZhbGxiYWNrID0gb3B0aW9ucy5vcmRpbmFsICYmIG5lZWRzUGx1cmFsSGFuZGxpbmcgPyB0aGlzLnBsdXJhbFJlc29sdmVyLmdldFN1ZmZpeChsbmcsIG9wdGlvbnMuY291bnQsIHtcbiAgICAgICAgb3JkaW5hbDogZmFsc2VcbiAgICAgIH0pIDogJyc7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBvcHRpb25zW2BkZWZhdWx0VmFsdWUke2RlZmF1bHRWYWx1ZVN1ZmZpeH1gXSB8fCBvcHRpb25zW2BkZWZhdWx0VmFsdWUke2RlZmF1bHRWYWx1ZVN1ZmZpeE9yZGluYWxGYWxsYmFja31gXSB8fCBvcHRpb25zLmRlZmF1bHRWYWx1ZTtcbiAgICAgIGlmICghdGhpcy5pc1ZhbGlkTG9va3VwKHJlcykgJiYgaGFzRGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHVzZWREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgcmVzID0gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmlzVmFsaWRMb29rdXAocmVzKSkge1xuICAgICAgICB1c2VkS2V5ID0gdHJ1ZTtcbiAgICAgICAgcmVzID0ga2V5O1xuICAgICAgfVxuICAgICAgY29uc3QgbWlzc2luZ0tleU5vVmFsdWVGYWxsYmFja1RvS2V5ID0gb3B0aW9ucy5taXNzaW5nS2V5Tm9WYWx1ZUZhbGxiYWNrVG9LZXkgfHwgdGhpcy5vcHRpb25zLm1pc3NpbmdLZXlOb1ZhbHVlRmFsbGJhY2tUb0tleTtcbiAgICAgIGNvbnN0IHJlc0Zvck1pc3NpbmcgPSBtaXNzaW5nS2V5Tm9WYWx1ZUZhbGxiYWNrVG9LZXkgJiYgdXNlZEtleSA/IHVuZGVmaW5lZCA6IHJlcztcbiAgICAgIGNvbnN0IHVwZGF0ZU1pc3NpbmcgPSBoYXNEZWZhdWx0VmFsdWUgJiYgZGVmYXVsdFZhbHVlICE9PSByZXMgJiYgdGhpcy5vcHRpb25zLnVwZGF0ZU1pc3Npbmc7XG4gICAgICBpZiAodXNlZEtleSB8fCB1c2VkRGVmYXVsdCB8fCB1cGRhdGVNaXNzaW5nKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyh1cGRhdGVNaXNzaW5nID8gJ3VwZGF0ZUtleScgOiAnbWlzc2luZ0tleScsIGxuZywgbmFtZXNwYWNlLCBrZXksIHVwZGF0ZU1pc3NpbmcgPyBkZWZhdWx0VmFsdWUgOiByZXMpO1xuICAgICAgICBpZiAoa2V5U2VwYXJhdG9yKSB7XG4gICAgICAgICAgY29uc3QgZmsgPSB0aGlzLnJlc29sdmUoa2V5LCB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAga2V5U2VwYXJhdG9yOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChmayAmJiBmay5yZXMpIHRoaXMubG9nZ2VyLndhcm4oJ1NlZW1zIHRoZSBsb2FkZWQgdHJhbnNsYXRpb25zIHdlcmUgaW4gZmxhdCBKU09OIGZvcm1hdCBpbnN0ZWFkIG9mIG5lc3RlZC4gRWl0aGVyIHNldCBrZXlTZXBhcmF0b3I6IGZhbHNlIG9uIGluaXQgb3IgbWFrZSBzdXJlIHlvdXIgdHJhbnNsYXRpb25zIGFyZSBwdWJsaXNoZWQgaW4gbmVzdGVkIGZvcm1hdC4nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbG5ncyA9IFtdO1xuICAgICAgICBjb25zdCBmYWxsYmFja0xuZ3MgPSB0aGlzLmxhbmd1YWdlVXRpbHMuZ2V0RmFsbGJhY2tDb2Rlcyh0aGlzLm9wdGlvbnMuZmFsbGJhY2tMbmcsIG9wdGlvbnMubG5nIHx8IHRoaXMubGFuZ3VhZ2UpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNhdmVNaXNzaW5nVG8gPT09ICdmYWxsYmFjaycgJiYgZmFsbGJhY2tMbmdzICYmIGZhbGxiYWNrTG5nc1swXSkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmFsbGJhY2tMbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsbmdzLnB1c2goZmFsbGJhY2tMbmdzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnNhdmVNaXNzaW5nVG8gPT09ICdhbGwnKSB7XG4gICAgICAgICAgbG5ncyA9IHRoaXMubGFuZ3VhZ2VVdGlscy50b1Jlc29sdmVIaWVyYXJjaHkob3B0aW9ucy5sbmcgfHwgdGhpcy5sYW5ndWFnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG5ncy5wdXNoKG9wdGlvbnMubG5nIHx8IHRoaXMubGFuZ3VhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbmQgPSAobCwgaywgc3BlY2lmaWNEZWZhdWx0VmFsdWUpID0+IHtcbiAgICAgICAgICBjb25zdCBkZWZhdWx0Rm9yTWlzc2luZyA9IGhhc0RlZmF1bHRWYWx1ZSAmJiBzcGVjaWZpY0RlZmF1bHRWYWx1ZSAhPT0gcmVzID8gc3BlY2lmaWNEZWZhdWx0VmFsdWUgOiByZXNGb3JNaXNzaW5nO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubWlzc2luZ0tleUhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5taXNzaW5nS2V5SGFuZGxlcihsLCBuYW1lc3BhY2UsIGssIGRlZmF1bHRGb3JNaXNzaW5nLCB1cGRhdGVNaXNzaW5nLCBvcHRpb25zKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYmFja2VuZENvbm5lY3RvciAmJiB0aGlzLmJhY2tlbmRDb25uZWN0b3Iuc2F2ZU1pc3NpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuYmFja2VuZENvbm5lY3Rvci5zYXZlTWlzc2luZyhsLCBuYW1lc3BhY2UsIGssIGRlZmF1bHRGb3JNaXNzaW5nLCB1cGRhdGVNaXNzaW5nLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lbWl0KCdtaXNzaW5nS2V5JywgbCwgbmFtZXNwYWNlLCBrLCByZXMpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNhdmVNaXNzaW5nKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zYXZlTWlzc2luZ1BsdXJhbHMgJiYgbmVlZHNQbHVyYWxIYW5kbGluZykge1xuICAgICAgICAgICAgbG5ncy5mb3JFYWNoKGxhbmd1YWdlID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5wbHVyYWxSZXNvbHZlci5nZXRTdWZmaXhlcyhsYW5ndWFnZSwgb3B0aW9ucykuZm9yRWFjaChzdWZmaXggPT4ge1xuICAgICAgICAgICAgICAgIHNlbmQoW2xhbmd1YWdlXSwga2V5ICsgc3VmZml4LCBvcHRpb25zW2BkZWZhdWx0VmFsdWUke3N1ZmZpeH1gXSB8fCBkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZW5kKGxuZ3MsIGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlcyA9IHRoaXMuZXh0ZW5kVHJhbnNsYXRpb24ocmVzLCBrZXlzLCBvcHRpb25zLCByZXNvbHZlZCwgbGFzdEtleSk7XG4gICAgICBpZiAodXNlZEtleSAmJiByZXMgPT09IGtleSAmJiB0aGlzLm9wdGlvbnMuYXBwZW5kTmFtZXNwYWNlVG9NaXNzaW5nS2V5KSByZXMgPSBgJHtuYW1lc3BhY2V9OiR7a2V5fWA7XG4gICAgICBpZiAoKHVzZWRLZXkgfHwgdXNlZERlZmF1bHQpICYmIHRoaXMub3B0aW9ucy5wYXJzZU1pc3NpbmdLZXlIYW5kbGVyKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29tcGF0aWJpbGl0eUFQSSAhPT0gJ3YxJykge1xuICAgICAgICAgIHJlcyA9IHRoaXMub3B0aW9ucy5wYXJzZU1pc3NpbmdLZXlIYW5kbGVyKHRoaXMub3B0aW9ucy5hcHBlbmROYW1lc3BhY2VUb01pc3NpbmdLZXkgPyBgJHtuYW1lc3BhY2V9OiR7a2V5fWAgOiBrZXksIHVzZWREZWZhdWx0ID8gcmVzIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXMgPSB0aGlzLm9wdGlvbnMucGFyc2VNaXNzaW5nS2V5SGFuZGxlcihyZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZXR1cm5EZXRhaWxzKSB7XG4gICAgICByZXNvbHZlZC5yZXMgPSByZXM7XG4gICAgICByZXNvbHZlZC51c2VkUGFyYW1zID0gdGhpcy5nZXRVc2VkUGFyYW1zRGV0YWlscyhvcHRpb25zKTtcbiAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBleHRlbmRUcmFuc2xhdGlvbihyZXMsIGtleSwgb3B0aW9ucywgcmVzb2x2ZWQsIGxhc3RLZXkpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmICh0aGlzLmkxOG5Gb3JtYXQgJiYgdGhpcy5pMThuRm9ybWF0LnBhcnNlKSB7XG4gICAgICByZXMgPSB0aGlzLmkxOG5Gb3JtYXQucGFyc2UocmVzLCB7XG4gICAgICAgIC4uLnRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0sIG9wdGlvbnMubG5nIHx8IHRoaXMubGFuZ3VhZ2UgfHwgcmVzb2x2ZWQudXNlZExuZywgcmVzb2x2ZWQudXNlZE5TLCByZXNvbHZlZC51c2VkS2V5LCB7XG4gICAgICAgIHJlc29sdmVkXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFvcHRpb25zLnNraXBJbnRlcnBvbGF0aW9uKSB7XG4gICAgICBpZiAob3B0aW9ucy5pbnRlcnBvbGF0aW9uKSB0aGlzLmludGVycG9sYXRvci5pbml0KHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgLi4ue1xuICAgICAgICAgIGludGVycG9sYXRpb246IHtcbiAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLFxuICAgICAgICAgICAgLi4ub3B0aW9ucy5pbnRlcnBvbGF0aW9uXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHNraXBPblZhcmlhYmxlcyA9IHR5cGVvZiByZXMgPT09ICdzdHJpbmcnICYmIChvcHRpb25zICYmIG9wdGlvbnMuaW50ZXJwb2xhdGlvbiAmJiBvcHRpb25zLmludGVycG9sYXRpb24uc2tpcE9uVmFyaWFibGVzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmludGVycG9sYXRpb24uc2tpcE9uVmFyaWFibGVzIDogdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uc2tpcE9uVmFyaWFibGVzKTtcbiAgICAgIGxldCBuZXN0QmVmO1xuICAgICAgaWYgKHNraXBPblZhcmlhYmxlcykge1xuICAgICAgICBjb25zdCBuYiA9IHJlcy5tYXRjaCh0aGlzLmludGVycG9sYXRvci5uZXN0aW5nUmVnZXhwKTtcbiAgICAgICAgbmVzdEJlZiA9IG5iICYmIG5iLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGxldCBkYXRhID0gb3B0aW9ucy5yZXBsYWNlICYmIHR5cGVvZiBvcHRpb25zLnJlcGxhY2UgIT09ICdzdHJpbmcnID8gb3B0aW9ucy5yZXBsYWNlIDogb3B0aW9ucztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5kZWZhdWx0VmFyaWFibGVzKSBkYXRhID0ge1xuICAgICAgICAuLi50aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5kZWZhdWx0VmFyaWFibGVzLFxuICAgICAgICAuLi5kYXRhXG4gICAgICB9O1xuICAgICAgcmVzID0gdGhpcy5pbnRlcnBvbGF0b3IuaW50ZXJwb2xhdGUocmVzLCBkYXRhLCBvcHRpb25zLmxuZyB8fCB0aGlzLmxhbmd1YWdlLCBvcHRpb25zKTtcbiAgICAgIGlmIChza2lwT25WYXJpYWJsZXMpIHtcbiAgICAgICAgY29uc3QgbmEgPSByZXMubWF0Y2godGhpcy5pbnRlcnBvbGF0b3IubmVzdGluZ1JlZ2V4cCk7XG4gICAgICAgIGNvbnN0IG5lc3RBZnQgPSBuYSAmJiBuYS5sZW5ndGg7XG4gICAgICAgIGlmIChuZXN0QmVmIDwgbmVzdEFmdCkgb3B0aW9ucy5uZXN0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvbnMubG5nICYmIHRoaXMub3B0aW9ucy5jb21wYXRpYmlsaXR5QVBJICE9PSAndjEnICYmIHJlc29sdmVkICYmIHJlc29sdmVkLnJlcykgb3B0aW9ucy5sbmcgPSByZXNvbHZlZC51c2VkTG5nO1xuICAgICAgaWYgKG9wdGlvbnMubmVzdCAhPT0gZmFsc2UpIHJlcyA9IHRoaXMuaW50ZXJwb2xhdG9yLm5lc3QocmVzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RLZXkgJiYgbGFzdEtleVswXSA9PT0gYXJnc1swXSAmJiAhb3B0aW9ucy5jb250ZXh0KSB7XG4gICAgICAgICAgX3RoaXMubG9nZ2VyLndhcm4oYEl0IHNlZW1zIHlvdSBhcmUgbmVzdGluZyByZWN1cnNpdmVseSBrZXk6ICR7YXJnc1swXX0gaW4ga2V5OiAke2tleVswXX1gKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNsYXRlKC4uLmFyZ3MsIGtleSk7XG4gICAgICB9LCBvcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLmludGVycG9sYXRpb24pIHRoaXMuaW50ZXJwb2xhdG9yLnJlc2V0KCk7XG4gICAgfVxuICAgIGNvbnN0IHBvc3RQcm9jZXNzID0gb3B0aW9ucy5wb3N0UHJvY2VzcyB8fCB0aGlzLm9wdGlvbnMucG9zdFByb2Nlc3M7XG4gICAgY29uc3QgcG9zdFByb2Nlc3Nvck5hbWVzID0gdHlwZW9mIHBvc3RQcm9jZXNzID09PSAnc3RyaW5nJyA/IFtwb3N0UHJvY2Vzc10gOiBwb3N0UHJvY2VzcztcbiAgICBpZiAocmVzICE9PSB1bmRlZmluZWQgJiYgcmVzICE9PSBudWxsICYmIHBvc3RQcm9jZXNzb3JOYW1lcyAmJiBwb3N0UHJvY2Vzc29yTmFtZXMubGVuZ3RoICYmIG9wdGlvbnMuYXBwbHlQb3N0UHJvY2Vzc29yICE9PSBmYWxzZSkge1xuICAgICAgcmVzID0gcG9zdFByb2Nlc3Nvci5oYW5kbGUocG9zdFByb2Nlc3Nvck5hbWVzLCByZXMsIGtleSwgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5wb3N0UHJvY2Vzc1Bhc3NSZXNvbHZlZCA/IHtcbiAgICAgICAgaTE4blJlc29sdmVkOiB7XG4gICAgICAgICAgLi4ucmVzb2x2ZWQsXG4gICAgICAgICAgdXNlZFBhcmFtczogdGhpcy5nZXRVc2VkUGFyYW1zRGV0YWlscyhvcHRpb25zKVxuICAgICAgICB9LFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9IDogb3B0aW9ucywgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgcmVzb2x2ZShrZXlzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGxldCBmb3VuZDtcbiAgICBsZXQgdXNlZEtleTtcbiAgICBsZXQgZXhhY3RVc2VkS2V5O1xuICAgIGxldCB1c2VkTG5nO1xuICAgIGxldCB1c2VkTlM7XG4gICAgaWYgKHR5cGVvZiBrZXlzID09PSAnc3RyaW5nJykga2V5cyA9IFtrZXlzXTtcbiAgICBrZXlzLmZvckVhY2goayA9PiB7XG4gICAgICBpZiAodGhpcy5pc1ZhbGlkTG9va3VwKGZvdW5kKSkgcmV0dXJuO1xuICAgICAgY29uc3QgZXh0cmFjdGVkID0gdGhpcy5leHRyYWN0RnJvbUtleShrLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IGtleSA9IGV4dHJhY3RlZC5rZXk7XG4gICAgICB1c2VkS2V5ID0ga2V5O1xuICAgICAgbGV0IG5hbWVzcGFjZXMgPSBleHRyYWN0ZWQubmFtZXNwYWNlcztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZmFsbGJhY2tOUykgbmFtZXNwYWNlcyA9IG5hbWVzcGFjZXMuY29uY2F0KHRoaXMub3B0aW9ucy5mYWxsYmFja05TKTtcbiAgICAgIGNvbnN0IG5lZWRzUGx1cmFsSGFuZGxpbmcgPSBvcHRpb25zLmNvdW50ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdGlvbnMuY291bnQgIT09ICdzdHJpbmcnO1xuICAgICAgY29uc3QgbmVlZHNaZXJvU3VmZml4TG9va3VwID0gbmVlZHNQbHVyYWxIYW5kbGluZyAmJiAhb3B0aW9ucy5vcmRpbmFsICYmIG9wdGlvbnMuY291bnQgPT09IDAgJiYgdGhpcy5wbHVyYWxSZXNvbHZlci5zaG91bGRVc2VJbnRsQXBpKCk7XG4gICAgICBjb25zdCBuZWVkc0NvbnRleHRIYW5kbGluZyA9IG9wdGlvbnMuY29udGV4dCAhPT0gdW5kZWZpbmVkICYmICh0eXBlb2Ygb3B0aW9ucy5jb250ZXh0ID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygb3B0aW9ucy5jb250ZXh0ID09PSAnbnVtYmVyJykgJiYgb3B0aW9ucy5jb250ZXh0ICE9PSAnJztcbiAgICAgIGNvbnN0IGNvZGVzID0gb3B0aW9ucy5sbmdzID8gb3B0aW9ucy5sbmdzIDogdGhpcy5sYW5ndWFnZVV0aWxzLnRvUmVzb2x2ZUhpZXJhcmNoeShvcHRpb25zLmxuZyB8fCB0aGlzLmxhbmd1YWdlLCBvcHRpb25zLmZhbGxiYWNrTG5nKTtcbiAgICAgIG5hbWVzcGFjZXMuZm9yRWFjaChucyA9PiB7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWRMb29rdXAoZm91bmQpKSByZXR1cm47XG4gICAgICAgIHVzZWROUyA9IG5zO1xuICAgICAgICBpZiAoIWNoZWNrZWRMb2FkZWRGb3JbYCR7Y29kZXNbMF19LSR7bnN9YF0gJiYgdGhpcy51dGlscyAmJiB0aGlzLnV0aWxzLmhhc0xvYWRlZE5hbWVzcGFjZSAmJiAhdGhpcy51dGlscy5oYXNMb2FkZWROYW1lc3BhY2UodXNlZE5TKSkge1xuICAgICAgICAgIGNoZWNrZWRMb2FkZWRGb3JbYCR7Y29kZXNbMF19LSR7bnN9YF0gPSB0cnVlO1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYGtleSBcIiR7dXNlZEtleX1cIiBmb3IgbGFuZ3VhZ2VzIFwiJHtjb2Rlcy5qb2luKCcsICcpfVwiIHdvbid0IGdldCByZXNvbHZlZCBhcyBuYW1lc3BhY2UgXCIke3VzZWROU31cIiB3YXMgbm90IHlldCBsb2FkZWRgLCAnVGhpcyBtZWFucyBzb21ldGhpbmcgSVMgV1JPTkcgaW4geW91ciBzZXR1cC4gWW91IGFjY2VzcyB0aGUgdCBmdW5jdGlvbiBiZWZvcmUgaTE4bmV4dC5pbml0IC8gaTE4bmV4dC5sb2FkTmFtZXNwYWNlIC8gaTE4bmV4dC5jaGFuZ2VMYW5ndWFnZSB3YXMgZG9uZS4gV2FpdCBmb3IgdGhlIGNhbGxiYWNrIG9yIFByb21pc2UgdG8gcmVzb2x2ZSBiZWZvcmUgYWNjZXNzaW5nIGl0ISEhJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29kZXMuZm9yRWFjaChjb2RlID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkTG9va3VwKGZvdW5kKSkgcmV0dXJuO1xuICAgICAgICAgIHVzZWRMbmcgPSBjb2RlO1xuICAgICAgICAgIGNvbnN0IGZpbmFsS2V5cyA9IFtrZXldO1xuICAgICAgICAgIGlmICh0aGlzLmkxOG5Gb3JtYXQgJiYgdGhpcy5pMThuRm9ybWF0LmFkZExvb2t1cEtleXMpIHtcbiAgICAgICAgICAgIHRoaXMuaTE4bkZvcm1hdC5hZGRMb29rdXBLZXlzKGZpbmFsS2V5cywga2V5LCBjb2RlLCBucywgb3B0aW9ucyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBwbHVyYWxTdWZmaXg7XG4gICAgICAgICAgICBpZiAobmVlZHNQbHVyYWxIYW5kbGluZykgcGx1cmFsU3VmZml4ID0gdGhpcy5wbHVyYWxSZXNvbHZlci5nZXRTdWZmaXgoY29kZSwgb3B0aW9ucy5jb3VudCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCB6ZXJvU3VmZml4ID0gYCR7dGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcn16ZXJvYDtcbiAgICAgICAgICAgIGNvbnN0IG9yZGluYWxQcmVmaXggPSBgJHt0aGlzLm9wdGlvbnMucGx1cmFsU2VwYXJhdG9yfW9yZGluYWwke3RoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3J9YDtcbiAgICAgICAgICAgIGlmIChuZWVkc1BsdXJhbEhhbmRsaW5nKSB7XG4gICAgICAgICAgICAgIGZpbmFsS2V5cy5wdXNoKGtleSArIHBsdXJhbFN1ZmZpeCk7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLm9yZGluYWwgJiYgcGx1cmFsU3VmZml4LmluZGV4T2Yob3JkaW5hbFByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBmaW5hbEtleXMucHVzaChrZXkgKyBwbHVyYWxTdWZmaXgucmVwbGFjZShvcmRpbmFsUHJlZml4LCB0aGlzLm9wdGlvbnMucGx1cmFsU2VwYXJhdG9yKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG5lZWRzWmVyb1N1ZmZpeExvb2t1cCkge1xuICAgICAgICAgICAgICAgIGZpbmFsS2V5cy5wdXNoKGtleSArIHplcm9TdWZmaXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmVlZHNDb250ZXh0SGFuZGxpbmcpIHtcbiAgICAgICAgICAgICAgY29uc3QgY29udGV4dEtleSA9IGAke2tleX0ke3RoaXMub3B0aW9ucy5jb250ZXh0U2VwYXJhdG9yfSR7b3B0aW9ucy5jb250ZXh0fWA7XG4gICAgICAgICAgICAgIGZpbmFsS2V5cy5wdXNoKGNvbnRleHRLZXkpO1xuICAgICAgICAgICAgICBpZiAobmVlZHNQbHVyYWxIYW5kbGluZykge1xuICAgICAgICAgICAgICAgIGZpbmFsS2V5cy5wdXNoKGNvbnRleHRLZXkgKyBwbHVyYWxTdWZmaXgpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm9yZGluYWwgJiYgcGx1cmFsU3VmZml4LmluZGV4T2Yob3JkaW5hbFByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGZpbmFsS2V5cy5wdXNoKGNvbnRleHRLZXkgKyBwbHVyYWxTdWZmaXgucmVwbGFjZShvcmRpbmFsUHJlZml4LCB0aGlzLm9wdGlvbnMucGx1cmFsU2VwYXJhdG9yKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZWVkc1plcm9TdWZmaXhMb29rdXApIHtcbiAgICAgICAgICAgICAgICAgIGZpbmFsS2V5cy5wdXNoKGNvbnRleHRLZXkgKyB6ZXJvU3VmZml4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHBvc3NpYmxlS2V5O1xuICAgICAgICAgIHdoaWxlIChwb3NzaWJsZUtleSA9IGZpbmFsS2V5cy5wb3AoKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWRMb29rdXAoZm91bmQpKSB7XG4gICAgICAgICAgICAgIGV4YWN0VXNlZEtleSA9IHBvc3NpYmxlS2V5O1xuICAgICAgICAgICAgICBmb3VuZCA9IHRoaXMuZ2V0UmVzb3VyY2UoY29kZSwgbnMsIHBvc3NpYmxlS2V5LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlczogZm91bmQsXG4gICAgICB1c2VkS2V5LFxuICAgICAgZXhhY3RVc2VkS2V5LFxuICAgICAgdXNlZExuZyxcbiAgICAgIHVzZWROU1xuICAgIH07XG4gIH1cbiAgaXNWYWxpZExvb2t1cChyZXMpIHtcbiAgICByZXR1cm4gcmVzICE9PSB1bmRlZmluZWQgJiYgISghdGhpcy5vcHRpb25zLnJldHVybk51bGwgJiYgcmVzID09PSBudWxsKSAmJiAhKCF0aGlzLm9wdGlvbnMucmV0dXJuRW1wdHlTdHJpbmcgJiYgcmVzID09PSAnJyk7XG4gIH1cbiAgZ2V0UmVzb3VyY2UoY29kZSwgbnMsIGtleSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICBpZiAodGhpcy5pMThuRm9ybWF0ICYmIHRoaXMuaTE4bkZvcm1hdC5nZXRSZXNvdXJjZSkgcmV0dXJuIHRoaXMuaTE4bkZvcm1hdC5nZXRSZXNvdXJjZShjb2RlLCBucywga2V5LCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5yZXNvdXJjZVN0b3JlLmdldFJlc291cmNlKGNvZGUsIG5zLCBrZXksIG9wdGlvbnMpO1xuICB9XG4gIGdldFVzZWRQYXJhbXNEZXRhaWxzKCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjb25zdCBvcHRpb25zS2V5cyA9IFsnZGVmYXVsdFZhbHVlJywgJ29yZGluYWwnLCAnY29udGV4dCcsICdyZXBsYWNlJywgJ2xuZycsICdsbmdzJywgJ2ZhbGxiYWNrTG5nJywgJ25zJywgJ2tleVNlcGFyYXRvcicsICduc1NlcGFyYXRvcicsICdyZXR1cm5PYmplY3RzJywgJ3JldHVybkRldGFpbHMnLCAnam9pbkFycmF5cycsICdwb3N0UHJvY2VzcycsICdpbnRlcnBvbGF0aW9uJ107XG4gICAgY29uc3QgdXNlT3B0aW9uc1JlcGxhY2VGb3JEYXRhID0gb3B0aW9ucy5yZXBsYWNlICYmIHR5cGVvZiBvcHRpb25zLnJlcGxhY2UgIT09ICdzdHJpbmcnO1xuICAgIGxldCBkYXRhID0gdXNlT3B0aW9uc1JlcGxhY2VGb3JEYXRhID8gb3B0aW9ucy5yZXBsYWNlIDogb3B0aW9ucztcbiAgICBpZiAodXNlT3B0aW9uc1JlcGxhY2VGb3JEYXRhICYmIHR5cGVvZiBvcHRpb25zLmNvdW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZGF0YS5jb3VudCA9IG9wdGlvbnMuY291bnQ7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5kZWZhdWx0VmFyaWFibGVzKSB7XG4gICAgICBkYXRhID0ge1xuICAgICAgICAuLi50aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5kZWZhdWx0VmFyaWFibGVzLFxuICAgICAgICAuLi5kYXRhXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIXVzZU9wdGlvbnNSZXBsYWNlRm9yRGF0YSkge1xuICAgICAgZGF0YSA9IHtcbiAgICAgICAgLi4uZGF0YVxuICAgICAgfTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIG9wdGlvbnNLZXlzKSB7XG4gICAgICAgIGRlbGV0ZSBkYXRhW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIHN0YXRpYyBoYXNEZWZhdWx0VmFsdWUob3B0aW9ucykge1xuICAgIGNvbnN0IHByZWZpeCA9ICdkZWZhdWx0VmFsdWUnO1xuICAgIGZvciAoY29uc3Qgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgb3B0aW9uKSAmJiBwcmVmaXggPT09IG9wdGlvbi5zdWJzdHJpbmcoMCwgcHJlZml4Lmxlbmd0aCkgJiYgdW5kZWZpbmVkICE9PSBvcHRpb25zW29wdGlvbl0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xufVxuY2xhc3MgTGFuZ3VhZ2VVdGlsIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5zdXBwb3J0ZWRMbmdzID0gdGhpcy5vcHRpb25zLnN1cHBvcnRlZExuZ3MgfHwgZmFsc2U7XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyLmNyZWF0ZSgnbGFuZ3VhZ2VVdGlscycpO1xuICB9XG4gIGdldFNjcmlwdFBhcnRGcm9tQ29kZShjb2RlKSB7XG4gICAgY29kZSA9IGdldENsZWFuZWRDb2RlKGNvZGUpO1xuICAgIGlmICghY29kZSB8fCBjb2RlLmluZGV4T2YoJy0nKSA8IDApIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHAgPSBjb2RlLnNwbGl0KCctJyk7XG4gICAgaWYgKHAubGVuZ3RoID09PSAyKSByZXR1cm4gbnVsbDtcbiAgICBwLnBvcCgpO1xuICAgIGlmIChwW3AubGVuZ3RoIC0gMV0udG9Mb3dlckNhc2UoKSA9PT0gJ3gnKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUocC5qb2luKCctJykpO1xuICB9XG4gIGdldExhbmd1YWdlUGFydEZyb21Db2RlKGNvZGUpIHtcbiAgICBjb2RlID0gZ2V0Q2xlYW5lZENvZGUoY29kZSk7XG4gICAgaWYgKCFjb2RlIHx8IGNvZGUuaW5kZXhPZignLScpIDwgMCkgcmV0dXJuIGNvZGU7XG4gICAgY29uc3QgcCA9IGNvZGUuc3BsaXQoJy0nKTtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUocFswXSk7XG4gIH1cbiAgZm9ybWF0TGFuZ3VhZ2VDb2RlKGNvZGUpIHtcbiAgICBpZiAodHlwZW9mIGNvZGUgPT09ICdzdHJpbmcnICYmIGNvZGUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIGNvbnN0IHNwZWNpYWxDYXNlcyA9IFsnaGFucycsICdoYW50JywgJ2xhdG4nLCAnY3lybCcsICdjYW5zJywgJ21vbmcnLCAnYXJhYiddO1xuICAgICAgbGV0IHAgPSBjb2RlLnNwbGl0KCctJyk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvd2VyQ2FzZUxuZykge1xuICAgICAgICBwID0gcC5tYXAocGFydCA9PiBwYXJ0LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgfSBlbHNlIGlmIChwLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBwWzBdID0gcFswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBwWzFdID0gcFsxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAoc3BlY2lhbENhc2VzLmluZGV4T2YocFsxXS50b0xvd2VyQ2FzZSgpKSA+IC0xKSBwWzFdID0gY2FwaXRhbGl6ZShwWzFdLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgfSBlbHNlIGlmIChwLmxlbmd0aCA9PT0gMykge1xuICAgICAgICBwWzBdID0gcFswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAocFsxXS5sZW5ndGggPT09IDIpIHBbMV0gPSBwWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmIChwWzBdICE9PSAnc2duJyAmJiBwWzJdLmxlbmd0aCA9PT0gMikgcFsyXSA9IHBbMl0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKHNwZWNpYWxDYXNlcy5pbmRleE9mKHBbMV0udG9Mb3dlckNhc2UoKSkgPiAtMSkgcFsxXSA9IGNhcGl0YWxpemUocFsxXS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgaWYgKHNwZWNpYWxDYXNlcy5pbmRleE9mKHBbMl0udG9Mb3dlckNhc2UoKSkgPiAtMSkgcFsyXSA9IGNhcGl0YWxpemUocFsyXS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwLmpvaW4oJy0nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5jbGVhbkNvZGUgfHwgdGhpcy5vcHRpb25zLmxvd2VyQ2FzZUxuZyA/IGNvZGUudG9Mb3dlckNhc2UoKSA6IGNvZGU7XG4gIH1cbiAgaXNTdXBwb3J0ZWRDb2RlKGNvZGUpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvYWQgPT09ICdsYW5ndWFnZU9ubHknIHx8IHRoaXMub3B0aW9ucy5ub25FeHBsaWNpdFN1cHBvcnRlZExuZ3MpIHtcbiAgICAgIGNvZGUgPSB0aGlzLmdldExhbmd1YWdlUGFydEZyb21Db2RlKGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gIXRoaXMuc3VwcG9ydGVkTG5ncyB8fCAhdGhpcy5zdXBwb3J0ZWRMbmdzLmxlbmd0aCB8fCB0aGlzLnN1cHBvcnRlZExuZ3MuaW5kZXhPZihjb2RlKSA+IC0xO1xuICB9XG4gIGdldEJlc3RNYXRjaEZyb21Db2Rlcyhjb2Rlcykge1xuICAgIGlmICghY29kZXMpIHJldHVybiBudWxsO1xuICAgIGxldCBmb3VuZDtcbiAgICBjb2Rlcy5mb3JFYWNoKGNvZGUgPT4ge1xuICAgICAgaWYgKGZvdW5kKSByZXR1cm47XG4gICAgICBjb25zdCBjbGVhbmVkTG5nID0gdGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUoY29kZSk7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zdXBwb3J0ZWRMbmdzIHx8IHRoaXMuaXNTdXBwb3J0ZWRDb2RlKGNsZWFuZWRMbmcpKSBmb3VuZCA9IGNsZWFuZWRMbmc7XG4gICAgfSk7XG4gICAgaWYgKCFmb3VuZCAmJiB0aGlzLm9wdGlvbnMuc3VwcG9ydGVkTG5ncykge1xuICAgICAgY29kZXMuZm9yRWFjaChjb2RlID0+IHtcbiAgICAgICAgaWYgKGZvdW5kKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGxuZ09ubHkgPSB0aGlzLmdldExhbmd1YWdlUGFydEZyb21Db2RlKGNvZGUpO1xuICAgICAgICBpZiAodGhpcy5pc1N1cHBvcnRlZENvZGUobG5nT25seSkpIHJldHVybiBmb3VuZCA9IGxuZ09ubHk7XG4gICAgICAgIGZvdW5kID0gdGhpcy5vcHRpb25zLnN1cHBvcnRlZExuZ3MuZmluZChzdXBwb3J0ZWRMbmcgPT4ge1xuICAgICAgICAgIGlmIChzdXBwb3J0ZWRMbmcgPT09IGxuZ09ubHkpIHJldHVybiBzdXBwb3J0ZWRMbmc7XG4gICAgICAgICAgaWYgKHN1cHBvcnRlZExuZy5pbmRleE9mKCctJykgPCAwICYmIGxuZ09ubHkuaW5kZXhPZignLScpIDwgMCkgcmV0dXJuO1xuICAgICAgICAgIGlmIChzdXBwb3J0ZWRMbmcuaW5kZXhPZihsbmdPbmx5KSA9PT0gMCkgcmV0dXJuIHN1cHBvcnRlZExuZztcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFmb3VuZCkgZm91bmQgPSB0aGlzLmdldEZhbGxiYWNrQ29kZXModGhpcy5vcHRpb25zLmZhbGxiYWNrTG5nKVswXTtcbiAgICByZXR1cm4gZm91bmQ7XG4gIH1cbiAgZ2V0RmFsbGJhY2tDb2RlcyhmYWxsYmFja3MsIGNvZGUpIHtcbiAgICBpZiAoIWZhbGxiYWNrcykgcmV0dXJuIFtdO1xuICAgIGlmICh0eXBlb2YgZmFsbGJhY2tzID09PSAnZnVuY3Rpb24nKSBmYWxsYmFja3MgPSBmYWxsYmFja3MoY29kZSk7XG4gICAgaWYgKHR5cGVvZiBmYWxsYmFja3MgPT09ICdzdHJpbmcnKSBmYWxsYmFja3MgPSBbZmFsbGJhY2tzXTtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShmYWxsYmFja3MpID09PSAnW29iamVjdCBBcnJheV0nKSByZXR1cm4gZmFsbGJhY2tzO1xuICAgIGlmICghY29kZSkgcmV0dXJuIGZhbGxiYWNrcy5kZWZhdWx0IHx8IFtdO1xuICAgIGxldCBmb3VuZCA9IGZhbGxiYWNrc1tjb2RlXTtcbiAgICBpZiAoIWZvdW5kKSBmb3VuZCA9IGZhbGxiYWNrc1t0aGlzLmdldFNjcmlwdFBhcnRGcm9tQ29kZShjb2RlKV07XG4gICAgaWYgKCFmb3VuZCkgZm91bmQgPSBmYWxsYmFja3NbdGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUoY29kZSldO1xuICAgIGlmICghZm91bmQpIGZvdW5kID0gZmFsbGJhY2tzW3RoaXMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSldO1xuICAgIGlmICghZm91bmQpIGZvdW5kID0gZmFsbGJhY2tzLmRlZmF1bHQ7XG4gICAgcmV0dXJuIGZvdW5kIHx8IFtdO1xuICB9XG4gIHRvUmVzb2x2ZUhpZXJhcmNoeShjb2RlLCBmYWxsYmFja0NvZGUpIHtcbiAgICBjb25zdCBmYWxsYmFja0NvZGVzID0gdGhpcy5nZXRGYWxsYmFja0NvZGVzKGZhbGxiYWNrQ29kZSB8fCB0aGlzLm9wdGlvbnMuZmFsbGJhY2tMbmcgfHwgW10sIGNvZGUpO1xuICAgIGNvbnN0IGNvZGVzID0gW107XG4gICAgY29uc3QgYWRkQ29kZSA9IGMgPT4ge1xuICAgICAgaWYgKCFjKSByZXR1cm47XG4gICAgICBpZiAodGhpcy5pc1N1cHBvcnRlZENvZGUoYykpIHtcbiAgICAgICAgY29kZXMucHVzaChjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYHJlamVjdGluZyBsYW5ndWFnZSBjb2RlIG5vdCBmb3VuZCBpbiBzdXBwb3J0ZWRMbmdzOiAke2N9YCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAodHlwZW9mIGNvZGUgPT09ICdzdHJpbmcnICYmIChjb2RlLmluZGV4T2YoJy0nKSA+IC0xIHx8IGNvZGUuaW5kZXhPZignXycpID4gLTEpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvYWQgIT09ICdsYW5ndWFnZU9ubHknKSBhZGRDb2RlKHRoaXMuZm9ybWF0TGFuZ3VhZ2VDb2RlKGNvZGUpKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9hZCAhPT0gJ2xhbmd1YWdlT25seScgJiYgdGhpcy5vcHRpb25zLmxvYWQgIT09ICdjdXJyZW50T25seScpIGFkZENvZGUodGhpcy5nZXRTY3JpcHRQYXJ0RnJvbUNvZGUoY29kZSkpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2FkICE9PSAnY3VycmVudE9ubHknKSBhZGRDb2RlKHRoaXMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhZGRDb2RlKHRoaXMuZm9ybWF0TGFuZ3VhZ2VDb2RlKGNvZGUpKTtcbiAgICB9XG4gICAgZmFsbGJhY2tDb2Rlcy5mb3JFYWNoKGZjID0+IHtcbiAgICAgIGlmIChjb2Rlcy5pbmRleE9mKGZjKSA8IDApIGFkZENvZGUodGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUoZmMpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29kZXM7XG4gIH1cbn1cblxubGV0IHNldHMgPSBbe1xuICBsbmdzOiBbJ2FjaCcsICdhaycsICdhbScsICdhcm4nLCAnYnInLCAnZmlsJywgJ2d1bicsICdsbicsICdtZmUnLCAnbWcnLCAnbWknLCAnb2MnLCAncHQnLCAncHQtQlInLCAndGcnLCAndGwnLCAndGknLCAndHInLCAndXonLCAnd2EnXSxcbiAgbnI6IFsxLCAyXSxcbiAgZmM6IDFcbn0sIHtcbiAgbG5nczogWydhZicsICdhbicsICdhc3QnLCAnYXonLCAnYmcnLCAnYm4nLCAnY2EnLCAnZGEnLCAnZGUnLCAnZGV2JywgJ2VsJywgJ2VuJywgJ2VvJywgJ2VzJywgJ2V0JywgJ2V1JywgJ2ZpJywgJ2ZvJywgJ2Z1cicsICdmeScsICdnbCcsICdndScsICdoYScsICdoaScsICdodScsICdoeScsICdpYScsICdpdCcsICdraycsICdrbicsICdrdScsICdsYicsICdtYWknLCAnbWwnLCAnbW4nLCAnbXInLCAnbmFoJywgJ25hcCcsICduYicsICduZScsICdubCcsICdubicsICdubycsICduc28nLCAncGEnLCAncGFwJywgJ3BtcycsICdwcycsICdwdC1QVCcsICdybScsICdzY28nLCAnc2UnLCAnc2knLCAnc28nLCAnc29uJywgJ3NxJywgJ3N2JywgJ3N3JywgJ3RhJywgJ3RlJywgJ3RrJywgJ3VyJywgJ3lvJ10sXG4gIG5yOiBbMSwgMl0sXG4gIGZjOiAyXG59LCB7XG4gIGxuZ3M6IFsnYXknLCAnYm8nLCAnY2dnJywgJ2ZhJywgJ2h0JywgJ2lkJywgJ2phJywgJ2pibycsICdrYScsICdrbScsICdrbycsICdreScsICdsbycsICdtcycsICdzYWgnLCAnc3UnLCAndGgnLCAndHQnLCAndWcnLCAndmknLCAnd28nLCAnemgnXSxcbiAgbnI6IFsxXSxcbiAgZmM6IDNcbn0sIHtcbiAgbG5nczogWydiZScsICdicycsICdjbnInLCAnZHonLCAnaHInLCAncnUnLCAnc3InLCAndWsnXSxcbiAgbnI6IFsxLCAyLCA1XSxcbiAgZmM6IDRcbn0sIHtcbiAgbG5nczogWydhciddLFxuICBucjogWzAsIDEsIDIsIDMsIDExLCAxMDBdLFxuICBmYzogNVxufSwge1xuICBsbmdzOiBbJ2NzJywgJ3NrJ10sXG4gIG5yOiBbMSwgMiwgNV0sXG4gIGZjOiA2XG59LCB7XG4gIGxuZ3M6IFsnY3NiJywgJ3BsJ10sXG4gIG5yOiBbMSwgMiwgNV0sXG4gIGZjOiA3XG59LCB7XG4gIGxuZ3M6IFsnY3knXSxcbiAgbnI6IFsxLCAyLCAzLCA4XSxcbiAgZmM6IDhcbn0sIHtcbiAgbG5nczogWydmciddLFxuICBucjogWzEsIDJdLFxuICBmYzogOVxufSwge1xuICBsbmdzOiBbJ2dhJ10sXG4gIG5yOiBbMSwgMiwgMywgNywgMTFdLFxuICBmYzogMTBcbn0sIHtcbiAgbG5nczogWydnZCddLFxuICBucjogWzEsIDIsIDMsIDIwXSxcbiAgZmM6IDExXG59LCB7XG4gIGxuZ3M6IFsnaXMnXSxcbiAgbnI6IFsxLCAyXSxcbiAgZmM6IDEyXG59LCB7XG4gIGxuZ3M6IFsnanYnXSxcbiAgbnI6IFswLCAxXSxcbiAgZmM6IDEzXG59LCB7XG4gIGxuZ3M6IFsna3cnXSxcbiAgbnI6IFsxLCAyLCAzLCA0XSxcbiAgZmM6IDE0XG59LCB7XG4gIGxuZ3M6IFsnbHQnXSxcbiAgbnI6IFsxLCAyLCAxMF0sXG4gIGZjOiAxNVxufSwge1xuICBsbmdzOiBbJ2x2J10sXG4gIG5yOiBbMSwgMiwgMF0sXG4gIGZjOiAxNlxufSwge1xuICBsbmdzOiBbJ21rJ10sXG4gIG5yOiBbMSwgMl0sXG4gIGZjOiAxN1xufSwge1xuICBsbmdzOiBbJ21uayddLFxuICBucjogWzAsIDEsIDJdLFxuICBmYzogMThcbn0sIHtcbiAgbG5nczogWydtdCddLFxuICBucjogWzEsIDIsIDExLCAyMF0sXG4gIGZjOiAxOVxufSwge1xuICBsbmdzOiBbJ29yJ10sXG4gIG5yOiBbMiwgMV0sXG4gIGZjOiAyXG59LCB7XG4gIGxuZ3M6IFsncm8nXSxcbiAgbnI6IFsxLCAyLCAyMF0sXG4gIGZjOiAyMFxufSwge1xuICBsbmdzOiBbJ3NsJ10sXG4gIG5yOiBbNSwgMSwgMiwgM10sXG4gIGZjOiAyMVxufSwge1xuICBsbmdzOiBbJ2hlJywgJ2l3J10sXG4gIG5yOiBbMSwgMiwgMjAsIDIxXSxcbiAgZmM6IDIyXG59XTtcbmxldCBfcnVsZXNQbHVyYWxzVHlwZXMgPSB7XG4gIDE6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuID4gMSk7XG4gIH0sXG4gIDI6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuICE9IDEpO1xuICB9LFxuICAzOiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiAwO1xuICB9LFxuICA0OiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBOdW1iZXIobiAlIDEwID09IDEgJiYgbiAlIDEwMCAhPSAxMSA/IDAgOiBuICUgMTAgPj0gMiAmJiBuICUgMTAgPD0gNCAmJiAobiAlIDEwMCA8IDEwIHx8IG4gJSAxMDAgPj0gMjApID8gMSA6IDIpO1xuICB9LFxuICA1OiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBOdW1iZXIobiA9PSAwID8gMCA6IG4gPT0gMSA/IDEgOiBuID09IDIgPyAyIDogbiAlIDEwMCA+PSAzICYmIG4gJSAxMDAgPD0gMTAgPyAzIDogbiAlIDEwMCA+PSAxMSA/IDQgOiA1KTtcbiAgfSxcbiAgNjogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gPT0gMSA/IDAgOiBuID49IDIgJiYgbiA8PSA0ID8gMSA6IDIpO1xuICB9LFxuICA3OiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBOdW1iZXIobiA9PSAxID8gMCA6IG4gJSAxMCA+PSAyICYmIG4gJSAxMCA8PSA0ICYmIChuICUgMTAwIDwgMTAgfHwgbiAlIDEwMCA+PSAyMCkgPyAxIDogMik7XG4gIH0sXG4gIDg6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuID09IDEgPyAwIDogbiA9PSAyID8gMSA6IG4gIT0gOCAmJiBuICE9IDExID8gMiA6IDMpO1xuICB9LFxuICA5OiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBOdW1iZXIobiA+PSAyKTtcbiAgfSxcbiAgMTA6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuID09IDEgPyAwIDogbiA9PSAyID8gMSA6IG4gPCA3ID8gMiA6IG4gPCAxMSA/IDMgOiA0KTtcbiAgfSxcbiAgMTE6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuID09IDEgfHwgbiA9PSAxMSA/IDAgOiBuID09IDIgfHwgbiA9PSAxMiA/IDEgOiBuID4gMiAmJiBuIDwgMjAgPyAyIDogMyk7XG4gIH0sXG4gIDEyOiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBOdW1iZXIobiAlIDEwICE9IDEgfHwgbiAlIDEwMCA9PSAxMSk7XG4gIH0sXG4gIDEzOiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBOdW1iZXIobiAhPT0gMCk7XG4gIH0sXG4gIDE0OiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBOdW1iZXIobiA9PSAxID8gMCA6IG4gPT0gMiA/IDEgOiBuID09IDMgPyAyIDogMyk7XG4gIH0sXG4gIDE1OiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBOdW1iZXIobiAlIDEwID09IDEgJiYgbiAlIDEwMCAhPSAxMSA/IDAgOiBuICUgMTAgPj0gMiAmJiAobiAlIDEwMCA8IDEwIHx8IG4gJSAxMDAgPj0gMjApID8gMSA6IDIpO1xuICB9LFxuICAxNjogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gJSAxMCA9PSAxICYmIG4gJSAxMDAgIT0gMTEgPyAwIDogbiAhPT0gMCA/IDEgOiAyKTtcbiAgfSxcbiAgMTc6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuID09IDEgfHwgbiAlIDEwID09IDEgJiYgbiAlIDEwMCAhPSAxMSA/IDAgOiAxKTtcbiAgfSxcbiAgMTg6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuID09IDAgPyAwIDogbiA9PSAxID8gMSA6IDIpO1xuICB9LFxuICAxOTogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gPT0gMSA/IDAgOiBuID09IDAgfHwgbiAlIDEwMCA+IDEgJiYgbiAlIDEwMCA8IDExID8gMSA6IG4gJSAxMDAgPiAxMCAmJiBuICUgMTAwIDwgMjAgPyAyIDogMyk7XG4gIH0sXG4gIDIwOiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBOdW1iZXIobiA9PSAxID8gMCA6IG4gPT0gMCB8fCBuICUgMTAwID4gMCAmJiBuICUgMTAwIDwgMjAgPyAxIDogMik7XG4gIH0sXG4gIDIxOiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBOdW1iZXIobiAlIDEwMCA9PSAxID8gMSA6IG4gJSAxMDAgPT0gMiA/IDIgOiBuICUgMTAwID09IDMgfHwgbiAlIDEwMCA9PSA0ID8gMyA6IDApO1xuICB9LFxuICAyMjogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gPT0gMSA/IDAgOiBuID09IDIgPyAxIDogKG4gPCAwIHx8IG4gPiAxMCkgJiYgbiAlIDEwID09IDAgPyAyIDogMyk7XG4gIH1cbn07XG5jb25zdCBub25JbnRsVmVyc2lvbnMgPSBbJ3YxJywgJ3YyJywgJ3YzJ107XG5jb25zdCBpbnRsVmVyc2lvbnMgPSBbJ3Y0J107XG5jb25zdCBzdWZmaXhlc09yZGVyID0ge1xuICB6ZXJvOiAwLFxuICBvbmU6IDEsXG4gIHR3bzogMixcbiAgZmV3OiAzLFxuICBtYW55OiA0LFxuICBvdGhlcjogNVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVJ1bGVzKCkge1xuICBjb25zdCBydWxlcyA9IHt9O1xuICBzZXRzLmZvckVhY2goc2V0ID0+IHtcbiAgICBzZXQubG5ncy5mb3JFYWNoKGwgPT4ge1xuICAgICAgcnVsZXNbbF0gPSB7XG4gICAgICAgIG51bWJlcnM6IHNldC5ucixcbiAgICAgICAgcGx1cmFsczogX3J1bGVzUGx1cmFsc1R5cGVzW3NldC5mY11cbiAgICAgIH07XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gcnVsZXM7XG59XG5jbGFzcyBQbHVyYWxSZXNvbHZlciB7XG4gIGNvbnN0cnVjdG9yKGxhbmd1YWdlVXRpbHMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdGhpcy5sYW5ndWFnZVV0aWxzID0gbGFuZ3VhZ2VVdGlscztcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMubG9nZ2VyID0gYmFzZUxvZ2dlci5jcmVhdGUoJ3BsdXJhbFJlc29sdmVyJyk7XG4gICAgaWYgKCghdGhpcy5vcHRpb25zLmNvbXBhdGliaWxpdHlKU09OIHx8IGludGxWZXJzaW9ucy5pbmNsdWRlcyh0aGlzLm9wdGlvbnMuY29tcGF0aWJpbGl0eUpTT04pKSAmJiAodHlwZW9mIEludGwgPT09ICd1bmRlZmluZWQnIHx8ICFJbnRsLlBsdXJhbFJ1bGVzKSkge1xuICAgICAgdGhpcy5vcHRpb25zLmNvbXBhdGliaWxpdHlKU09OID0gJ3YzJztcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdZb3VyIGVudmlyb25tZW50IHNlZW1zIG5vdCB0byBiZSBJbnRsIEFQSSBjb21wYXRpYmxlLCB1c2UgYW4gSW50bC5QbHVyYWxSdWxlcyBwb2x5ZmlsbC4gV2lsbCBmYWxsYmFjayB0byB0aGUgY29tcGF0aWJpbGl0eUpTT04gdjMgZm9ybWF0IGhhbmRsaW5nLicpO1xuICAgIH1cbiAgICB0aGlzLnJ1bGVzID0gY3JlYXRlUnVsZXMoKTtcbiAgfVxuICBhZGRSdWxlKGxuZywgb2JqKSB7XG4gICAgdGhpcy5ydWxlc1tsbmddID0gb2JqO1xuICB9XG4gIGdldFJ1bGUoY29kZSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBpZiAodGhpcy5zaG91bGRVc2VJbnRsQXBpKCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50bC5QbHVyYWxSdWxlcyhnZXRDbGVhbmVkQ29kZShjb2RlKSwge1xuICAgICAgICAgIHR5cGU6IG9wdGlvbnMub3JkaW5hbCA/ICdvcmRpbmFsJyA6ICdjYXJkaW5hbCdcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ydWxlc1tjb2RlXSB8fCB0aGlzLnJ1bGVzW3RoaXMubGFuZ3VhZ2VVdGlscy5nZXRMYW5ndWFnZVBhcnRGcm9tQ29kZShjb2RlKV07XG4gIH1cbiAgbmVlZHNQbHVyYWwoY29kZSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBjb25zdCBydWxlID0gdGhpcy5nZXRSdWxlKGNvZGUsIG9wdGlvbnMpO1xuICAgIGlmICh0aGlzLnNob3VsZFVzZUludGxBcGkoKSkge1xuICAgICAgcmV0dXJuIHJ1bGUgJiYgcnVsZS5yZXNvbHZlZE9wdGlvbnMoKS5wbHVyYWxDYXRlZ29yaWVzLmxlbmd0aCA+IDE7XG4gICAgfVxuICAgIHJldHVybiBydWxlICYmIHJ1bGUubnVtYmVycy5sZW5ndGggPiAxO1xuICB9XG4gIGdldFBsdXJhbEZvcm1zT2ZLZXkoY29kZSwga2V5KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiB0aGlzLmdldFN1ZmZpeGVzKGNvZGUsIG9wdGlvbnMpLm1hcChzdWZmaXggPT4gYCR7a2V5fSR7c3VmZml4fWApO1xuICB9XG4gIGdldFN1ZmZpeGVzKGNvZGUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY29uc3QgcnVsZSA9IHRoaXMuZ2V0UnVsZShjb2RlLCBvcHRpb25zKTtcbiAgICBpZiAoIXJ1bGUpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2hvdWxkVXNlSW50bEFwaSgpKSB7XG4gICAgICByZXR1cm4gcnVsZS5yZXNvbHZlZE9wdGlvbnMoKS5wbHVyYWxDYXRlZ29yaWVzLnNvcnQoKHBsdXJhbENhdGVnb3J5MSwgcGx1cmFsQ2F0ZWdvcnkyKSA9PiBzdWZmaXhlc09yZGVyW3BsdXJhbENhdGVnb3J5MV0gLSBzdWZmaXhlc09yZGVyW3BsdXJhbENhdGVnb3J5Ml0pLm1hcChwbHVyYWxDYXRlZ29yeSA9PiBgJHt0aGlzLm9wdGlvbnMucHJlcGVuZH0ke29wdGlvbnMub3JkaW5hbCA/IGBvcmRpbmFsJHt0aGlzLm9wdGlvbnMucHJlcGVuZH1gIDogJyd9JHtwbHVyYWxDYXRlZ29yeX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1bGUubnVtYmVycy5tYXAobnVtYmVyID0+IHRoaXMuZ2V0U3VmZml4KGNvZGUsIG51bWJlciwgb3B0aW9ucykpO1xuICB9XG4gIGdldFN1ZmZpeChjb2RlLCBjb3VudCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBjb25zdCBydWxlID0gdGhpcy5nZXRSdWxlKGNvZGUsIG9wdGlvbnMpO1xuICAgIGlmIChydWxlKSB7XG4gICAgICBpZiAodGhpcy5zaG91bGRVc2VJbnRsQXBpKCkpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMub3B0aW9ucy5wcmVwZW5kfSR7b3B0aW9ucy5vcmRpbmFsID8gYG9yZGluYWwke3RoaXMub3B0aW9ucy5wcmVwZW5kfWAgOiAnJ30ke3J1bGUuc2VsZWN0KGNvdW50KX1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0U3VmZml4UmV0cm9Db21wYXRpYmxlKHJ1bGUsIGNvdW50KTtcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIud2Fybihgbm8gcGx1cmFsIHJ1bGUgZm91bmQgZm9yOiAke2NvZGV9YCk7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGdldFN1ZmZpeFJldHJvQ29tcGF0aWJsZShydWxlLCBjb3VudCkge1xuICAgIGNvbnN0IGlkeCA9IHJ1bGUubm9BYnMgPyBydWxlLnBsdXJhbHMoY291bnQpIDogcnVsZS5wbHVyYWxzKE1hdGguYWJzKGNvdW50KSk7XG4gICAgbGV0IHN1ZmZpeCA9IHJ1bGUubnVtYmVyc1tpZHhdO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuc2ltcGxpZnlQbHVyYWxTdWZmaXggJiYgcnVsZS5udW1iZXJzLmxlbmd0aCA9PT0gMiAmJiBydWxlLm51bWJlcnNbMF0gPT09IDEpIHtcbiAgICAgIGlmIChzdWZmaXggPT09IDIpIHtcbiAgICAgICAgc3VmZml4ID0gJ3BsdXJhbCc7XG4gICAgICB9IGVsc2UgaWYgKHN1ZmZpeCA9PT0gMSkge1xuICAgICAgICBzdWZmaXggPSAnJztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmV0dXJuU3VmZml4ID0gKCkgPT4gdGhpcy5vcHRpb25zLnByZXBlbmQgJiYgc3VmZml4LnRvU3RyaW5nKCkgPyB0aGlzLm9wdGlvbnMucHJlcGVuZCArIHN1ZmZpeC50b1N0cmluZygpIDogc3VmZml4LnRvU3RyaW5nKCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb21wYXRpYmlsaXR5SlNPTiA9PT0gJ3YxJykge1xuICAgICAgaWYgKHN1ZmZpeCA9PT0gMSkgcmV0dXJuICcnO1xuICAgICAgaWYgKHR5cGVvZiBzdWZmaXggPT09ICdudW1iZXInKSByZXR1cm4gYF9wbHVyYWxfJHtzdWZmaXgudG9TdHJpbmcoKX1gO1xuICAgICAgcmV0dXJuIHJldHVyblN1ZmZpeCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmNvbXBhdGliaWxpdHlKU09OID09PSAndjInKSB7XG4gICAgICByZXR1cm4gcmV0dXJuU3VmZml4KCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc2ltcGxpZnlQbHVyYWxTdWZmaXggJiYgcnVsZS5udW1iZXJzLmxlbmd0aCA9PT0gMiAmJiBydWxlLm51bWJlcnNbMF0gPT09IDEpIHtcbiAgICAgIHJldHVybiByZXR1cm5TdWZmaXgoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wcmVwZW5kICYmIGlkeC50b1N0cmluZygpID8gdGhpcy5vcHRpb25zLnByZXBlbmQgKyBpZHgudG9TdHJpbmcoKSA6IGlkeC50b1N0cmluZygpO1xuICB9XG4gIHNob3VsZFVzZUludGxBcGkoKSB7XG4gICAgcmV0dXJuICFub25JbnRsVmVyc2lvbnMuaW5jbHVkZXModGhpcy5vcHRpb25zLmNvbXBhdGliaWxpdHlKU09OKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWVwRmluZFdpdGhEZWZhdWx0cyhkYXRhLCBkZWZhdWx0RGF0YSwga2V5KSB7XG4gIGxldCBrZXlTZXBhcmF0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6ICcuJztcbiAgbGV0IGlnbm9yZUpTT05TdHJ1Y3R1cmUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRydWU7XG4gIGxldCBwYXRoID0gZ2V0UGF0aFdpdGhEZWZhdWx0cyhkYXRhLCBkZWZhdWx0RGF0YSwga2V5KTtcbiAgaWYgKCFwYXRoICYmIGlnbm9yZUpTT05TdHJ1Y3R1cmUgJiYgdHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXRoID0gZGVlcEZpbmQoZGF0YSwga2V5LCBrZXlTZXBhcmF0b3IpO1xuICAgIGlmIChwYXRoID09PSB1bmRlZmluZWQpIHBhdGggPSBkZWVwRmluZChkZWZhdWx0RGF0YSwga2V5LCBrZXlTZXBhcmF0b3IpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuY2xhc3MgSW50ZXJwb2xhdG9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHRoaXMubG9nZ2VyID0gYmFzZUxvZ2dlci5jcmVhdGUoJ2ludGVycG9sYXRvcicpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5mb3JtYXQgPSBvcHRpb25zLmludGVycG9sYXRpb24gJiYgb3B0aW9ucy5pbnRlcnBvbGF0aW9uLmZvcm1hdCB8fCAodmFsdWUgPT4gdmFsdWUpO1xuICAgIHRoaXMuaW5pdChvcHRpb25zKTtcbiAgfVxuICBpbml0KCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBpZiAoIW9wdGlvbnMuaW50ZXJwb2xhdGlvbikgb3B0aW9ucy5pbnRlcnBvbGF0aW9uID0ge1xuICAgICAgZXNjYXBlVmFsdWU6IHRydWVcbiAgICB9O1xuICAgIGNvbnN0IGlPcHRzID0gb3B0aW9ucy5pbnRlcnBvbGF0aW9uO1xuICAgIHRoaXMuZXNjYXBlID0gaU9wdHMuZXNjYXBlICE9PSB1bmRlZmluZWQgPyBpT3B0cy5lc2NhcGUgOiBlc2NhcGU7XG4gICAgdGhpcy5lc2NhcGVWYWx1ZSA9IGlPcHRzLmVzY2FwZVZhbHVlICE9PSB1bmRlZmluZWQgPyBpT3B0cy5lc2NhcGVWYWx1ZSA6IHRydWU7XG4gICAgdGhpcy51c2VSYXdWYWx1ZVRvRXNjYXBlID0gaU9wdHMudXNlUmF3VmFsdWVUb0VzY2FwZSAhPT0gdW5kZWZpbmVkID8gaU9wdHMudXNlUmF3VmFsdWVUb0VzY2FwZSA6IGZhbHNlO1xuICAgIHRoaXMucHJlZml4ID0gaU9wdHMucHJlZml4ID8gcmVnZXhFc2NhcGUoaU9wdHMucHJlZml4KSA6IGlPcHRzLnByZWZpeEVzY2FwZWQgfHwgJ3t7JztcbiAgICB0aGlzLnN1ZmZpeCA9IGlPcHRzLnN1ZmZpeCA/IHJlZ2V4RXNjYXBlKGlPcHRzLnN1ZmZpeCkgOiBpT3B0cy5zdWZmaXhFc2NhcGVkIHx8ICd9fSc7XG4gICAgdGhpcy5mb3JtYXRTZXBhcmF0b3IgPSBpT3B0cy5mb3JtYXRTZXBhcmF0b3IgPyBpT3B0cy5mb3JtYXRTZXBhcmF0b3IgOiBpT3B0cy5mb3JtYXRTZXBhcmF0b3IgfHwgJywnO1xuICAgIHRoaXMudW5lc2NhcGVQcmVmaXggPSBpT3B0cy51bmVzY2FwZVN1ZmZpeCA/ICcnIDogaU9wdHMudW5lc2NhcGVQcmVmaXggfHwgJy0nO1xuICAgIHRoaXMudW5lc2NhcGVTdWZmaXggPSB0aGlzLnVuZXNjYXBlUHJlZml4ID8gJycgOiBpT3B0cy51bmVzY2FwZVN1ZmZpeCB8fCAnJztcbiAgICB0aGlzLm5lc3RpbmdQcmVmaXggPSBpT3B0cy5uZXN0aW5nUHJlZml4ID8gcmVnZXhFc2NhcGUoaU9wdHMubmVzdGluZ1ByZWZpeCkgOiBpT3B0cy5uZXN0aW5nUHJlZml4RXNjYXBlZCB8fCByZWdleEVzY2FwZSgnJHQoJyk7XG4gICAgdGhpcy5uZXN0aW5nU3VmZml4ID0gaU9wdHMubmVzdGluZ1N1ZmZpeCA/IHJlZ2V4RXNjYXBlKGlPcHRzLm5lc3RpbmdTdWZmaXgpIDogaU9wdHMubmVzdGluZ1N1ZmZpeEVzY2FwZWQgfHwgcmVnZXhFc2NhcGUoJyknKTtcbiAgICB0aGlzLm5lc3RpbmdPcHRpb25zU2VwYXJhdG9yID0gaU9wdHMubmVzdGluZ09wdGlvbnNTZXBhcmF0b3IgPyBpT3B0cy5uZXN0aW5nT3B0aW9uc1NlcGFyYXRvciA6IGlPcHRzLm5lc3RpbmdPcHRpb25zU2VwYXJhdG9yIHx8ICcsJztcbiAgICB0aGlzLm1heFJlcGxhY2VzID0gaU9wdHMubWF4UmVwbGFjZXMgPyBpT3B0cy5tYXhSZXBsYWNlcyA6IDEwMDA7XG4gICAgdGhpcy5hbHdheXNGb3JtYXQgPSBpT3B0cy5hbHdheXNGb3JtYXQgIT09IHVuZGVmaW5lZCA/IGlPcHRzLmFsd2F5c0Zvcm1hdCA6IGZhbHNlO1xuICAgIHRoaXMucmVzZXRSZWdFeHAoKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zKSB0aGlzLmluaXQodGhpcy5vcHRpb25zKTtcbiAgfVxuICByZXNldFJlZ0V4cCgpIHtcbiAgICBjb25zdCByZWdleHBTdHIgPSBgJHt0aGlzLnByZWZpeH0oLis/KSR7dGhpcy5zdWZmaXh9YDtcbiAgICB0aGlzLnJlZ2V4cCA9IG5ldyBSZWdFeHAocmVnZXhwU3RyLCAnZycpO1xuICAgIGNvbnN0IHJlZ2V4cFVuZXNjYXBlU3RyID0gYCR7dGhpcy5wcmVmaXh9JHt0aGlzLnVuZXNjYXBlUHJlZml4fSguKz8pJHt0aGlzLnVuZXNjYXBlU3VmZml4fSR7dGhpcy5zdWZmaXh9YDtcbiAgICB0aGlzLnJlZ2V4cFVuZXNjYXBlID0gbmV3IFJlZ0V4cChyZWdleHBVbmVzY2FwZVN0ciwgJ2cnKTtcbiAgICBjb25zdCBuZXN0aW5nUmVnZXhwU3RyID0gYCR7dGhpcy5uZXN0aW5nUHJlZml4fSguKz8pJHt0aGlzLm5lc3RpbmdTdWZmaXh9YDtcbiAgICB0aGlzLm5lc3RpbmdSZWdleHAgPSBuZXcgUmVnRXhwKG5lc3RpbmdSZWdleHBTdHIsICdnJyk7XG4gIH1cbiAgaW50ZXJwb2xhdGUoc3RyLCBkYXRhLCBsbmcsIG9wdGlvbnMpIHtcbiAgICBsZXQgbWF0Y2g7XG4gICAgbGV0IHZhbHVlO1xuICAgIGxldCByZXBsYWNlcztcbiAgICBjb25zdCBkZWZhdWx0RGF0YSA9IHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbiAmJiB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5kZWZhdWx0VmFyaWFibGVzIHx8IHt9O1xuICAgIGZ1bmN0aW9uIHJlZ2V4U2FmZSh2YWwpIHtcbiAgICAgIHJldHVybiB2YWwucmVwbGFjZSgvXFwkL2csICckJCQkJyk7XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZUZvcm1hdCA9IGtleSA9PiB7XG4gICAgICBpZiAoa2V5LmluZGV4T2YodGhpcy5mb3JtYXRTZXBhcmF0b3IpIDwgMCkge1xuICAgICAgICBjb25zdCBwYXRoID0gZGVlcEZpbmRXaXRoRGVmYXVsdHMoZGF0YSwgZGVmYXVsdERhdGEsIGtleSwgdGhpcy5vcHRpb25zLmtleVNlcGFyYXRvciwgdGhpcy5vcHRpb25zLmlnbm9yZUpTT05TdHJ1Y3R1cmUpO1xuICAgICAgICByZXR1cm4gdGhpcy5hbHdheXNGb3JtYXQgPyB0aGlzLmZvcm1hdChwYXRoLCB1bmRlZmluZWQsIGxuZywge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICBpbnRlcnBvbGF0aW9ua2V5OiBrZXlcbiAgICAgICAgfSkgOiBwYXRoO1xuICAgICAgfVxuICAgICAgY29uc3QgcCA9IGtleS5zcGxpdCh0aGlzLmZvcm1hdFNlcGFyYXRvcik7XG4gICAgICBjb25zdCBrID0gcC5zaGlmdCgpLnRyaW0oKTtcbiAgICAgIGNvbnN0IGYgPSBwLmpvaW4odGhpcy5mb3JtYXRTZXBhcmF0b3IpLnRyaW0oKTtcbiAgICAgIHJldHVybiB0aGlzLmZvcm1hdChkZWVwRmluZFdpdGhEZWZhdWx0cyhkYXRhLCBkZWZhdWx0RGF0YSwgaywgdGhpcy5vcHRpb25zLmtleVNlcGFyYXRvciwgdGhpcy5vcHRpb25zLmlnbm9yZUpTT05TdHJ1Y3R1cmUpLCBmLCBsbmcsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgaW50ZXJwb2xhdGlvbmtleToga1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLnJlc2V0UmVnRXhwKCk7XG4gICAgY29uc3QgbWlzc2luZ0ludGVycG9sYXRpb25IYW5kbGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLm1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlciB8fCB0aGlzLm9wdGlvbnMubWlzc2luZ0ludGVycG9sYXRpb25IYW5kbGVyO1xuICAgIGNvbnN0IHNraXBPblZhcmlhYmxlcyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5pbnRlcnBvbGF0aW9uICYmIG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5za2lwT25WYXJpYWJsZXMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5za2lwT25WYXJpYWJsZXMgOiB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5za2lwT25WYXJpYWJsZXM7XG4gICAgY29uc3QgdG9kb3MgPSBbe1xuICAgICAgcmVnZXg6IHRoaXMucmVnZXhwVW5lc2NhcGUsXG4gICAgICBzYWZlVmFsdWU6IHZhbCA9PiByZWdleFNhZmUodmFsKVxuICAgIH0sIHtcbiAgICAgIHJlZ2V4OiB0aGlzLnJlZ2V4cCxcbiAgICAgIHNhZmVWYWx1ZTogdmFsID0+IHRoaXMuZXNjYXBlVmFsdWUgPyByZWdleFNhZmUodGhpcy5lc2NhcGUodmFsKSkgOiByZWdleFNhZmUodmFsKVxuICAgIH1dO1xuICAgIHRvZG9zLmZvckVhY2godG9kbyA9PiB7XG4gICAgICByZXBsYWNlcyA9IDA7XG4gICAgICB3aGlsZSAobWF0Y2ggPSB0b2RvLnJlZ2V4LmV4ZWMoc3RyKSkge1xuICAgICAgICBjb25zdCBtYXRjaGVkVmFyID0gbWF0Y2hbMV0udHJpbSgpO1xuICAgICAgICB2YWx1ZSA9IGhhbmRsZUZvcm1hdChtYXRjaGVkVmFyKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgdGVtcCA9IG1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlcihzdHIsIG1hdGNoLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHZhbHVlID0gdHlwZW9mIHRlbXAgPT09ICdzdHJpbmcnID8gdGVtcCA6ICcnO1xuICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgbWF0Y2hlZFZhcikpIHtcbiAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgICAgfSBlbHNlIGlmIChza2lwT25WYXJpYWJsZXMpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbWF0Y2hbMF07XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihgbWlzc2VkIHRvIHBhc3MgaW4gdmFyaWFibGUgJHttYXRjaGVkVmFyfSBmb3IgaW50ZXJwb2xhdGluZyAke3N0cn1gKTtcbiAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgJiYgIXRoaXMudXNlUmF3VmFsdWVUb0VzY2FwZSkge1xuICAgICAgICAgIHZhbHVlID0gbWFrZVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2FmZVZhbHVlID0gdG9kby5zYWZlVmFsdWUodmFsdWUpO1xuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShtYXRjaFswXSwgc2FmZVZhbHVlKTtcbiAgICAgICAgaWYgKHNraXBPblZhcmlhYmxlcykge1xuICAgICAgICAgIHRvZG8ucmVnZXgubGFzdEluZGV4ICs9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICB0b2RvLnJlZ2V4Lmxhc3RJbmRleCAtPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9kby5yZWdleC5sYXN0SW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJlcGxhY2VzKys7XG4gICAgICAgIGlmIChyZXBsYWNlcyA+PSB0aGlzLm1heFJlcGxhY2VzKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIG5lc3Qoc3RyLCBmYykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBsZXQgbWF0Y2g7XG4gICAgbGV0IHZhbHVlO1xuICAgIGxldCBjbG9uZWRPcHRpb25zO1xuICAgIGZ1bmN0aW9uIGhhbmRsZUhhc09wdGlvbnMoa2V5LCBpbmhlcml0ZWRPcHRpb25zKSB7XG4gICAgICBjb25zdCBzZXAgPSB0aGlzLm5lc3RpbmdPcHRpb25zU2VwYXJhdG9yO1xuICAgICAgaWYgKGtleS5pbmRleE9mKHNlcCkgPCAwKSByZXR1cm4ga2V5O1xuICAgICAgY29uc3QgYyA9IGtleS5zcGxpdChuZXcgUmVnRXhwKGAke3NlcH1bIF0qe2ApKTtcbiAgICAgIGxldCBvcHRpb25zU3RyaW5nID0gYHske2NbMV19YDtcbiAgICAgIGtleSA9IGNbMF07XG4gICAgICBvcHRpb25zU3RyaW5nID0gdGhpcy5pbnRlcnBvbGF0ZShvcHRpb25zU3RyaW5nLCBjbG9uZWRPcHRpb25zKTtcbiAgICAgIGNvbnN0IG1hdGNoZWRTaW5nbGVRdW90ZXMgPSBvcHRpb25zU3RyaW5nLm1hdGNoKC8nL2cpO1xuICAgICAgY29uc3QgbWF0Y2hlZERvdWJsZVF1b3RlcyA9IG9wdGlvbnNTdHJpbmcubWF0Y2goL1wiL2cpO1xuICAgICAgaWYgKG1hdGNoZWRTaW5nbGVRdW90ZXMgJiYgbWF0Y2hlZFNpbmdsZVF1b3Rlcy5sZW5ndGggJSAyID09PSAwICYmICFtYXRjaGVkRG91YmxlUXVvdGVzIHx8IG1hdGNoZWREb3VibGVRdW90ZXMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICBvcHRpb25zU3RyaW5nID0gb3B0aW9uc1N0cmluZy5yZXBsYWNlKC8nL2csICdcIicpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY2xvbmVkT3B0aW9ucyA9IEpTT04ucGFyc2Uob3B0aW9uc1N0cmluZyk7XG4gICAgICAgIGlmIChpbmhlcml0ZWRPcHRpb25zKSBjbG9uZWRPcHRpb25zID0ge1xuICAgICAgICAgIC4uLmluaGVyaXRlZE9wdGlvbnMsXG4gICAgICAgICAgLi4uY2xvbmVkT3B0aW9uc1xuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBmYWlsZWQgcGFyc2luZyBvcHRpb25zIHN0cmluZyBpbiBuZXN0aW5nIGZvciBrZXkgJHtrZXl9YCwgZSk7XG4gICAgICAgIHJldHVybiBgJHtrZXl9JHtzZXB9JHtvcHRpb25zU3RyaW5nfWA7XG4gICAgICB9XG4gICAgICBkZWxldGUgY2xvbmVkT3B0aW9ucy5kZWZhdWx0VmFsdWU7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICB3aGlsZSAobWF0Y2ggPSB0aGlzLm5lc3RpbmdSZWdleHAuZXhlYyhzdHIpKSB7XG4gICAgICBsZXQgZm9ybWF0dGVycyA9IFtdO1xuICAgICAgY2xvbmVkT3B0aW9ucyA9IHtcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfTtcbiAgICAgIGNsb25lZE9wdGlvbnMgPSBjbG9uZWRPcHRpb25zLnJlcGxhY2UgJiYgdHlwZW9mIGNsb25lZE9wdGlvbnMucmVwbGFjZSAhPT0gJ3N0cmluZycgPyBjbG9uZWRPcHRpb25zLnJlcGxhY2UgOiBjbG9uZWRPcHRpb25zO1xuICAgICAgY2xvbmVkT3B0aW9ucy5hcHBseVBvc3RQcm9jZXNzb3IgPSBmYWxzZTtcbiAgICAgIGRlbGV0ZSBjbG9uZWRPcHRpb25zLmRlZmF1bHRWYWx1ZTtcbiAgICAgIGxldCBkb1JlZHVjZSA9IGZhbHNlO1xuICAgICAgaWYgKG1hdGNoWzBdLmluZGV4T2YodGhpcy5mb3JtYXRTZXBhcmF0b3IpICE9PSAtMSAmJiAhL3suKn0vLnRlc3QobWF0Y2hbMV0pKSB7XG4gICAgICAgIGNvbnN0IHIgPSBtYXRjaFsxXS5zcGxpdCh0aGlzLmZvcm1hdFNlcGFyYXRvcikubWFwKGVsZW0gPT4gZWxlbS50cmltKCkpO1xuICAgICAgICBtYXRjaFsxXSA9IHIuc2hpZnQoKTtcbiAgICAgICAgZm9ybWF0dGVycyA9IHI7XG4gICAgICAgIGRvUmVkdWNlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gZmMoaGFuZGxlSGFzT3B0aW9ucy5jYWxsKHRoaXMsIG1hdGNoWzFdLnRyaW0oKSwgY2xvbmVkT3B0aW9ucyksIGNsb25lZE9wdGlvbnMpO1xuICAgICAgaWYgKHZhbHVlICYmIG1hdGNoWzBdID09PSBzdHIgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykgcmV0dXJuIHZhbHVlO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHZhbHVlID0gbWFrZVN0cmluZyh2YWx1ZSk7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYG1pc3NlZCB0byByZXNvbHZlICR7bWF0Y2hbMV19IGZvciBuZXN0aW5nICR7c3RyfWApO1xuICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgfVxuICAgICAgaWYgKGRvUmVkdWNlKSB7XG4gICAgICAgIHZhbHVlID0gZm9ybWF0dGVycy5yZWR1Y2UoKHYsIGYpID0+IHRoaXMuZm9ybWF0KHYsIGYsIG9wdGlvbnMubG5nLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICBpbnRlcnBvbGF0aW9ua2V5OiBtYXRjaFsxXS50cmltKClcbiAgICAgICAgfSksIHZhbHVlLnRyaW0oKSk7XG4gICAgICB9XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZShtYXRjaFswXSwgdmFsdWUpO1xuICAgICAgdGhpcy5yZWdleHAubGFzdEluZGV4ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZUZvcm1hdFN0cihmb3JtYXRTdHIpIHtcbiAgbGV0IGZvcm1hdE5hbWUgPSBmb3JtYXRTdHIudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gIGNvbnN0IGZvcm1hdE9wdGlvbnMgPSB7fTtcbiAgaWYgKGZvcm1hdFN0ci5pbmRleE9mKCcoJykgPiAtMSkge1xuICAgIGNvbnN0IHAgPSBmb3JtYXRTdHIuc3BsaXQoJygnKTtcbiAgICBmb3JtYXROYW1lID0gcFswXS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICBjb25zdCBvcHRTdHIgPSBwWzFdLnN1YnN0cmluZygwLCBwWzFdLmxlbmd0aCAtIDEpO1xuICAgIGlmIChmb3JtYXROYW1lID09PSAnY3VycmVuY3knICYmIG9wdFN0ci5pbmRleE9mKCc6JykgPCAwKSB7XG4gICAgICBpZiAoIWZvcm1hdE9wdGlvbnMuY3VycmVuY3kpIGZvcm1hdE9wdGlvbnMuY3VycmVuY3kgPSBvcHRTdHIudHJpbSgpO1xuICAgIH0gZWxzZSBpZiAoZm9ybWF0TmFtZSA9PT0gJ3JlbGF0aXZldGltZScgJiYgb3B0U3RyLmluZGV4T2YoJzonKSA8IDApIHtcbiAgICAgIGlmICghZm9ybWF0T3B0aW9ucy5yYW5nZSkgZm9ybWF0T3B0aW9ucy5yYW5nZSA9IG9wdFN0ci50cmltKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9wdHMgPSBvcHRTdHIuc3BsaXQoJzsnKTtcbiAgICAgIG9wdHMuZm9yRWFjaChvcHQgPT4ge1xuICAgICAgICBpZiAoIW9wdCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IG9wdC5zcGxpdCgnOicpO1xuICAgICAgICBjb25zdCB2YWwgPSByZXN0LmpvaW4oJzonKS50cmltKCkucmVwbGFjZSgvXicrfCcrJC9nLCAnJyk7XG4gICAgICAgIGlmICghZm9ybWF0T3B0aW9uc1trZXkudHJpbSgpXSkgZm9ybWF0T3B0aW9uc1trZXkudHJpbSgpXSA9IHZhbDtcbiAgICAgICAgaWYgKHZhbCA9PT0gJ2ZhbHNlJykgZm9ybWF0T3B0aW9uc1trZXkudHJpbSgpXSA9IGZhbHNlO1xuICAgICAgICBpZiAodmFsID09PSAndHJ1ZScpIGZvcm1hdE9wdGlvbnNba2V5LnRyaW0oKV0gPSB0cnVlO1xuICAgICAgICBpZiAoIWlzTmFOKHZhbCkpIGZvcm1hdE9wdGlvbnNba2V5LnRyaW0oKV0gPSBwYXJzZUludCh2YWwsIDEwKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGZvcm1hdE5hbWUsXG4gICAgZm9ybWF0T3B0aW9uc1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVkRm9ybWF0dGVyKGZuKSB7XG4gIGNvbnN0IGNhY2hlID0ge307XG4gIHJldHVybiBmdW5jdGlvbiBpbnZva2VGb3JtYXR0ZXIodmFsLCBsbmcsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBrZXkgPSBsbmcgKyBKU09OLnN0cmluZ2lmeShvcHRpb25zKTtcbiAgICBsZXQgZm9ybWF0dGVyID0gY2FjaGVba2V5XTtcbiAgICBpZiAoIWZvcm1hdHRlcikge1xuICAgICAgZm9ybWF0dGVyID0gZm4oZ2V0Q2xlYW5lZENvZGUobG5nKSwgb3B0aW9ucyk7XG4gICAgICBjYWNoZVtrZXldID0gZm9ybWF0dGVyO1xuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0dGVyKHZhbCk7XG4gIH07XG59XG5jbGFzcyBGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyLmNyZWF0ZSgnZm9ybWF0dGVyJyk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmZvcm1hdHMgPSB7XG4gICAgICBudW1iZXI6IGNyZWF0ZUNhY2hlZEZvcm1hdHRlcigobG5nLCBvcHQpID0+IHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxuZywge1xuICAgICAgICAgIC4uLm9wdFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PiBmb3JtYXR0ZXIuZm9ybWF0KHZhbCk7XG4gICAgICB9KSxcbiAgICAgIGN1cnJlbmN5OiBjcmVhdGVDYWNoZWRGb3JtYXR0ZXIoKGxuZywgb3B0KSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsbmcsIHtcbiAgICAgICAgICAuLi5vcHQsXG4gICAgICAgICAgc3R5bGU6ICdjdXJyZW5jeSdcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWwgPT4gZm9ybWF0dGVyLmZvcm1hdCh2YWwpO1xuICAgICAgfSksXG4gICAgICBkYXRldGltZTogY3JlYXRlQ2FjaGVkRm9ybWF0dGVyKChsbmcsIG9wdCkgPT4ge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsbmcsIHtcbiAgICAgICAgICAuLi5vcHRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWwgPT4gZm9ybWF0dGVyLmZvcm1hdCh2YWwpO1xuICAgICAgfSksXG4gICAgICByZWxhdGl2ZXRpbWU6IGNyZWF0ZUNhY2hlZEZvcm1hdHRlcigobG5nLCBvcHQpID0+IHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEludGwuUmVsYXRpdmVUaW1lRm9ybWF0KGxuZywge1xuICAgICAgICAgIC4uLm9wdFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PiBmb3JtYXR0ZXIuZm9ybWF0KHZhbCwgb3B0LnJhbmdlIHx8ICdkYXknKTtcbiAgICAgIH0pLFxuICAgICAgbGlzdDogY3JlYXRlQ2FjaGVkRm9ybWF0dGVyKChsbmcsIG9wdCkgPT4ge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5MaXN0Rm9ybWF0KGxuZywge1xuICAgICAgICAgIC4uLm9wdFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PiBmb3JtYXR0ZXIuZm9ybWF0KHZhbCk7XG4gICAgICB9KVxuICAgIH07XG4gICAgdGhpcy5pbml0KG9wdGlvbnMpO1xuICB9XG4gIGluaXQoc2VydmljZXMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge1xuICAgICAgaW50ZXJwb2xhdGlvbjoge31cbiAgICB9O1xuICAgIGNvbnN0IGlPcHRzID0gb3B0aW9ucy5pbnRlcnBvbGF0aW9uO1xuICAgIHRoaXMuZm9ybWF0U2VwYXJhdG9yID0gaU9wdHMuZm9ybWF0U2VwYXJhdG9yID8gaU9wdHMuZm9ybWF0U2VwYXJhdG9yIDogaU9wdHMuZm9ybWF0U2VwYXJhdG9yIHx8ICcsJztcbiAgfVxuICBhZGQobmFtZSwgZmMpIHtcbiAgICB0aGlzLmZvcm1hdHNbbmFtZS50b0xvd2VyQ2FzZSgpLnRyaW0oKV0gPSBmYztcbiAgfVxuICBhZGRDYWNoZWQobmFtZSwgZmMpIHtcbiAgICB0aGlzLmZvcm1hdHNbbmFtZS50b0xvd2VyQ2FzZSgpLnRyaW0oKV0gPSBjcmVhdGVDYWNoZWRGb3JtYXR0ZXIoZmMpO1xuICB9XG4gIGZvcm1hdCh2YWx1ZSwgZm9ybWF0LCBsbmcpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gICAgY29uc3QgZm9ybWF0cyA9IGZvcm1hdC5zcGxpdCh0aGlzLmZvcm1hdFNlcGFyYXRvcik7XG4gICAgY29uc3QgcmVzdWx0ID0gZm9ybWF0cy5yZWR1Y2UoKG1lbSwgZikgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmb3JtYXROYW1lLFxuICAgICAgICBmb3JtYXRPcHRpb25zXG4gICAgICB9ID0gcGFyc2VGb3JtYXRTdHIoZik7XG4gICAgICBpZiAodGhpcy5mb3JtYXRzW2Zvcm1hdE5hbWVdKSB7XG4gICAgICAgIGxldCBmb3JtYXR0ZWQgPSBtZW07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgdmFsT3B0aW9ucyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5mb3JtYXRQYXJhbXMgJiYgb3B0aW9ucy5mb3JtYXRQYXJhbXNbb3B0aW9ucy5pbnRlcnBvbGF0aW9ua2V5XSB8fCB7fTtcbiAgICAgICAgICBjb25zdCBsID0gdmFsT3B0aW9ucy5sb2NhbGUgfHwgdmFsT3B0aW9ucy5sbmcgfHwgb3B0aW9ucy5sb2NhbGUgfHwgb3B0aW9ucy5sbmcgfHwgbG5nO1xuICAgICAgICAgIGZvcm1hdHRlZCA9IHRoaXMuZm9ybWF0c1tmb3JtYXROYW1lXShtZW0sIGwsIHtcbiAgICAgICAgICAgIC4uLmZvcm1hdE9wdGlvbnMsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgLi4udmFsT3B0aW9uc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGB0aGVyZSB3YXMgbm8gZm9ybWF0IGZ1bmN0aW9uIGZvciAke2Zvcm1hdE5hbWV9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtO1xuICAgIH0sIHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVBlbmRpbmcocSwgbmFtZSkge1xuICBpZiAocS5wZW5kaW5nW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZWxldGUgcS5wZW5kaW5nW25hbWVdO1xuICAgIHEucGVuZGluZ0NvdW50LS07XG4gIH1cbn1cbmNsYXNzIENvbm5lY3RvciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKGJhY2tlbmQsIHN0b3JlLCBzZXJ2aWNlcykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYmFja2VuZCA9IGJhY2tlbmQ7XG4gICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xuICAgIHRoaXMuc2VydmljZXMgPSBzZXJ2aWNlcztcbiAgICB0aGlzLmxhbmd1YWdlVXRpbHMgPSBzZXJ2aWNlcy5sYW5ndWFnZVV0aWxzO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyLmNyZWF0ZSgnYmFja2VuZENvbm5lY3RvcicpO1xuICAgIHRoaXMud2FpdGluZ1JlYWRzID0gW107XG4gICAgdGhpcy5tYXhQYXJhbGxlbFJlYWRzID0gb3B0aW9ucy5tYXhQYXJhbGxlbFJlYWRzIHx8IDEwO1xuICAgIHRoaXMucmVhZGluZ0NhbGxzID0gMDtcbiAgICB0aGlzLm1heFJldHJpZXMgPSBvcHRpb25zLm1heFJldHJpZXMgPj0gMCA/IG9wdGlvbnMubWF4UmV0cmllcyA6IDU7XG4gICAgdGhpcy5yZXRyeVRpbWVvdXQgPSBvcHRpb25zLnJldHJ5VGltZW91dCA+PSAxID8gb3B0aW9ucy5yZXRyeVRpbWVvdXQgOiAzNTA7XG4gICAgdGhpcy5zdGF0ZSA9IHt9O1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICBpZiAodGhpcy5iYWNrZW5kICYmIHRoaXMuYmFja2VuZC5pbml0KSB7XG4gICAgICB0aGlzLmJhY2tlbmQuaW5pdChzZXJ2aWNlcywgb3B0aW9ucy5iYWNrZW5kLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgcXVldWVMb2FkKGxhbmd1YWdlcywgbmFtZXNwYWNlcywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBjb25zdCB0b0xvYWQgPSB7fTtcbiAgICBjb25zdCBwZW5kaW5nID0ge307XG4gICAgY29uc3QgdG9Mb2FkTGFuZ3VhZ2VzID0ge307XG4gICAgY29uc3QgdG9Mb2FkTmFtZXNwYWNlcyA9IHt9O1xuICAgIGxhbmd1YWdlcy5mb3JFYWNoKGxuZyA9PiB7XG4gICAgICBsZXQgaGFzQWxsTmFtZXNwYWNlcyA9IHRydWU7XG4gICAgICBuYW1lc3BhY2VzLmZvckVhY2gobnMgPT4ge1xuICAgICAgICBjb25zdCBuYW1lID0gYCR7bG5nfXwke25zfWA7XG4gICAgICAgIGlmICghb3B0aW9ucy5yZWxvYWQgJiYgdGhpcy5zdG9yZS5oYXNSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSkge1xuICAgICAgICAgIHRoaXMuc3RhdGVbbmFtZV0gPSAyO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGVbbmFtZV0gPCAwKSA7IGVsc2UgaWYgKHRoaXMuc3RhdGVbbmFtZV0gPT09IDEpIHtcbiAgICAgICAgICBpZiAocGVuZGluZ1tuYW1lXSA9PT0gdW5kZWZpbmVkKSBwZW5kaW5nW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXRlW25hbWVdID0gMTtcbiAgICAgICAgICBoYXNBbGxOYW1lc3BhY2VzID0gZmFsc2U7XG4gICAgICAgICAgaWYgKHBlbmRpbmdbbmFtZV0gPT09IHVuZGVmaW5lZCkgcGVuZGluZ1tuYW1lXSA9IHRydWU7XG4gICAgICAgICAgaWYgKHRvTG9hZFtuYW1lXSA9PT0gdW5kZWZpbmVkKSB0b0xvYWRbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgIGlmICh0b0xvYWROYW1lc3BhY2VzW25zXSA9PT0gdW5kZWZpbmVkKSB0b0xvYWROYW1lc3BhY2VzW25zXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFoYXNBbGxOYW1lc3BhY2VzKSB0b0xvYWRMYW5ndWFnZXNbbG5nXSA9IHRydWU7XG4gICAgfSk7XG4gICAgaWYgKE9iamVjdC5rZXlzKHRvTG9hZCkubGVuZ3RoIHx8IE9iamVjdC5rZXlzKHBlbmRpbmcpLmxlbmd0aCkge1xuICAgICAgdGhpcy5xdWV1ZS5wdXNoKHtcbiAgICAgICAgcGVuZGluZyxcbiAgICAgICAgcGVuZGluZ0NvdW50OiBPYmplY3Qua2V5cyhwZW5kaW5nKS5sZW5ndGgsXG4gICAgICAgIGxvYWRlZDoge30sXG4gICAgICAgIGVycm9yczogW10sXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvTG9hZDogT2JqZWN0LmtleXModG9Mb2FkKSxcbiAgICAgIHBlbmRpbmc6IE9iamVjdC5rZXlzKHBlbmRpbmcpLFxuICAgICAgdG9Mb2FkTGFuZ3VhZ2VzOiBPYmplY3Qua2V5cyh0b0xvYWRMYW5ndWFnZXMpLFxuICAgICAgdG9Mb2FkTmFtZXNwYWNlczogT2JqZWN0LmtleXModG9Mb2FkTmFtZXNwYWNlcylcbiAgICB9O1xuICB9XG4gIGxvYWRlZChuYW1lLCBlcnIsIGRhdGEpIHtcbiAgICBjb25zdCBzID0gbmFtZS5zcGxpdCgnfCcpO1xuICAgIGNvbnN0IGxuZyA9IHNbMF07XG4gICAgY29uc3QgbnMgPSBzWzFdO1xuICAgIGlmIChlcnIpIHRoaXMuZW1pdCgnZmFpbGVkTG9hZGluZycsIGxuZywgbnMsIGVycik7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMuc3RvcmUuYWRkUmVzb3VyY2VCdW5kbGUobG5nLCBucywgZGF0YSk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGVbbmFtZV0gPSBlcnIgPyAtMSA6IDI7XG4gICAgY29uc3QgbG9hZGVkID0ge307XG4gICAgdGhpcy5xdWV1ZS5mb3JFYWNoKHEgPT4ge1xuICAgICAgcHVzaFBhdGgocS5sb2FkZWQsIFtsbmddLCBucyk7XG4gICAgICByZW1vdmVQZW5kaW5nKHEsIG5hbWUpO1xuICAgICAgaWYgKGVycikgcS5lcnJvcnMucHVzaChlcnIpO1xuICAgICAgaWYgKHEucGVuZGluZ0NvdW50ID09PSAwICYmICFxLmRvbmUpIHtcbiAgICAgICAgT2JqZWN0LmtleXMocS5sb2FkZWQpLmZvckVhY2gobCA9PiB7XG4gICAgICAgICAgaWYgKCFsb2FkZWRbbF0pIGxvYWRlZFtsXSA9IHt9O1xuICAgICAgICAgIGNvbnN0IGxvYWRlZEtleXMgPSBxLmxvYWRlZFtsXTtcbiAgICAgICAgICBpZiAobG9hZGVkS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvYWRlZEtleXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgICAgaWYgKGxvYWRlZFtsXVtuXSA9PT0gdW5kZWZpbmVkKSBsb2FkZWRbbF1bbl0gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcS5kb25lID0gdHJ1ZTtcbiAgICAgICAgaWYgKHEuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgIHEuY2FsbGJhY2socS5lcnJvcnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHEuY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZW1pdCgnbG9hZGVkJywgbG9hZGVkKTtcbiAgICB0aGlzLnF1ZXVlID0gdGhpcy5xdWV1ZS5maWx0ZXIocSA9PiAhcS5kb25lKTtcbiAgfVxuICByZWFkKGxuZywgbnMsIGZjTmFtZSkge1xuICAgIGxldCB0cmllZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMDtcbiAgICBsZXQgd2FpdCA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogdGhpcy5yZXRyeVRpbWVvdXQ7XG4gICAgbGV0IGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgPyBhcmd1bWVudHNbNV0gOiB1bmRlZmluZWQ7XG4gICAgaWYgKCFsbmcubGVuZ3RoKSByZXR1cm4gY2FsbGJhY2sobnVsbCwge30pO1xuICAgIGlmICh0aGlzLnJlYWRpbmdDYWxscyA+PSB0aGlzLm1heFBhcmFsbGVsUmVhZHMpIHtcbiAgICAgIHRoaXMud2FpdGluZ1JlYWRzLnB1c2goe1xuICAgICAgICBsbmcsXG4gICAgICAgIG5zLFxuICAgICAgICBmY05hbWUsXG4gICAgICAgIHRyaWVkLFxuICAgICAgICB3YWl0LFxuICAgICAgICBjYWxsYmFja1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVhZGluZ0NhbGxzKys7XG4gICAgY29uc3QgcmVzb2x2ZXIgPSAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICB0aGlzLnJlYWRpbmdDYWxscy0tO1xuICAgICAgaWYgKHRoaXMud2FpdGluZ1JlYWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMud2FpdGluZ1JlYWRzLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMucmVhZChuZXh0LmxuZywgbmV4dC5ucywgbmV4dC5mY05hbWUsIG5leHQudHJpZWQsIG5leHQud2FpdCwgbmV4dC5jYWxsYmFjayk7XG4gICAgICB9XG4gICAgICBpZiAoZXJyICYmIGRhdGEgJiYgdHJpZWQgPCB0aGlzLm1heFJldHJpZXMpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZWFkLmNhbGwodGhpcywgbG5nLCBucywgZmNOYW1lLCB0cmllZCArIDEsIHdhaXQgKiAyLCBjYWxsYmFjayk7XG4gICAgICAgIH0sIHdhaXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhlcnIsIGRhdGEpO1xuICAgIH07XG4gICAgY29uc3QgZmMgPSB0aGlzLmJhY2tlbmRbZmNOYW1lXS5iaW5kKHRoaXMuYmFja2VuZCk7XG4gICAgaWYgKGZjLmxlbmd0aCA9PT0gMikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgciA9IGZjKGxuZywgbnMpO1xuICAgICAgICBpZiAociAmJiB0eXBlb2Ygci50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgci50aGVuKGRhdGEgPT4gcmVzb2x2ZXIobnVsbCwgZGF0YSkpLmNhdGNoKHJlc29sdmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlcihudWxsLCByKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlc29sdmVyKGVycik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBmYyhsbmcsIG5zLCByZXNvbHZlcik7XG4gIH1cbiAgcHJlcGFyZUxvYWRpbmcobGFuZ3VhZ2VzLCBuYW1lc3BhY2VzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGxldCBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICAgIGlmICghdGhpcy5iYWNrZW5kKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdObyBiYWNrZW5kIHdhcyBhZGRlZCB2aWEgaTE4bmV4dC51c2UuIFdpbGwgbm90IGxvYWQgcmVzb3VyY2VzLicpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbGFuZ3VhZ2VzID09PSAnc3RyaW5nJykgbGFuZ3VhZ2VzID0gdGhpcy5sYW5ndWFnZVV0aWxzLnRvUmVzb2x2ZUhpZXJhcmNoeShsYW5ndWFnZXMpO1xuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycpIG5hbWVzcGFjZXMgPSBbbmFtZXNwYWNlc107XG4gICAgY29uc3QgdG9Mb2FkID0gdGhpcy5xdWV1ZUxvYWQobGFuZ3VhZ2VzLCBuYW1lc3BhY2VzLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgaWYgKCF0b0xvYWQudG9Mb2FkLmxlbmd0aCkge1xuICAgICAgaWYgKCF0b0xvYWQucGVuZGluZy5sZW5ndGgpIGNhbGxiYWNrKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdG9Mb2FkLnRvTG9hZC5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgdGhpcy5sb2FkT25lKG5hbWUpO1xuICAgIH0pO1xuICB9XG4gIGxvYWQobGFuZ3VhZ2VzLCBuYW1lc3BhY2VzLCBjYWxsYmFjaykge1xuICAgIHRoaXMucHJlcGFyZUxvYWRpbmcobGFuZ3VhZ2VzLCBuYW1lc3BhY2VzLCB7fSwgY2FsbGJhY2spO1xuICB9XG4gIHJlbG9hZChsYW5ndWFnZXMsIG5hbWVzcGFjZXMsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5wcmVwYXJlTG9hZGluZyhsYW5ndWFnZXMsIG5hbWVzcGFjZXMsIHtcbiAgICAgIHJlbG9hZDogdHJ1ZVxuICAgIH0sIGNhbGxiYWNrKTtcbiAgfVxuICBsb2FkT25lKG5hbWUpIHtcbiAgICBsZXQgcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJztcbiAgICBjb25zdCBzID0gbmFtZS5zcGxpdCgnfCcpO1xuICAgIGNvbnN0IGxuZyA9IHNbMF07XG4gICAgY29uc3QgbnMgPSBzWzFdO1xuICAgIHRoaXMucmVhZChsbmcsIG5zLCAncmVhZCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICBpZiAoZXJyKSB0aGlzLmxvZ2dlci53YXJuKGAke3ByZWZpeH1sb2FkaW5nIG5hbWVzcGFjZSAke25zfSBmb3IgbGFuZ3VhZ2UgJHtsbmd9IGZhaWxlZGAsIGVycik7XG4gICAgICBpZiAoIWVyciAmJiBkYXRhKSB0aGlzLmxvZ2dlci5sb2coYCR7cHJlZml4fWxvYWRlZCBuYW1lc3BhY2UgJHtuc30gZm9yIGxhbmd1YWdlICR7bG5nfWAsIGRhdGEpO1xuICAgICAgdGhpcy5sb2FkZWQobmFtZSwgZXJyLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuICBzYXZlTWlzc2luZyhsYW5ndWFnZXMsIG5hbWVzcGFjZSwga2V5LCBmYWxsYmFja1ZhbHVlLCBpc1VwZGF0ZSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB7fTtcbiAgICBsZXQgY2xiID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiAoKSA9PiB7fTtcbiAgICBpZiAodGhpcy5zZXJ2aWNlcy51dGlscyAmJiB0aGlzLnNlcnZpY2VzLnV0aWxzLmhhc0xvYWRlZE5hbWVzcGFjZSAmJiAhdGhpcy5zZXJ2aWNlcy51dGlscy5oYXNMb2FkZWROYW1lc3BhY2UobmFtZXNwYWNlKSkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihgZGlkIG5vdCBzYXZlIGtleSBcIiR7a2V5fVwiIGFzIHRoZSBuYW1lc3BhY2UgXCIke25hbWVzcGFjZX1cIiB3YXMgbm90IHlldCBsb2FkZWRgLCAnVGhpcyBtZWFucyBzb21ldGhpbmcgSVMgV1JPTkcgaW4geW91ciBzZXR1cC4gWW91IGFjY2VzcyB0aGUgdCBmdW5jdGlvbiBiZWZvcmUgaTE4bmV4dC5pbml0IC8gaTE4bmV4dC5sb2FkTmFtZXNwYWNlIC8gaTE4bmV4dC5jaGFuZ2VMYW5ndWFnZSB3YXMgZG9uZS4gV2FpdCBmb3IgdGhlIGNhbGxiYWNrIG9yIFByb21pc2UgdG8gcmVzb2x2ZSBiZWZvcmUgYWNjZXNzaW5nIGl0ISEhJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCB8fCBrZXkgPT09IG51bGwgfHwga2V5ID09PSAnJykgcmV0dXJuO1xuICAgIGlmICh0aGlzLmJhY2tlbmQgJiYgdGhpcy5iYWNrZW5kLmNyZWF0ZSkge1xuICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgaXNVcGRhdGVcbiAgICAgIH07XG4gICAgICBjb25zdCBmYyA9IHRoaXMuYmFja2VuZC5jcmVhdGUuYmluZCh0aGlzLmJhY2tlbmQpO1xuICAgICAgaWYgKGZjLmxlbmd0aCA8IDYpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgcjtcbiAgICAgICAgICBpZiAoZmMubGVuZ3RoID09PSA1KSB7XG4gICAgICAgICAgICByID0gZmMobGFuZ3VhZ2VzLCBuYW1lc3BhY2UsIGtleSwgZmFsbGJhY2tWYWx1ZSwgb3B0cyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHIgPSBmYyhsYW5ndWFnZXMsIG5hbWVzcGFjZSwga2V5LCBmYWxsYmFja1ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHIgJiYgdHlwZW9mIHIudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgci50aGVuKGRhdGEgPT4gY2xiKG51bGwsIGRhdGEpKS5jYXRjaChjbGIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGIobnVsbCwgcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjbGIoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmMobGFuZ3VhZ2VzLCBuYW1lc3BhY2UsIGtleSwgZmFsbGJhY2tWYWx1ZSwgY2xiLCBvcHRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFsYW5ndWFnZXMgfHwgIWxhbmd1YWdlc1swXSkgcmV0dXJuO1xuICAgIHRoaXMuc3RvcmUuYWRkUmVzb3VyY2UobGFuZ3VhZ2VzWzBdLCBuYW1lc3BhY2UsIGtleSwgZmFsbGJhY2tWYWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0KCkge1xuICByZXR1cm4ge1xuICAgIGRlYnVnOiBmYWxzZSxcbiAgICBpbml0SW1tZWRpYXRlOiB0cnVlLFxuICAgIG5zOiBbJ3RyYW5zbGF0aW9uJ10sXG4gICAgZGVmYXVsdE5TOiBbJ3RyYW5zbGF0aW9uJ10sXG4gICAgZmFsbGJhY2tMbmc6IFsnZGV2J10sXG4gICAgZmFsbGJhY2tOUzogZmFsc2UsXG4gICAgc3VwcG9ydGVkTG5nczogZmFsc2UsXG4gICAgbm9uRXhwbGljaXRTdXBwb3J0ZWRMbmdzOiBmYWxzZSxcbiAgICBsb2FkOiAnYWxsJyxcbiAgICBwcmVsb2FkOiBmYWxzZSxcbiAgICBzaW1wbGlmeVBsdXJhbFN1ZmZpeDogdHJ1ZSxcbiAgICBrZXlTZXBhcmF0b3I6ICcuJyxcbiAgICBuc1NlcGFyYXRvcjogJzonLFxuICAgIHBsdXJhbFNlcGFyYXRvcjogJ18nLFxuICAgIGNvbnRleHRTZXBhcmF0b3I6ICdfJyxcbiAgICBwYXJ0aWFsQnVuZGxlZExhbmd1YWdlczogZmFsc2UsXG4gICAgc2F2ZU1pc3Npbmc6IGZhbHNlLFxuICAgIHVwZGF0ZU1pc3Npbmc6IGZhbHNlLFxuICAgIHNhdmVNaXNzaW5nVG86ICdmYWxsYmFjaycsXG4gICAgc2F2ZU1pc3NpbmdQbHVyYWxzOiB0cnVlLFxuICAgIG1pc3NpbmdLZXlIYW5kbGVyOiBmYWxzZSxcbiAgICBtaXNzaW5nSW50ZXJwb2xhdGlvbkhhbmRsZXI6IGZhbHNlLFxuICAgIHBvc3RQcm9jZXNzOiBmYWxzZSxcbiAgICBwb3N0UHJvY2Vzc1Bhc3NSZXNvbHZlZDogZmFsc2UsXG4gICAgcmV0dXJuTnVsbDogZmFsc2UsXG4gICAgcmV0dXJuRW1wdHlTdHJpbmc6IHRydWUsXG4gICAgcmV0dXJuT2JqZWN0czogZmFsc2UsXG4gICAgam9pbkFycmF5czogZmFsc2UsXG4gICAgcmV0dXJuZWRPYmplY3RIYW5kbGVyOiBmYWxzZSxcbiAgICBwYXJzZU1pc3NpbmdLZXlIYW5kbGVyOiBmYWxzZSxcbiAgICBhcHBlbmROYW1lc3BhY2VUb01pc3NpbmdLZXk6IGZhbHNlLFxuICAgIGFwcGVuZE5hbWVzcGFjZVRvQ0lNb2RlOiBmYWxzZSxcbiAgICBvdmVybG9hZFRyYW5zbGF0aW9uT3B0aW9uSGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlKGFyZ3MpIHtcbiAgICAgIGxldCByZXQgPSB7fTtcbiAgICAgIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gJ29iamVjdCcpIHJldCA9IGFyZ3NbMV07XG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMV0gPT09ICdzdHJpbmcnKSByZXQuZGVmYXVsdFZhbHVlID0gYXJnc1sxXTtcbiAgICAgIGlmICh0eXBlb2YgYXJnc1syXSA9PT0gJ3N0cmluZycpIHJldC50RGVzY3JpcHRpb24gPSBhcmdzWzJdO1xuICAgICAgaWYgKHR5cGVvZiBhcmdzWzJdID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgYXJnc1szXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGFyZ3NbM10gfHwgYXJnc1syXTtcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgIHJldFtrZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcbiAgICBpbnRlcnBvbGF0aW9uOiB7XG4gICAgICBlc2NhcGVWYWx1ZTogdHJ1ZSxcbiAgICAgIGZvcm1hdDogdmFsdWUgPT4gdmFsdWUsXG4gICAgICBwcmVmaXg6ICd7eycsXG4gICAgICBzdWZmaXg6ICd9fScsXG4gICAgICBmb3JtYXRTZXBhcmF0b3I6ICcsJyxcbiAgICAgIHVuZXNjYXBlUHJlZml4OiAnLScsXG4gICAgICBuZXN0aW5nUHJlZml4OiAnJHQoJyxcbiAgICAgIG5lc3RpbmdTdWZmaXg6ICcpJyxcbiAgICAgIG5lc3RpbmdPcHRpb25zU2VwYXJhdG9yOiAnLCcsXG4gICAgICBtYXhSZXBsYWNlczogMTAwMCxcbiAgICAgIHNraXBPblZhcmlhYmxlczogdHJ1ZVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybU9wdGlvbnMob3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMubnMgPT09ICdzdHJpbmcnKSBvcHRpb25zLm5zID0gW29wdGlvbnMubnNdO1xuICBpZiAodHlwZW9mIG9wdGlvbnMuZmFsbGJhY2tMbmcgPT09ICdzdHJpbmcnKSBvcHRpb25zLmZhbGxiYWNrTG5nID0gW29wdGlvbnMuZmFsbGJhY2tMbmddO1xuICBpZiAodHlwZW9mIG9wdGlvbnMuZmFsbGJhY2tOUyA9PT0gJ3N0cmluZycpIG9wdGlvbnMuZmFsbGJhY2tOUyA9IFtvcHRpb25zLmZhbGxiYWNrTlNdO1xuICBpZiAob3B0aW9ucy5zdXBwb3J0ZWRMbmdzICYmIG9wdGlvbnMuc3VwcG9ydGVkTG5ncy5pbmRleE9mKCdjaW1vZGUnKSA8IDApIHtcbiAgICBvcHRpb25zLnN1cHBvcnRlZExuZ3MgPSBvcHRpb25zLnN1cHBvcnRlZExuZ3MuY29uY2F0KFsnY2ltb2RlJ10pO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cbmZ1bmN0aW9uIGJpbmRNZW1iZXJGdW5jdGlvbnMoaW5zdCkge1xuICBjb25zdCBtZW1zID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoT2JqZWN0LmdldFByb3RvdHlwZU9mKGluc3QpKTtcbiAgbWVtcy5mb3JFYWNoKG1lbSA9PiB7XG4gICAgaWYgKHR5cGVvZiBpbnN0W21lbV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluc3RbbWVtXSA9IGluc3RbbWVtXS5iaW5kKGluc3QpO1xuICAgIH1cbiAgfSk7XG59XG5jbGFzcyBJMThuIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGxldCBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gdHJhbnNmb3JtT3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLnNlcnZpY2VzID0ge307XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyO1xuICAgIHRoaXMubW9kdWxlcyA9IHtcbiAgICAgIGV4dGVybmFsOiBbXVxuICAgIH07XG4gICAgYmluZE1lbWJlckZ1bmN0aW9ucyh0aGlzKTtcbiAgICBpZiAoY2FsbGJhY2sgJiYgIXRoaXMuaXNJbml0aWFsaXplZCAmJiAhb3B0aW9ucy5pc0Nsb25lKSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5pbml0SW1tZWRpYXRlKSB7XG4gICAgICAgIHRoaXMuaW5pdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuaW5pdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH1cbiAgaW5pdCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBsZXQgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLmRlZmF1bHROUyAmJiBvcHRpb25zLmRlZmF1bHROUyAhPT0gZmFsc2UgJiYgb3B0aW9ucy5ucykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm5zID09PSAnc3RyaW5nJykge1xuICAgICAgICBvcHRpb25zLmRlZmF1bHROUyA9IG9wdGlvbnMubnM7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMubnMuaW5kZXhPZigndHJhbnNsYXRpb24nKSA8IDApIHtcbiAgICAgICAgb3B0aW9ucy5kZWZhdWx0TlMgPSBvcHRpb25zLm5zWzBdO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkZWZPcHRzID0gZ2V0KCk7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgLi4uZGVmT3B0cyxcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgIC4uLnRyYW5zZm9ybU9wdGlvbnMob3B0aW9ucylcbiAgICB9O1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY29tcGF0aWJpbGl0eUFQSSAhPT0gJ3YxJykge1xuICAgICAgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24gPSB7XG4gICAgICAgIC4uLmRlZk9wdHMuaW50ZXJwb2xhdGlvbixcbiAgICAgICAgLi4udGhpcy5vcHRpb25zLmludGVycG9sYXRpb25cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmtleVNlcGFyYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMudXNlckRlZmluZWRLZXlTZXBhcmF0b3IgPSBvcHRpb25zLmtleVNlcGFyYXRvcjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubnNTZXBhcmF0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5vcHRpb25zLnVzZXJEZWZpbmVkTnNTZXBhcmF0b3IgPSBvcHRpb25zLm5zU2VwYXJhdG9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVDbGFzc09uRGVtYW5kKENsYXNzT3JPYmplY3QpIHtcbiAgICAgIGlmICghQ2xhc3NPck9iamVjdCkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAodHlwZW9mIENsYXNzT3JPYmplY3QgPT09ICdmdW5jdGlvbicpIHJldHVybiBuZXcgQ2xhc3NPck9iamVjdCgpO1xuICAgICAgcmV0dXJuIENsYXNzT3JPYmplY3Q7XG4gICAgfVxuICAgIGlmICghdGhpcy5vcHRpb25zLmlzQ2xvbmUpIHtcbiAgICAgIGlmICh0aGlzLm1vZHVsZXMubG9nZ2VyKSB7XG4gICAgICAgIGJhc2VMb2dnZXIuaW5pdChjcmVhdGVDbGFzc09uRGVtYW5kKHRoaXMubW9kdWxlcy5sb2dnZXIpLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZUxvZ2dlci5pbml0KG51bGwsIHRoaXMub3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBsZXQgZm9ybWF0dGVyO1xuICAgICAgaWYgKHRoaXMubW9kdWxlcy5mb3JtYXR0ZXIpIHtcbiAgICAgICAgZm9ybWF0dGVyID0gdGhpcy5tb2R1bGVzLmZvcm1hdHRlcjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEludGwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGZvcm1hdHRlciA9IEZvcm1hdHRlcjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGx1ID0gbmV3IExhbmd1YWdlVXRpbCh0aGlzLm9wdGlvbnMpO1xuICAgICAgdGhpcy5zdG9yZSA9IG5ldyBSZXNvdXJjZVN0b3JlKHRoaXMub3B0aW9ucy5yZXNvdXJjZXMsIHRoaXMub3B0aW9ucyk7XG4gICAgICBjb25zdCBzID0gdGhpcy5zZXJ2aWNlcztcbiAgICAgIHMubG9nZ2VyID0gYmFzZUxvZ2dlcjtcbiAgICAgIHMucmVzb3VyY2VTdG9yZSA9IHRoaXMuc3RvcmU7XG4gICAgICBzLmxhbmd1YWdlVXRpbHMgPSBsdTtcbiAgICAgIHMucGx1cmFsUmVzb2x2ZXIgPSBuZXcgUGx1cmFsUmVzb2x2ZXIobHUsIHtcbiAgICAgICAgcHJlcGVuZDogdGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcixcbiAgICAgICAgY29tcGF0aWJpbGl0eUpTT046IHRoaXMub3B0aW9ucy5jb21wYXRpYmlsaXR5SlNPTixcbiAgICAgICAgc2ltcGxpZnlQbHVyYWxTdWZmaXg6IHRoaXMub3B0aW9ucy5zaW1wbGlmeVBsdXJhbFN1ZmZpeFxuICAgICAgfSk7XG4gICAgICBpZiAoZm9ybWF0dGVyICYmICghdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZm9ybWF0IHx8IHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmZvcm1hdCA9PT0gZGVmT3B0cy5pbnRlcnBvbGF0aW9uLmZvcm1hdCkpIHtcbiAgICAgICAgcy5mb3JtYXR0ZXIgPSBjcmVhdGVDbGFzc09uRGVtYW5kKGZvcm1hdHRlcik7XG4gICAgICAgIHMuZm9ybWF0dGVyLmluaXQocywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZm9ybWF0ID0gcy5mb3JtYXR0ZXIuZm9ybWF0LmJpbmQocy5mb3JtYXR0ZXIpO1xuICAgICAgfVxuICAgICAgcy5pbnRlcnBvbGF0b3IgPSBuZXcgSW50ZXJwb2xhdG9yKHRoaXMub3B0aW9ucyk7XG4gICAgICBzLnV0aWxzID0ge1xuICAgICAgICBoYXNMb2FkZWROYW1lc3BhY2U6IHRoaXMuaGFzTG9hZGVkTmFtZXNwYWNlLmJpbmQodGhpcylcbiAgICAgIH07XG4gICAgICBzLmJhY2tlbmRDb25uZWN0b3IgPSBuZXcgQ29ubmVjdG9yKGNyZWF0ZUNsYXNzT25EZW1hbmQodGhpcy5tb2R1bGVzLmJhY2tlbmQpLCBzLnJlc291cmNlU3RvcmUsIHMsIHRoaXMub3B0aW9ucyk7XG4gICAgICBzLmJhY2tlbmRDb25uZWN0b3Iub24oJyonLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5tb2R1bGVzLmxhbmd1YWdlRGV0ZWN0b3IpIHtcbiAgICAgICAgcy5sYW5ndWFnZURldGVjdG9yID0gY3JlYXRlQ2xhc3NPbkRlbWFuZCh0aGlzLm1vZHVsZXMubGFuZ3VhZ2VEZXRlY3Rvcik7XG4gICAgICAgIGlmIChzLmxhbmd1YWdlRGV0ZWN0b3IuaW5pdCkgcy5sYW5ndWFnZURldGVjdG9yLmluaXQocywgdGhpcy5vcHRpb25zLmRldGVjdGlvbiwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1vZHVsZXMuaTE4bkZvcm1hdCkge1xuICAgICAgICBzLmkxOG5Gb3JtYXQgPSBjcmVhdGVDbGFzc09uRGVtYW5kKHRoaXMubW9kdWxlcy5pMThuRm9ybWF0KTtcbiAgICAgICAgaWYgKHMuaTE4bkZvcm1hdC5pbml0KSBzLmkxOG5Gb3JtYXQuaW5pdCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhbnNsYXRvciA9IG5ldyBUcmFuc2xhdG9yKHRoaXMuc2VydmljZXMsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLnRyYW5zbGF0b3Iub24oJyonLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm1vZHVsZXMuZXh0ZXJuYWwuZm9yRWFjaChtID0+IHtcbiAgICAgICAgaWYgKG0uaW5pdCkgbS5pbml0KHRoaXMpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuZm9ybWF0ID0gdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZm9ybWF0O1xuICAgIGlmICghY2FsbGJhY2spIGNhbGxiYWNrID0gbm9vcDtcbiAgICBpZiAodGhpcy5vcHRpb25zLmZhbGxiYWNrTG5nICYmICF0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IgJiYgIXRoaXMub3B0aW9ucy5sbmcpIHtcbiAgICAgIGNvbnN0IGNvZGVzID0gdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZVV0aWxzLmdldEZhbGxiYWNrQ29kZXModGhpcy5vcHRpb25zLmZhbGxiYWNrTG5nKTtcbiAgICAgIGlmIChjb2Rlcy5sZW5ndGggPiAwICYmIGNvZGVzWzBdICE9PSAnZGV2JykgdGhpcy5vcHRpb25zLmxuZyA9IGNvZGVzWzBdO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3RvciAmJiAhdGhpcy5vcHRpb25zLmxuZykge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignaW5pdDogbm8gbGFuZ3VhZ2VEZXRlY3RvciBpcyB1c2VkIGFuZCBubyBsbmcgaXMgZGVmaW5lZCcpO1xuICAgIH1cbiAgICBjb25zdCBzdG9yZUFwaSA9IFsnZ2V0UmVzb3VyY2UnLCAnaGFzUmVzb3VyY2VCdW5kbGUnLCAnZ2V0UmVzb3VyY2VCdW5kbGUnLCAnZ2V0RGF0YUJ5TGFuZ3VhZ2UnXTtcbiAgICBzdG9yZUFwaS5mb3JFYWNoKGZjTmFtZSA9PiB7XG4gICAgICB0aGlzW2ZjTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5zdG9yZVtmY05hbWVdKC4uLmFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHN0b3JlQXBpQ2hhaW5lZCA9IFsnYWRkUmVzb3VyY2UnLCAnYWRkUmVzb3VyY2VzJywgJ2FkZFJlc291cmNlQnVuZGxlJywgJ3JlbW92ZVJlc291cmNlQnVuZGxlJ107XG4gICAgc3RvcmVBcGlDaGFpbmVkLmZvckVhY2goZmNOYW1lID0+IHtcbiAgICAgIHRoaXNbZmNOYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuc3RvcmVbZmNOYW1lXSguLi5hcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBjb25zdCBsb2FkID0gKCkgPT4ge1xuICAgICAgY29uc3QgZmluaXNoID0gKGVyciwgdCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkICYmICF0aGlzLmluaXRpYWxpemVkU3RvcmVPbmNlKSB0aGlzLmxvZ2dlci53YXJuKCdpbml0OiBpMThuZXh0IGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuIFlvdSBzaG91bGQgY2FsbCBpbml0IGp1c3Qgb25jZSEnKTtcbiAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaXNDbG9uZSkgdGhpcy5sb2dnZXIubG9nKCdpbml0aWFsaXplZCcsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZW1pdCgnaW5pdGlhbGl6ZWQnLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHQpO1xuICAgICAgICBjYWxsYmFjayhlcnIsIHQpO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmxhbmd1YWdlcyAmJiB0aGlzLm9wdGlvbnMuY29tcGF0aWJpbGl0eUFQSSAhPT0gJ3YxJyAmJiAhdGhpcy5pc0luaXRpYWxpemVkKSByZXR1cm4gZmluaXNoKG51bGwsIHRoaXMudC5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuY2hhbmdlTGFuZ3VhZ2UodGhpcy5vcHRpb25zLmxuZywgZmluaXNoKTtcbiAgICB9O1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmVzb3VyY2VzIHx8ICF0aGlzLm9wdGlvbnMuaW5pdEltbWVkaWF0ZSkge1xuICAgICAgbG9hZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRUaW1lb3V0KGxvYWQsIDApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQ7XG4gIH1cbiAgbG9hZFJlc291cmNlcyhsYW5ndWFnZSkge1xuICAgIGxldCBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbm9vcDtcbiAgICBsZXQgdXNlZENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgY29uc3QgdXNlZExuZyA9IHR5cGVvZiBsYW5ndWFnZSA9PT0gJ3N0cmluZycgPyBsYW5ndWFnZSA6IHRoaXMubGFuZ3VhZ2U7XG4gICAgaWYgKHR5cGVvZiBsYW5ndWFnZSA9PT0gJ2Z1bmN0aW9uJykgdXNlZENhbGxiYWNrID0gbGFuZ3VhZ2U7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMucmVzb3VyY2VzIHx8IHRoaXMub3B0aW9ucy5wYXJ0aWFsQnVuZGxlZExhbmd1YWdlcykge1xuICAgICAgaWYgKHVzZWRMbmcgJiYgdXNlZExuZy50b0xvd2VyQ2FzZSgpID09PSAnY2ltb2RlJyAmJiAoIXRoaXMub3B0aW9ucy5wcmVsb2FkIHx8IHRoaXMub3B0aW9ucy5wcmVsb2FkLmxlbmd0aCA9PT0gMCkpIHJldHVybiB1c2VkQ2FsbGJhY2soKTtcbiAgICAgIGNvbnN0IHRvTG9hZCA9IFtdO1xuICAgICAgY29uc3QgYXBwZW5kID0gbG5nID0+IHtcbiAgICAgICAgaWYgKCFsbmcpIHJldHVybjtcbiAgICAgICAgaWYgKGxuZyA9PT0gJ2NpbW9kZScpIHJldHVybjtcbiAgICAgICAgY29uc3QgbG5ncyA9IHRoaXMuc2VydmljZXMubGFuZ3VhZ2VVdGlscy50b1Jlc29sdmVIaWVyYXJjaHkobG5nKTtcbiAgICAgICAgbG5ncy5mb3JFYWNoKGwgPT4ge1xuICAgICAgICAgIGlmIChsID09PSAnY2ltb2RlJykgcmV0dXJuO1xuICAgICAgICAgIGlmICh0b0xvYWQuaW5kZXhPZihsKSA8IDApIHRvTG9hZC5wdXNoKGwpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBpZiAoIXVzZWRMbmcpIHtcbiAgICAgICAgY29uc3QgZmFsbGJhY2tzID0gdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZVV0aWxzLmdldEZhbGxiYWNrQ29kZXModGhpcy5vcHRpb25zLmZhbGxiYWNrTG5nKTtcbiAgICAgICAgZmFsbGJhY2tzLmZvckVhY2gobCA9PiBhcHBlbmQobCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXBwZW5kKHVzZWRMbmcpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcmVsb2FkKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5wcmVsb2FkLmZvckVhY2gobCA9PiBhcHBlbmQobCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXJ2aWNlcy5iYWNrZW5kQ29ubmVjdG9yLmxvYWQodG9Mb2FkLCB0aGlzLm9wdGlvbnMubnMsIGUgPT4ge1xuICAgICAgICBpZiAoIWUgJiYgIXRoaXMucmVzb2x2ZWRMYW5ndWFnZSAmJiB0aGlzLmxhbmd1YWdlKSB0aGlzLnNldFJlc29sdmVkTGFuZ3VhZ2UodGhpcy5sYW5ndWFnZSk7XG4gICAgICAgIHVzZWRDYWxsYmFjayhlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB1c2VkQ2FsbGJhY2sobnVsbCk7XG4gICAgfVxuICB9XG4gIHJlbG9hZFJlc291cmNlcyhsbmdzLCBucywgY2FsbGJhY2spIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgaWYgKCFsbmdzKSBsbmdzID0gdGhpcy5sYW5ndWFnZXM7XG4gICAgaWYgKCFucykgbnMgPSB0aGlzLm9wdGlvbnMubnM7XG4gICAgaWYgKCFjYWxsYmFjaykgY2FsbGJhY2sgPSBub29wO1xuICAgIHRoaXMuc2VydmljZXMuYmFja2VuZENvbm5lY3Rvci5yZWxvYWQobG5ncywgbnMsIGVyciA9PiB7XG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZDtcbiAgfVxuICB1c2UobW9kdWxlKSB7XG4gICAgaWYgKCFtb2R1bGUpIHRocm93IG5ldyBFcnJvcignWW91IGFyZSBwYXNzaW5nIGFuIHVuZGVmaW5lZCBtb2R1bGUhIFBsZWFzZSBjaGVjayB0aGUgb2JqZWN0IHlvdSBhcmUgcGFzc2luZyB0byBpMThuZXh0LnVzZSgpJyk7XG4gICAgaWYgKCFtb2R1bGUudHlwZSkgdGhyb3cgbmV3IEVycm9yKCdZb3UgYXJlIHBhc3NpbmcgYSB3cm9uZyBtb2R1bGUhIFBsZWFzZSBjaGVjayB0aGUgb2JqZWN0IHlvdSBhcmUgcGFzc2luZyB0byBpMThuZXh0LnVzZSgpJyk7XG4gICAgaWYgKG1vZHVsZS50eXBlID09PSAnYmFja2VuZCcpIHtcbiAgICAgIHRoaXMubW9kdWxlcy5iYWNrZW5kID0gbW9kdWxlO1xuICAgIH1cbiAgICBpZiAobW9kdWxlLnR5cGUgPT09ICdsb2dnZXInIHx8IG1vZHVsZS5sb2cgJiYgbW9kdWxlLndhcm4gJiYgbW9kdWxlLmVycm9yKSB7XG4gICAgICB0aGlzLm1vZHVsZXMubG9nZ2VyID0gbW9kdWxlO1xuICAgIH1cbiAgICBpZiAobW9kdWxlLnR5cGUgPT09ICdsYW5ndWFnZURldGVjdG9yJykge1xuICAgICAgdGhpcy5tb2R1bGVzLmxhbmd1YWdlRGV0ZWN0b3IgPSBtb2R1bGU7XG4gICAgfVxuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJ2kxOG5Gb3JtYXQnKSB7XG4gICAgICB0aGlzLm1vZHVsZXMuaTE4bkZvcm1hdCA9IG1vZHVsZTtcbiAgICB9XG4gICAgaWYgKG1vZHVsZS50eXBlID09PSAncG9zdFByb2Nlc3NvcicpIHtcbiAgICAgIHBvc3RQcm9jZXNzb3IuYWRkUG9zdFByb2Nlc3Nvcihtb2R1bGUpO1xuICAgIH1cbiAgICBpZiAobW9kdWxlLnR5cGUgPT09ICdmb3JtYXR0ZXInKSB7XG4gICAgICB0aGlzLm1vZHVsZXMuZm9ybWF0dGVyID0gbW9kdWxlO1xuICAgIH1cbiAgICBpZiAobW9kdWxlLnR5cGUgPT09ICczcmRQYXJ0eScpIHtcbiAgICAgIHRoaXMubW9kdWxlcy5leHRlcm5hbC5wdXNoKG1vZHVsZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldFJlc29sdmVkTGFuZ3VhZ2UobCkge1xuICAgIGlmICghbCB8fCAhdGhpcy5sYW5ndWFnZXMpIHJldHVybjtcbiAgICBpZiAoWydjaW1vZGUnLCAnZGV2J10uaW5kZXhPZihsKSA+IC0xKSByZXR1cm47XG4gICAgZm9yIChsZXQgbGkgPSAwOyBsaSA8IHRoaXMubGFuZ3VhZ2VzLmxlbmd0aDsgbGkrKykge1xuICAgICAgY29uc3QgbG5nSW5MbmdzID0gdGhpcy5sYW5ndWFnZXNbbGldO1xuICAgICAgaWYgKFsnY2ltb2RlJywgJ2RldiddLmluZGV4T2YobG5nSW5MbmdzKSA+IC0xKSBjb250aW51ZTtcbiAgICAgIGlmICh0aGlzLnN0b3JlLmhhc0xhbmd1YWdlU29tZVRyYW5zbGF0aW9ucyhsbmdJbkxuZ3MpKSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZWRMYW5ndWFnZSA9IGxuZ0luTG5ncztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNoYW5nZUxhbmd1YWdlKGxuZywgY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICB0aGlzLmlzTGFuZ3VhZ2VDaGFuZ2luZ1RvID0gbG5nO1xuICAgIGNvbnN0IGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB0aGlzLmVtaXQoJ2xhbmd1YWdlQ2hhbmdpbmcnLCBsbmcpO1xuICAgIGNvbnN0IHNldExuZ1Byb3BzID0gbCA9PiB7XG4gICAgICB0aGlzLmxhbmd1YWdlID0gbDtcbiAgICAgIHRoaXMubGFuZ3VhZ2VzID0gdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZVV0aWxzLnRvUmVzb2x2ZUhpZXJhcmNoeShsKTtcbiAgICAgIHRoaXMucmVzb2x2ZWRMYW5ndWFnZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuc2V0UmVzb2x2ZWRMYW5ndWFnZShsKTtcbiAgICB9O1xuICAgIGNvbnN0IGRvbmUgPSAoZXJyLCBsKSA9PiB7XG4gICAgICBpZiAobCkge1xuICAgICAgICBzZXRMbmdQcm9wcyhsKTtcbiAgICAgICAgdGhpcy50cmFuc2xhdG9yLmNoYW5nZUxhbmd1YWdlKGwpO1xuICAgICAgICB0aGlzLmlzTGFuZ3VhZ2VDaGFuZ2luZ1RvID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmVtaXQoJ2xhbmd1YWdlQ2hhbmdlZCcsIGwpO1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ2xhbmd1YWdlQ2hhbmdlZCcsIGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pc0xhbmd1YWdlQ2hhbmdpbmdUbyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGRlZmVycmVkLnJlc29sdmUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLnQoLi4uYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi50KC4uLmFyZ3VtZW50cyk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHNldExuZyA9IGxuZ3MgPT4ge1xuICAgICAgaWYgKCFsbmcgJiYgIWxuZ3MgJiYgdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yKSBsbmdzID0gW107XG4gICAgICBjb25zdCBsID0gdHlwZW9mIGxuZ3MgPT09ICdzdHJpbmcnID8gbG5ncyA6IHRoaXMuc2VydmljZXMubGFuZ3VhZ2VVdGlscy5nZXRCZXN0TWF0Y2hGcm9tQ29kZXMobG5ncyk7XG4gICAgICBpZiAobCkge1xuICAgICAgICBpZiAoIXRoaXMubGFuZ3VhZ2UpIHtcbiAgICAgICAgICBzZXRMbmdQcm9wcyhsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudHJhbnNsYXRvci5sYW5ndWFnZSkgdGhpcy50cmFuc2xhdG9yLmNoYW5nZUxhbmd1YWdlKGwpO1xuICAgICAgICBpZiAodGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yICYmIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvci5jYWNoZVVzZXJMYW5ndWFnZSkgdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yLmNhY2hlVXNlckxhbmd1YWdlKGwpO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2FkUmVzb3VyY2VzKGwsIGVyciA9PiB7XG4gICAgICAgIGRvbmUoZXJyLCBsKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKCFsbmcgJiYgdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yICYmICF0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IuYXN5bmMpIHtcbiAgICAgIHNldExuZyh0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IuZGV0ZWN0KCkpO1xuICAgIH0gZWxzZSBpZiAoIWxuZyAmJiB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IgJiYgdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yLmFzeW5jKSB7XG4gICAgICBpZiAodGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yLmRldGVjdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yLmRldGVjdCgpLnRoZW4oc2V0TG5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvci5kZXRlY3Qoc2V0TG5nKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2V0TG5nKGxuZyk7XG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZDtcbiAgfVxuICBnZXRGaXhlZFQobG5nLCBucywga2V5UHJlZml4KSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgY29uc3QgZml4ZWRUID0gZnVuY3Rpb24gKGtleSwgb3B0cykge1xuICAgICAgbGV0IG9wdGlvbnM7XG4gICAgICBpZiAodHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuMyA+IDIgPyBfbGVuMyAtIDIgOiAwKSwgX2tleTMgPSAyOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgICAgcmVzdFtfa2V5MyAtIDJdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gX3RoaXMzLm9wdGlvbnMub3ZlcmxvYWRUcmFuc2xhdGlvbk9wdGlvbkhhbmRsZXIoW2tleSwgb3B0c10uY29uY2F0KHJlc3QpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgLi4ub3B0c1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5sbmcgPSBvcHRpb25zLmxuZyB8fCBmaXhlZFQubG5nO1xuICAgICAgb3B0aW9ucy5sbmdzID0gb3B0aW9ucy5sbmdzIHx8IGZpeGVkVC5sbmdzO1xuICAgICAgb3B0aW9ucy5ucyA9IG9wdGlvbnMubnMgfHwgZml4ZWRULm5zO1xuICAgICAgb3B0aW9ucy5rZXlQcmVmaXggPSBvcHRpb25zLmtleVByZWZpeCB8fCBrZXlQcmVmaXggfHwgZml4ZWRULmtleVByZWZpeDtcbiAgICAgIGNvbnN0IGtleVNlcGFyYXRvciA9IF90aGlzMy5vcHRpb25zLmtleVNlcGFyYXRvciB8fCAnLic7XG4gICAgICBsZXQgcmVzdWx0S2V5O1xuICAgICAgaWYgKG9wdGlvbnMua2V5UHJlZml4ICYmIEFycmF5LmlzQXJyYXkoa2V5KSkge1xuICAgICAgICByZXN1bHRLZXkgPSBrZXkubWFwKGsgPT4gYCR7b3B0aW9ucy5rZXlQcmVmaXh9JHtrZXlTZXBhcmF0b3J9JHtrfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0S2V5ID0gb3B0aW9ucy5rZXlQcmVmaXggPyBgJHtvcHRpb25zLmtleVByZWZpeH0ke2tleVNlcGFyYXRvcn0ke2tleX1gIDoga2V5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIF90aGlzMy50KHJlc3VsdEtleSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBpZiAodHlwZW9mIGxuZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZpeGVkVC5sbmcgPSBsbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpeGVkVC5sbmdzID0gbG5nO1xuICAgIH1cbiAgICBmaXhlZFQubnMgPSBucztcbiAgICBmaXhlZFQua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICAgIHJldHVybiBmaXhlZFQ7XG4gIH1cbiAgdCgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2xhdG9yICYmIHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGUoLi4uYXJndW1lbnRzKTtcbiAgfVxuICBleGlzdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNsYXRvciAmJiB0aGlzLnRyYW5zbGF0b3IuZXhpc3RzKC4uLmFyZ3VtZW50cyk7XG4gIH1cbiAgc2V0RGVmYXVsdE5hbWVzcGFjZShucykge1xuICAgIHRoaXMub3B0aW9ucy5kZWZhdWx0TlMgPSBucztcbiAgfVxuICBoYXNMb2FkZWROYW1lc3BhY2UobnMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ2hhc0xvYWRlZE5hbWVzcGFjZTogaTE4bmV4dCB3YXMgbm90IGluaXRpYWxpemVkJywgdGhpcy5sYW5ndWFnZXMpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMubGFuZ3VhZ2VzIHx8ICF0aGlzLmxhbmd1YWdlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ2hhc0xvYWRlZE5hbWVzcGFjZTogaTE4bi5sYW5ndWFnZXMgd2VyZSB1bmRlZmluZWQgb3IgZW1wdHknLCB0aGlzLmxhbmd1YWdlcyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGxuZyA9IG9wdGlvbnMubG5nIHx8IHRoaXMucmVzb2x2ZWRMYW5ndWFnZSB8fCB0aGlzLmxhbmd1YWdlc1swXTtcbiAgICBjb25zdCBmYWxsYmFja0xuZyA9IHRoaXMub3B0aW9ucyA/IHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZyA6IGZhbHNlO1xuICAgIGNvbnN0IGxhc3RMbmcgPSB0aGlzLmxhbmd1YWdlc1t0aGlzLmxhbmd1YWdlcy5sZW5ndGggLSAxXTtcbiAgICBpZiAobG5nLnRvTG93ZXJDYXNlKCkgPT09ICdjaW1vZGUnKSByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBsb2FkTm90UGVuZGluZyA9IChsLCBuKSA9PiB7XG4gICAgICBjb25zdCBsb2FkU3RhdGUgPSB0aGlzLnNlcnZpY2VzLmJhY2tlbmRDb25uZWN0b3Iuc3RhdGVbYCR7bH18JHtufWBdO1xuICAgICAgcmV0dXJuIGxvYWRTdGF0ZSA9PT0gLTEgfHwgbG9hZFN0YXRlID09PSAyO1xuICAgIH07XG4gICAgaWYgKG9wdGlvbnMucHJlY2hlY2spIHtcbiAgICAgIGNvbnN0IHByZVJlc3VsdCA9IG9wdGlvbnMucHJlY2hlY2sodGhpcywgbG9hZE5vdFBlbmRpbmcpO1xuICAgICAgaWYgKHByZVJlc3VsdCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcHJlUmVzdWx0O1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKCF0aGlzLnNlcnZpY2VzLmJhY2tlbmRDb25uZWN0b3IuYmFja2VuZCB8fCB0aGlzLm9wdGlvbnMucmVzb3VyY2VzICYmICF0aGlzLm9wdGlvbnMucGFydGlhbEJ1bmRsZWRMYW5ndWFnZXMpIHJldHVybiB0cnVlO1xuICAgIGlmIChsb2FkTm90UGVuZGluZyhsbmcsIG5zKSAmJiAoIWZhbGxiYWNrTG5nIHx8IGxvYWROb3RQZW5kaW5nKGxhc3RMbmcsIG5zKSkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsb2FkTmFtZXNwYWNlcyhucywgY2FsbGJhY2spIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMubnMpIHtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBucyA9PT0gJ3N0cmluZycpIG5zID0gW25zXTtcbiAgICBucy5mb3JFYWNoKG4gPT4ge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ucy5pbmRleE9mKG4pIDwgMCkgdGhpcy5vcHRpb25zLm5zLnB1c2gobik7XG4gICAgfSk7XG4gICAgdGhpcy5sb2FkUmVzb3VyY2VzKGVyciA9PiB7XG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkO1xuICB9XG4gIGxvYWRMYW5ndWFnZXMobG5ncywgY2FsbGJhY2spIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgaWYgKHR5cGVvZiBsbmdzID09PSAnc3RyaW5nJykgbG5ncyA9IFtsbmdzXTtcbiAgICBjb25zdCBwcmVsb2FkZWQgPSB0aGlzLm9wdGlvbnMucHJlbG9hZCB8fCBbXTtcbiAgICBjb25zdCBuZXdMbmdzID0gbG5ncy5maWx0ZXIobG5nID0+IHByZWxvYWRlZC5pbmRleE9mKGxuZykgPCAwKTtcbiAgICBpZiAoIW5ld0xuZ3MubGVuZ3RoKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHRoaXMub3B0aW9ucy5wcmVsb2FkID0gcHJlbG9hZGVkLmNvbmNhdChuZXdMbmdzKTtcbiAgICB0aGlzLmxvYWRSZXNvdXJjZXMoZXJyID0+IHtcbiAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQ7XG4gIH1cbiAgZGlyKGxuZykge1xuICAgIGlmICghbG5nKSBsbmcgPSB0aGlzLnJlc29sdmVkTGFuZ3VhZ2UgfHwgKHRoaXMubGFuZ3VhZ2VzICYmIHRoaXMubGFuZ3VhZ2VzLmxlbmd0aCA+IDAgPyB0aGlzLmxhbmd1YWdlc1swXSA6IHRoaXMubGFuZ3VhZ2UpO1xuICAgIGlmICghbG5nKSByZXR1cm4gJ3J0bCc7XG4gICAgY29uc3QgcnRsTG5ncyA9IFsnYXInLCAnc2h1JywgJ3NxcicsICdzc2gnLCAneGFhJywgJ3loZCcsICd5dWQnLCAnYWFvJywgJ2FiaCcsICdhYnYnLCAnYWNtJywgJ2FjcScsICdhY3cnLCAnYWN4JywgJ2FjeScsICdhZGYnLCAnYWRzJywgJ2FlYicsICdhZWMnLCAnYWZiJywgJ2FqcCcsICdhcGMnLCAnYXBkJywgJ2FyYicsICdhcnEnLCAnYXJzJywgJ2FyeScsICdhcnonLCAnYXV6JywgJ2F2bCcsICdheWgnLCAnYXlsJywgJ2F5bicsICdheXAnLCAnYmJ6JywgJ3BnYScsICdoZScsICdpdycsICdwcycsICdwYnQnLCAncGJ1JywgJ3BzdCcsICdwcnAnLCAncHJkJywgJ3VnJywgJ3VyJywgJ3lkZCcsICd5ZHMnLCAneWloJywgJ2ppJywgJ3lpJywgJ2hibycsICdtZW4nLCAneG1uJywgJ2ZhJywgJ2pwcicsICdwZW8nLCAncGVzJywgJ3BycycsICdkdicsICdzYW0nLCAnY2tiJ107XG4gICAgY29uc3QgbGFuZ3VhZ2VVdGlscyA9IHRoaXMuc2VydmljZXMgJiYgdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZVV0aWxzIHx8IG5ldyBMYW5ndWFnZVV0aWwoZ2V0KCkpO1xuICAgIHJldHVybiBydGxMbmdzLmluZGV4T2YobGFuZ3VhZ2VVdGlscy5nZXRMYW5ndWFnZVBhcnRGcm9tQ29kZShsbmcpKSA+IC0xIHx8IGxuZy50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJy1hcmFiJykgPiAxID8gJ3J0bCcgOiAnbHRyJztcbiAgfVxuICBzdGF0aWMgY3JlYXRlSW5zdGFuY2UoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGxldCBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBuZXcgSTE4bihvcHRpb25zLCBjYWxsYmFjayk7XG4gIH1cbiAgY2xvbmVJbnN0YW5jZSgpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgbGV0IGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBub29wO1xuICAgIGNvbnN0IGZvcmtSZXNvdXJjZVN0b3JlID0gb3B0aW9ucy5mb3JrUmVzb3VyY2VTdG9yZTtcbiAgICBpZiAoZm9ya1Jlc291cmNlU3RvcmUpIGRlbGV0ZSBvcHRpb25zLmZvcmtSZXNvdXJjZVN0b3JlO1xuICAgIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgLi4ue1xuICAgICAgICBpc0Nsb25lOiB0cnVlXG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBJMThuKG1lcmdlZE9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmRlYnVnICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5wcmVmaXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xvbmUubG9nZ2VyID0gY2xvbmUubG9nZ2VyLmNsb25lKG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBtZW1iZXJzVG9Db3B5ID0gWydzdG9yZScsICdzZXJ2aWNlcycsICdsYW5ndWFnZSddO1xuICAgIG1lbWJlcnNUb0NvcHkuZm9yRWFjaChtID0+IHtcbiAgICAgIGNsb25lW21dID0gdGhpc1ttXTtcbiAgICB9KTtcbiAgICBjbG9uZS5zZXJ2aWNlcyA9IHtcbiAgICAgIC4uLnRoaXMuc2VydmljZXNcbiAgICB9O1xuICAgIGNsb25lLnNlcnZpY2VzLnV0aWxzID0ge1xuICAgICAgaGFzTG9hZGVkTmFtZXNwYWNlOiBjbG9uZS5oYXNMb2FkZWROYW1lc3BhY2UuYmluZChjbG9uZSlcbiAgICB9O1xuICAgIGlmIChmb3JrUmVzb3VyY2VTdG9yZSkge1xuICAgICAgY2xvbmUuc3RvcmUgPSBuZXcgUmVzb3VyY2VTdG9yZSh0aGlzLnN0b3JlLmRhdGEsIG1lcmdlZE9wdGlvbnMpO1xuICAgICAgY2xvbmUuc2VydmljZXMucmVzb3VyY2VTdG9yZSA9IGNsb25lLnN0b3JlO1xuICAgIH1cbiAgICBjbG9uZS50cmFuc2xhdG9yID0gbmV3IFRyYW5zbGF0b3IoY2xvbmUuc2VydmljZXMsIG1lcmdlZE9wdGlvbnMpO1xuICAgIGNsb25lLnRyYW5zbGF0b3Iub24oJyonLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCA+IDEgPyBfbGVuNCAtIDEgOiAwKSwgX2tleTQgPSAxOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTQgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICB9XG4gICAgICBjbG9uZS5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgICB9KTtcbiAgICBjbG9uZS5pbml0KG1lcmdlZE9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICBjbG9uZS50cmFuc2xhdG9yLm9wdGlvbnMgPSBtZXJnZWRPcHRpb25zO1xuICAgIGNsb25lLnRyYW5zbGF0b3IuYmFja2VuZENvbm5lY3Rvci5zZXJ2aWNlcy51dGlscyA9IHtcbiAgICAgIGhhc0xvYWRlZE5hbWVzcGFjZTogY2xvbmUuaGFzTG9hZGVkTmFtZXNwYWNlLmJpbmQoY2xvbmUpXG4gICAgfTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICBzdG9yZTogdGhpcy5zdG9yZSxcbiAgICAgIGxhbmd1YWdlOiB0aGlzLmxhbmd1YWdlLFxuICAgICAgbGFuZ3VhZ2VzOiB0aGlzLmxhbmd1YWdlcyxcbiAgICAgIHJlc29sdmVkTGFuZ3VhZ2U6IHRoaXMucmVzb2x2ZWRMYW5ndWFnZVxuICAgIH07XG4gIH1cbn1cbmNvbnN0IGluc3RhbmNlID0gSTE4bi5jcmVhdGVJbnN0YW5jZSgpO1xuaW5zdGFuY2UuY3JlYXRlSW5zdGFuY2UgPSBJMThuLmNyZWF0ZUluc3RhbmNlO1xuXG5jb25zdCBjcmVhdGVJbnN0YW5jZSA9IGluc3RhbmNlLmNyZWF0ZUluc3RhbmNlO1xuY29uc3QgZGlyID0gaW5zdGFuY2UuZGlyO1xuY29uc3QgaW5pdCA9IGluc3RhbmNlLmluaXQ7XG5jb25zdCBsb2FkUmVzb3VyY2VzID0gaW5zdGFuY2UubG9hZFJlc291cmNlcztcbmNvbnN0IHJlbG9hZFJlc291cmNlcyA9IGluc3RhbmNlLnJlbG9hZFJlc291cmNlcztcbmNvbnN0IHVzZSA9IGluc3RhbmNlLnVzZTtcbmNvbnN0IGNoYW5nZUxhbmd1YWdlID0gaW5zdGFuY2UuY2hhbmdlTGFuZ3VhZ2U7XG5jb25zdCBnZXRGaXhlZFQgPSBpbnN0YW5jZS5nZXRGaXhlZFQ7XG5jb25zdCB0ID0gaW5zdGFuY2UudDtcbmNvbnN0IGV4aXN0cyA9IGluc3RhbmNlLmV4aXN0cztcbmNvbnN0IHNldERlZmF1bHROYW1lc3BhY2UgPSBpbnN0YW5jZS5zZXREZWZhdWx0TmFtZXNwYWNlO1xuY29uc3QgaGFzTG9hZGVkTmFtZXNwYWNlID0gaW5zdGFuY2UuaGFzTG9hZGVkTmFtZXNwYWNlO1xuY29uc3QgbG9hZE5hbWVzcGFjZXMgPSBpbnN0YW5jZS5sb2FkTmFtZXNwYWNlcztcbmNvbnN0IGxvYWRMYW5ndWFnZXMgPSBpbnN0YW5jZS5sb2FkTGFuZ3VhZ2VzO1xuXG5leHBvcnQgeyBjaGFuZ2VMYW5ndWFnZSwgY3JlYXRlSW5zdGFuY2UsIGluc3RhbmNlIGFzIGRlZmF1bHQsIGRpciwgZXhpc3RzLCBnZXRGaXhlZFQsIGhhc0xvYWRlZE5hbWVzcGFjZSwgaW5pdCwgbG9hZExhbmd1YWdlcywgbG9hZE5hbWVzcGFjZXMsIGxvYWRSZXNvdXJjZXMsIHJlbG9hZFJlc291cmNlcywgc2V0RGVmYXVsdE5hbWVzcGFjZSwgdCwgdXNlIH07XG4iXSwibmFtZXMiOlsiY29uc29sZUxvZ2dlciIsInR5cGUiLCJsb2ciLCJhcmdzIiwib3V0cHV0Iiwid2FybiIsImVycm9yIiwiY29uc29sZSIsImFwcGx5IiwiTG9nZ2VyIiwiY29uc3RydWN0b3IiLCJjb25jcmV0ZUxvZ2dlciIsIm9wdGlvbnMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJpbml0IiwicHJlZml4IiwibG9nZ2VyIiwiZGVidWciLCJfbGVuIiwiQXJyYXkiLCJfa2V5IiwiZm9yd2FyZCIsIl9sZW4yIiwiX2tleTIiLCJfbGVuMyIsIl9rZXkzIiwiZGVwcmVjYXRlIiwiX2xlbjQiLCJfa2V5NCIsImx2bCIsImRlYnVnT25seSIsImNyZWF0ZSIsIm1vZHVsZU5hbWUiLCJjbG9uZSIsImJhc2VMb2dnZXIiLCJFdmVudEVtaXR0ZXIiLCJvYnNlcnZlcnMiLCJvbiIsImV2ZW50cyIsImxpc3RlbmVyIiwic3BsaXQiLCJmb3JFYWNoIiwiZXZlbnQiLCJwdXNoIiwib2ZmIiwiZmlsdGVyIiwibCIsImVtaXQiLCJjbG9uZWQiLCJjb25jYXQiLCJvYnNlcnZlciIsImRlZmVyIiwicmVzIiwicmVqIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwibWFrZVN0cmluZyIsIm9iamVjdCIsImNvcHkiLCJhIiwicyIsInQiLCJtIiwiZ2V0TGFzdE9mUGF0aCIsInBhdGgiLCJFbXB0eSIsImNsZWFuS2V5Iiwia2V5IiwiaW5kZXhPZiIsInJlcGxhY2UiLCJjYW5Ob3RUcmF2ZXJzZURlZXBlciIsInN0YWNrIiwic2hpZnQiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJvYmoiLCJrIiwic2V0UGF0aCIsIm5ld1ZhbHVlIiwicHVzaFBhdGgiLCJnZXRQYXRoIiwiZ2V0UGF0aFdpdGhEZWZhdWx0cyIsImRhdGEiLCJkZWZhdWx0RGF0YSIsInZhbHVlIiwiZGVlcEV4dGVuZCIsInRhcmdldCIsInNvdXJjZSIsIm92ZXJ3cml0ZSIsInByb3AiLCJTdHJpbmciLCJyZWdleEVzY2FwZSIsInN0ciIsIl9lbnRpdHlNYXAiLCJlc2NhcGUiLCJjaGFycyIsImxvb2tzTGlrZU9iamVjdFBhdGgiLCJuc1NlcGFyYXRvciIsImtleVNlcGFyYXRvciIsInBvc3NpYmxlQ2hhcnMiLCJjIiwiciIsIlJlZ0V4cCIsIm1hcCIsImpvaW4iLCJtYXRjaGVkIiwidGVzdCIsImtpIiwic3Vic3RyaW5nIiwiZGVlcEZpbmQiLCJwYXRocyIsImN1cnJlbnQiLCJpIiwiaiIsInAiLCJzbGljZSIsIm1peCIsImVuZHNXaXRoIiwiam9pbmVkUGF0aCIsImdldENsZWFuZWRDb2RlIiwiY29kZSIsIlJlc291cmNlU3RvcmUiLCJucyIsImRlZmF1bHROUyIsImlnbm9yZUpTT05TdHJ1Y3R1cmUiLCJhZGROYW1lc3BhY2VzIiwicmVtb3ZlTmFtZXNwYWNlcyIsImluZGV4Iiwic3BsaWNlIiwiZ2V0UmVzb3VyY2UiLCJsbmciLCJyZXN1bHQiLCJhZGRSZXNvdXJjZSIsInNpbGVudCIsImFkZFJlc291cmNlcyIsInJlc291cmNlcyIsInRvU3RyaW5nIiwiYWRkUmVzb3VyY2VCdW5kbGUiLCJkZWVwIiwicGFjayIsInJlbW92ZVJlc291cmNlQnVuZGxlIiwiaGFzUmVzb3VyY2VCdW5kbGUiLCJnZXRSZXNvdXJjZUJ1bmRsZSIsImNvbXBhdGliaWxpdHlBUEkiLCJnZXREYXRhQnlMYW5ndWFnZSIsImhhc0xhbmd1YWdlU29tZVRyYW5zbGF0aW9ucyIsIm4iLCJrZXlzIiwiZmluZCIsInYiLCJ0b0pTT04iLCJwb3N0UHJvY2Vzc29yIiwicHJvY2Vzc29ycyIsImFkZFBvc3RQcm9jZXNzb3IiLCJtb2R1bGUiLCJuYW1lIiwiaGFuZGxlIiwidHJhbnNsYXRvciIsInByb2Nlc3NvciIsInByb2Nlc3MiLCJjaGVja2VkTG9hZGVkRm9yIiwiVHJhbnNsYXRvciIsInNlcnZpY2VzIiwiY2hhbmdlTGFuZ3VhZ2UiLCJsYW5ndWFnZSIsImV4aXN0cyIsImludGVycG9sYXRpb24iLCJyZXNvbHZlZCIsImV4dHJhY3RGcm9tS2V5IiwibmFtZXNwYWNlcyIsIndvdWxkQ2hlY2tGb3JOc0luS2V5Iiwic2VlbXNOYXR1cmFsTGFuZ3VhZ2UiLCJ1c2VyRGVmaW5lZEtleVNlcGFyYXRvciIsInVzZXJEZWZpbmVkTnNTZXBhcmF0b3IiLCJtYXRjaCIsImludGVycG9sYXRvciIsIm5lc3RpbmdSZWdleHAiLCJwYXJ0cyIsInRyYW5zbGF0ZSIsImxhc3RLZXkiLCJvdmVybG9hZFRyYW5zbGF0aW9uT3B0aW9uSGFuZGxlciIsImlzQXJyYXkiLCJyZXR1cm5EZXRhaWxzIiwibmFtZXNwYWNlIiwiYXBwZW5kTmFtZXNwYWNlVG9DSU1vZGUiLCJ0b0xvd2VyQ2FzZSIsInVzZWRLZXkiLCJleGFjdFVzZWRLZXkiLCJ1c2VkTG5nIiwidXNlZE5TIiwidXNlZFBhcmFtcyIsImdldFVzZWRQYXJhbXNEZXRhaWxzIiwicmVzVXNlZEtleSIsInJlc0V4YWN0VXNlZEtleSIsInJlc1R5cGUiLCJub09iamVjdCIsImpvaW5BcnJheXMiLCJoYW5kbGVBc09iamVjdEluSTE4bkZvcm1hdCIsImkxOG5Gb3JtYXQiLCJoYW5kbGVBc09iamVjdCIsInJldHVybk9iamVjdHMiLCJyZXR1cm5lZE9iamVjdEhhbmRsZXIiLCJyZXNUeXBlSXNBcnJheSIsIm5ld0tleVRvVXNlIiwiZGVlcEtleSIsImV4dGVuZFRyYW5zbGF0aW9uIiwidXNlZERlZmF1bHQiLCJuZWVkc1BsdXJhbEhhbmRsaW5nIiwiY291bnQiLCJoYXNEZWZhdWx0VmFsdWUiLCJkZWZhdWx0VmFsdWVTdWZmaXgiLCJwbHVyYWxSZXNvbHZlciIsImdldFN1ZmZpeCIsImRlZmF1bHRWYWx1ZVN1ZmZpeE9yZGluYWxGYWxsYmFjayIsIm9yZGluYWwiLCJkZWZhdWx0VmFsdWUiLCJpc1ZhbGlkTG9va3VwIiwibWlzc2luZ0tleU5vVmFsdWVGYWxsYmFja1RvS2V5IiwicmVzRm9yTWlzc2luZyIsInVwZGF0ZU1pc3NpbmciLCJmayIsImxuZ3MiLCJmYWxsYmFja0xuZ3MiLCJsYW5ndWFnZVV0aWxzIiwiZ2V0RmFsbGJhY2tDb2RlcyIsImZhbGxiYWNrTG5nIiwic2F2ZU1pc3NpbmdUbyIsInRvUmVzb2x2ZUhpZXJhcmNoeSIsInNlbmQiLCJzcGVjaWZpY0RlZmF1bHRWYWx1ZSIsImRlZmF1bHRGb3JNaXNzaW5nIiwibWlzc2luZ0tleUhhbmRsZXIiLCJiYWNrZW5kQ29ubmVjdG9yIiwic2F2ZU1pc3NpbmciLCJzYXZlTWlzc2luZ1BsdXJhbHMiLCJnZXRTdWZmaXhlcyIsInN1ZmZpeCIsImFwcGVuZE5hbWVzcGFjZVRvTWlzc2luZ0tleSIsInBhcnNlTWlzc2luZ0tleUhhbmRsZXIiLCJfdGhpcyIsInBhcnNlIiwiZGVmYXVsdFZhcmlhYmxlcyIsInNraXBJbnRlcnBvbGF0aW9uIiwic2tpcE9uVmFyaWFibGVzIiwibmVzdEJlZiIsIm5iIiwiaW50ZXJwb2xhdGUiLCJuYSIsIm5lc3RBZnQiLCJuZXN0IiwiY29udGV4dCIsInJlc2V0IiwicG9zdFByb2Nlc3MiLCJwb3N0UHJvY2Vzc29yTmFtZXMiLCJhcHBseVBvc3RQcm9jZXNzb3IiLCJwb3N0UHJvY2Vzc1Bhc3NSZXNvbHZlZCIsImkxOG5SZXNvbHZlZCIsImZvdW5kIiwiZXh0cmFjdGVkIiwiZmFsbGJhY2tOUyIsIm5lZWRzWmVyb1N1ZmZpeExvb2t1cCIsInNob3VsZFVzZUludGxBcGkiLCJuZWVkc0NvbnRleHRIYW5kbGluZyIsImNvZGVzIiwidXRpbHMiLCJoYXNMb2FkZWROYW1lc3BhY2UiLCJmaW5hbEtleXMiLCJhZGRMb29rdXBLZXlzIiwicGx1cmFsU3VmZml4IiwiemVyb1N1ZmZpeCIsInBsdXJhbFNlcGFyYXRvciIsIm9yZGluYWxQcmVmaXgiLCJjb250ZXh0S2V5IiwiY29udGV4dFNlcGFyYXRvciIsInBvc3NpYmxlS2V5IiwicG9wIiwicmV0dXJuTnVsbCIsInJldHVybkVtcHR5U3RyaW5nIiwicmVzb3VyY2VTdG9yZSIsIm9wdGlvbnNLZXlzIiwidXNlT3B0aW9uc1JlcGxhY2VGb3JEYXRhIiwib3B0aW9uIiwiY2FwaXRhbGl6ZSIsInN0cmluZyIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwiTGFuZ3VhZ2VVdGlsIiwic3VwcG9ydGVkTG5ncyIsImdldFNjcmlwdFBhcnRGcm9tQ29kZSIsImZvcm1hdExhbmd1YWdlQ29kZSIsImdldExhbmd1YWdlUGFydEZyb21Db2RlIiwic3BlY2lhbENhc2VzIiwibG93ZXJDYXNlTG5nIiwicGFydCIsImNsZWFuQ29kZSIsImlzU3VwcG9ydGVkQ29kZSIsImxvYWQiLCJub25FeHBsaWNpdFN1cHBvcnRlZExuZ3MiLCJnZXRCZXN0TWF0Y2hGcm9tQ29kZXMiLCJjbGVhbmVkTG5nIiwibG5nT25seSIsInN1cHBvcnRlZExuZyIsImZhbGxiYWNrcyIsImRlZmF1bHQiLCJmYWxsYmFja0NvZGUiLCJmYWxsYmFja0NvZGVzIiwiYWRkQ29kZSIsImZjIiwic2V0cyIsIm5yIiwiX3J1bGVzUGx1cmFsc1R5cGVzIiwiTnVtYmVyIiwibm9uSW50bFZlcnNpb25zIiwiaW50bFZlcnNpb25zIiwic3VmZml4ZXNPcmRlciIsInplcm8iLCJvbmUiLCJ0d28iLCJmZXciLCJtYW55Iiwib3RoZXIiLCJjcmVhdGVSdWxlcyIsInJ1bGVzIiwic2V0IiwibnVtYmVycyIsInBsdXJhbHMiLCJQbHVyYWxSZXNvbHZlciIsImNvbXBhdGliaWxpdHlKU09OIiwiaW5jbHVkZXMiLCJJbnRsIiwiUGx1cmFsUnVsZXMiLCJhZGRSdWxlIiwiZ2V0UnVsZSIsImVyciIsIm5lZWRzUGx1cmFsIiwicnVsZSIsInJlc29sdmVkT3B0aW9ucyIsInBsdXJhbENhdGVnb3JpZXMiLCJnZXRQbHVyYWxGb3Jtc09mS2V5Iiwic29ydCIsInBsdXJhbENhdGVnb3J5MSIsInBsdXJhbENhdGVnb3J5MiIsInBsdXJhbENhdGVnb3J5IiwicHJlcGVuZCIsIm51bWJlciIsInNlbGVjdCIsImdldFN1ZmZpeFJldHJvQ29tcGF0aWJsZSIsImlkeCIsIm5vQWJzIiwiTWF0aCIsImFicyIsInNpbXBsaWZ5UGx1cmFsU3VmZml4IiwicmV0dXJuU3VmZml4IiwiZGVlcEZpbmRXaXRoRGVmYXVsdHMiLCJJbnRlcnBvbGF0b3IiLCJmb3JtYXQiLCJlc2NhcGVWYWx1ZSIsImlPcHRzIiwidXNlUmF3VmFsdWVUb0VzY2FwZSIsInByZWZpeEVzY2FwZWQiLCJzdWZmaXhFc2NhcGVkIiwiZm9ybWF0U2VwYXJhdG9yIiwidW5lc2NhcGVQcmVmaXgiLCJ1bmVzY2FwZVN1ZmZpeCIsIm5lc3RpbmdQcmVmaXgiLCJuZXN0aW5nUHJlZml4RXNjYXBlZCIsIm5lc3RpbmdTdWZmaXgiLCJuZXN0aW5nU3VmZml4RXNjYXBlZCIsIm5lc3RpbmdPcHRpb25zU2VwYXJhdG9yIiwibWF4UmVwbGFjZXMiLCJhbHdheXNGb3JtYXQiLCJyZXNldFJlZ0V4cCIsInJlZ2V4cFN0ciIsInJlZ2V4cCIsInJlZ2V4cFVuZXNjYXBlU3RyIiwicmVnZXhwVW5lc2NhcGUiLCJuZXN0aW5nUmVnZXhwU3RyIiwicmVwbGFjZXMiLCJyZWdleFNhZmUiLCJ2YWwiLCJoYW5kbGVGb3JtYXQiLCJpbnRlcnBvbGF0aW9ua2V5IiwidHJpbSIsImYiLCJtaXNzaW5nSW50ZXJwb2xhdGlvbkhhbmRsZXIiLCJ0b2RvcyIsInJlZ2V4Iiwic2FmZVZhbHVlIiwidG9kbyIsImV4ZWMiLCJtYXRjaGVkVmFyIiwidGVtcCIsImxhc3RJbmRleCIsImNsb25lZE9wdGlvbnMiLCJoYW5kbGVIYXNPcHRpb25zIiwiaW5oZXJpdGVkT3B0aW9ucyIsInNlcCIsIm9wdGlvbnNTdHJpbmciLCJtYXRjaGVkU2luZ2xlUXVvdGVzIiwibWF0Y2hlZERvdWJsZVF1b3RlcyIsIkpTT04iLCJlIiwiZm9ybWF0dGVycyIsImRvUmVkdWNlIiwiZWxlbSIsInJlZHVjZSIsInBhcnNlRm9ybWF0U3RyIiwiZm9ybWF0U3RyIiwiZm9ybWF0TmFtZSIsImZvcm1hdE9wdGlvbnMiLCJvcHRTdHIiLCJjdXJyZW5jeSIsInJhbmdlIiwib3B0cyIsIm9wdCIsInJlc3QiLCJpc05hTiIsInBhcnNlSW50IiwiY3JlYXRlQ2FjaGVkRm9ybWF0dGVyIiwiZm4iLCJjYWNoZSIsImludm9rZUZvcm1hdHRlciIsInN0cmluZ2lmeSIsImZvcm1hdHRlciIsIkZvcm1hdHRlciIsImZvcm1hdHMiLCJOdW1iZXJGb3JtYXQiLCJzdHlsZSIsImRhdGV0aW1lIiwiRGF0ZVRpbWVGb3JtYXQiLCJyZWxhdGl2ZXRpbWUiLCJSZWxhdGl2ZVRpbWVGb3JtYXQiLCJsaXN0IiwiTGlzdEZvcm1hdCIsImFkZCIsImFkZENhY2hlZCIsIm1lbSIsImZvcm1hdHRlZCIsInZhbE9wdGlvbnMiLCJmb3JtYXRQYXJhbXMiLCJsb2NhbGUiLCJyZW1vdmVQZW5kaW5nIiwicSIsInBlbmRpbmciLCJwZW5kaW5nQ291bnQiLCJDb25uZWN0b3IiLCJiYWNrZW5kIiwic3RvcmUiLCJ3YWl0aW5nUmVhZHMiLCJtYXhQYXJhbGxlbFJlYWRzIiwicmVhZGluZ0NhbGxzIiwibWF4UmV0cmllcyIsInJldHJ5VGltZW91dCIsInN0YXRlIiwicXVldWUiLCJxdWV1ZUxvYWQiLCJsYW5ndWFnZXMiLCJjYWxsYmFjayIsInRvTG9hZCIsInRvTG9hZExhbmd1YWdlcyIsInRvTG9hZE5hbWVzcGFjZXMiLCJoYXNBbGxOYW1lc3BhY2VzIiwicmVsb2FkIiwibG9hZGVkIiwiZXJyb3JzIiwiZG9uZSIsImxvYWRlZEtleXMiLCJyZWFkIiwiZmNOYW1lIiwidHJpZWQiLCJ3YWl0IiwicmVzb2x2ZXIiLCJuZXh0Iiwic2V0VGltZW91dCIsImJpbmQiLCJ0aGVuIiwiY2F0Y2giLCJwcmVwYXJlTG9hZGluZyIsImxvYWRPbmUiLCJmYWxsYmFja1ZhbHVlIiwiaXNVcGRhdGUiLCJjbGIiLCJnZXQiLCJpbml0SW1tZWRpYXRlIiwicHJlbG9hZCIsInBhcnRpYWxCdW5kbGVkTGFuZ3VhZ2VzIiwicmV0IiwidERlc2NyaXB0aW9uIiwidHJhbnNmb3JtT3B0aW9ucyIsIm5vb3AiLCJiaW5kTWVtYmVyRnVuY3Rpb25zIiwiaW5zdCIsIm1lbXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZ2V0UHJvdG90eXBlT2YiLCJJMThuIiwibW9kdWxlcyIsImV4dGVybmFsIiwiaXNJbml0aWFsaXplZCIsImlzQ2xvbmUiLCJkZWZPcHRzIiwiY3JlYXRlQ2xhc3NPbkRlbWFuZCIsIkNsYXNzT3JPYmplY3QiLCJsdSIsImxhbmd1YWdlRGV0ZWN0b3IiLCJkZXRlY3Rpb24iLCJzdG9yZUFwaSIsInN0b3JlQXBpQ2hhaW5lZCIsImRlZmVycmVkIiwiZmluaXNoIiwiaW5pdGlhbGl6ZWRTdG9yZU9uY2UiLCJsb2FkUmVzb3VyY2VzIiwidXNlZENhbGxiYWNrIiwiYXBwZW5kIiwicmVzb2x2ZWRMYW5ndWFnZSIsInNldFJlc29sdmVkTGFuZ3VhZ2UiLCJyZWxvYWRSZXNvdXJjZXMiLCJ1c2UiLCJFcnJvciIsImxpIiwibG5nSW5MbmdzIiwiX3RoaXMyIiwiaXNMYW5ndWFnZUNoYW5naW5nVG8iLCJzZXRMbmdQcm9wcyIsInNldExuZyIsImNhY2hlVXNlckxhbmd1YWdlIiwiYXN5bmMiLCJkZXRlY3QiLCJnZXRGaXhlZFQiLCJrZXlQcmVmaXgiLCJfdGhpczMiLCJmaXhlZFQiLCJyZXN1bHRLZXkiLCJzZXREZWZhdWx0TmFtZXNwYWNlIiwibGFzdExuZyIsImxvYWROb3RQZW5kaW5nIiwibG9hZFN0YXRlIiwicHJlY2hlY2siLCJwcmVSZXN1bHQiLCJsb2FkTmFtZXNwYWNlcyIsImxvYWRMYW5ndWFnZXMiLCJwcmVsb2FkZWQiLCJuZXdMbmdzIiwiZGlyIiwicnRsTG5ncyIsImNyZWF0ZUluc3RhbmNlIiwiY2xvbmVJbnN0YW5jZSIsImZvcmtSZXNvdXJjZVN0b3JlIiwibWVyZ2VkT3B0aW9ucyIsIm1lbWJlcnNUb0NvcHkiLCJpbnN0YW5jZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/i18next@23.7.16/node_modules/i18next/dist/esm/i18next.js\n");

/***/ })

};
;